// This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)
// Copyright (c) 2023-2025 Doliam
// This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
// This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

#pragma once

#include "disk.hh"
#include "hash.hh"
#include "serialize.hh"
#include "time.hh"

#include "autodep/env.hh"

// START_OF_VERSIONING
enum class Dflag : uint8_t { // flags for deps, recorded in server book-keeping
	Critical                 // if modified, ignore following deps
,	Essential                // show when generating user oriented graphs
,	IgnoreError              // dont propagate error if dep is in error (Error instead of Err because name is visible from user)
,	Required                 // dep must be buildable (static deps are always required)
,	Static                   // is static dep, for internal use only
,	Full                     // if false, dep is only necessary to compute resources
//
// aliases
,	NRule = Required         // number of Dflag's allowed in rule definition
,	NDyn  = Static           // number of Dflag's allowed in side flags
} ;
// END_OF_VERSIONING
static constexpr ::amap<Dflag,char,N<Dflag>> DflagChars {{
	{ Dflag::Critical    , 'c' }
,	{ Dflag::Essential   , 'E' }
,	{ Dflag::IgnoreError , 'e' }
,	{ Dflag::Required    , 'r' }
,	{ Dflag::Static      , 'S' }
,	{ Dflag::Full        , 'F' }
}} ;
using Dflags = BitMap<Dflag> ;
static_assert(chk_enum_tab(DflagChars)) ;
static constexpr Dflags DflagsDflt       = Dflag::Full                               ;
static constexpr Dflags DflagsDfltStatic = DflagsDflt|Dflag::Essential|Dflag::Static ;
static constexpr Dflags DflagsDfltDyn    = DflagsDflt                                ;
static constexpr Dflags DflagsDfltDepend = DflagsDflt|Dflag::Required                ;

// START_OF_VERSIONING
enum class ExtraDflag : uint8_t { // flags for deps, not recorded in server book-keeping
	Top
,	Ignore
,	ReaddirOk
,	NoStar                        // exclude flags from star patterns (common info for dep and target)
,	CreateEncode                  // used when creating a codec entry while encoding
// aliases
,	NRule = CreateEncode          // number of Dflag's allowed in rule definition
} ;
// END_OF_VERSIONING
static constexpr ::amap<ExtraDflag,char,N<ExtraDflag>> ExtraDflagChars {{
	{ ExtraDflag::Top          , 0   }
,	{ ExtraDflag::Ignore       , 'I' }
,	{ ExtraDflag::ReaddirOk    , 'D' }
,	{ ExtraDflag::NoStar       , 'x' }
,	{ ExtraDflag::CreateEncode , 0   }
}} ;
using ExtraDflags = BitMap<ExtraDflag> ;
static_assert(chk_enum_tab(ExtraDflagChars)) ;
static constexpr ExtraDflags ExtraDflagsDflt       = {}                                 ;
static constexpr ExtraDflags ExtraDflagsDfltStatic = ExtraDflagsDflt|ExtraDflag::NoStar ;
static constexpr ExtraDflags ExtraDflagsDfltDyn    = ExtraDflagsDflt                    ;
static constexpr ExtraDflags ExtraDflagsDfltDepend = ExtraDflagsDflt|ExtraDflag::NoStar ;

// START_OF_VERSIONING
enum class Tflag : uint8_t { // flags for targets, recorded in server book-keeping
	Essential                // show when generating user oriented graphs
,	Incremental              // reads are allowed (before earliest write if any)
,	NoWarning                // warn if target is either uniquified or unlinked and generated by another rule
,	Phony                    // accept that target is not generated
,	Static                   // is static  , for internal use only, only if also a Target
,	Target                   // is a target, for internal use only
//
// aliases
,	NRule = Static           // number of Tflag's allowed in rule definition
,	NDyn  = Phony            // number of Tflag's allowed inside flags
} ;
// END_OF_VERSIONING
static constexpr ::amap<Tflag,char,N<Tflag>> TflagChars {{
	{ Tflag::Essential   , 'E' }
,	{ Tflag::Incremental , 'i' }
,	{ Tflag::NoWarning   , 'w' }
,	{ Tflag::Phony       , 'p' }
,	{ Tflag::Static      , 'S' }
,	{ Tflag::Target      , 'T' }
}} ;
using Tflags = BitMap<Tflag> ;
static_assert(chk_enum_tab(TflagChars)) ;
inline bool static_phony(Tflags tf) {
	return tf[Tflag::Target] && (tf[Tflag::Static]||tf[Tflag::Phony]) ;
}

// START_OF_VERSIONING
// not recorded in server book-keeping
enum class ExtraTflag : uint8_t { // flags for targets, not recorded in server book-keeping
	Top
,	Ignore
,	Optional
,	SourceOk                      // ok to overwrite source files
,	Allow                         // writing to this target is allowed (for use in clmake.target and ltarget)
,	Late                          // target was written for real, not during washing
//
// aliases
,	NRule = Allow                 // number of Tflag's allowed in rule definition
} ;
// END_OF_VERSIONING
static constexpr ::amap<ExtraTflag,char,N<ExtraTflag>> ExtraTflagChars {{
	{ ExtraTflag::Top      , 0   }
,	{ ExtraTflag::Ignore   , 'I' }
,	{ ExtraTflag::Optional , 0   }
,	{ ExtraTflag::SourceOk , 's' }
,	{ ExtraTflag::Allow    , 'a' }
,	{ ExtraTflag::Late     , 0   }
}} ;
using ExtraTflags = BitMap<ExtraTflag> ;
static_assert(chk_enum_tab(ExtraTflagChars)) ;

enum class MatchKind : uint8_t {
	Target
,	SideTarget
,	SideDep
} ;

struct MatchFlags {
	friend ::string& operator+=( ::string& , MatchFlags const& ) ;
	using Kind = MatchKind ;
	// accesses
	bool operator==(MatchFlags const&) const = default ;
	bool operator+ (                 ) const { return +tflags || +dflags || +extra_tflags || +extra_dflags ; }
	//
	Kind kind             () const { return !extra_tflags[ExtraTflag::Allow] ? Kind::SideDep : !tflags[Tflag::Target] ? Kind::SideTarget : Kind::Target ; }
	bool dep_and_target_ok() const { return extra_tflags[ExtraTflag::SourceOk] && !tflags[Tflag::Incremental]                                           ; }
	// services
	MatchFlags  operator~ (              ) const { return { ~tflags , ~dflags , ~extra_tflags , ~extra_dflags } ; }
	MatchFlags  operator| (MatchFlags mfs) const { return ::copy(self)|=mfs                                     ; }
	MatchFlags& operator|=(MatchFlags mfs) {
		tflags       |= mfs.tflags       ;
		dflags       |= mfs.dflags       ;
		extra_tflags |= mfs.extra_tflags ;
		extra_dflags |= mfs.extra_dflags ;
		return self ;
	}
	bool operator>=(MatchFlags mfs) const {
		return
			tflags       >= mfs.tflags
		&&	dflags       >= mfs.dflags
		&&	extra_tflags >= mfs.extra_tflags
		&&	extra_dflags >= mfs.extra_dflags
		;
	}
	// data
	// START_OF_VERSIONING
	Tflags      tflags       = {} ;                                   // if kind>=Target
	Dflags      dflags       = {} ;                                   // if kind>=Dep
	ExtraTflags extra_tflags = {} ;                                   // if kind>=Target
	ExtraDflags extra_dflags = {} ;                                   // if kind>=Dep
	// END_OF_VERSIONING
} ;
inline ::string& operator+=( ::string& os , MatchFlags const& mfs ) { // START_OF_NO_COV
	First first ;
	/**/                   os <<"MatchFlags("                    ;
	if (+mfs.tflags      ) os <<first("",",")<< mfs.tflags       ;
	if (+mfs.extra_tflags) os <<first("",",")<< mfs.extra_tflags ;
	if (+mfs.dflags      ) os <<first("",",")<< mfs.dflags       ;
	if (+mfs.extra_dflags) os <<first("",",")<< mfs.extra_dflags ;
	return                 os <<')'                              ;
}                                                                     // END_OF_NO_COV

// START_OF_VERSIONING
enum class Comment : uint8_t {
	None
// syscalls
,	access
,	canonicalize_file_name
,	chdir
,	chmod
,	chroot
,	creat                  , creat64
,	dlmopen
,	dlopen
,	execv                  , execvDep
,	execve                 , execveDep       , execveat          , execveatDep
,	execvp                 , execvpDep
,	execvpe                , execvpeDep
,	                                           faccessat         , faccessat2
,	fchdir
,	                                           fchmodat
,	fopen                  , fopen64
,	freopen                , freopen64
,	                                           fstatat           , fstatat64
,	                                           futimesat
,	getdents               , getdents64
,	getdirentries          , getdirentries64
,	glob                   , glob64
,	la_objopen
,	la_objsearch
,	link                                     , linkat
,	lstat                  , lstat64
,	lutimes
,	mkdir                                    , mkdirat
,	mkostemp               , mkostemp64
,	mkostemps              , mkostemps64
,	mkstemp                , mkstemp64
,	mkstemps               , mkstemps64
,	mount
,	                                           name_to_handle_at
,	                                           newfstatat
,	oldlstat
,	oldstat
,	open                   , open64          , openat            , openat64     , openat2
,	open_tree
,	opendir
,	readdir                , readdir64       , readdir_r         , readdir64_r
,	readlink                                 , readlinkat
,	realpath
,	rename                                   , renameat          , renameat2
,	rmdir
,	scandir                , scandir64       , scandirat         , scandirat64
,	stat                   , stat64
,	statx
,	symlink                                  , symlinkat
,	truncate               , truncate64
,	unlink                                   , unlinkat
,	utime
,	                                           utimensat
,	utimes
,	                                           __fxstatat        , __fxstatat64
,	                                           __lxstat          , __lxstat64
,	__open                 , __open64
,	__open_2               , __open64_2      , __openat_2        , __openat64_2
,	__open64_nocancel
,	__open_nocancel
,	__readlink__chk                          , __readlinkat_chk
,	__realpath_chk
,	__xstat                , __xstat64
// lmake functions
,	Analyzed
,	ChkDeps            , ChkTargets
,	ComputedCrcs
,	CreateCodec
,	Decode
,	DepAndTarget
,	Depend
,	Encode
,	EndJob             , EndOverhead
,	EnteredNamespace
,	Hot
,	Kill
,	List
,	LostServer
,	OsInfo
,	Panic
,	StartInfo
,	StartJob           , StartOverhead
,	StaticDep          , StaticDepAndTarget
,	StaticExec
,	StaticMatch
,	StaticTarget
,	StaticUnlnk
,	Stderr             , Stdin              , Stdout
,	StillAlive
,	Timeout
,	Target
,	Tmp
,	Trace
,	UnexpectedTarget
,	Unstable
,	UploadedToCache
,	Wash               , Washed
} ;
// END_OF_VERSIONING

// START_OF_VERSIONING
enum class CommentExt : uint8_t {
	Bind
,	Direct
,	Err
,	File
,	Last
,	LdLibraryPath
,	Killed
,	Lnk
,	NoFollow
,	Orig
,	Overlay
,	RunPath
,	Read
,	Reply
,	Stat
,	Tmp
,	Unlnk
,	Verbose
,	Write
} ;
using CommentExts = BitMap<CommentExt> ;
// END_OF_VERSIONING

struct VerboseInfo {
	friend ::string& operator+=( ::string& , VerboseInfo ) ;
	Bool3     ok  = Maybe ;                                     // Maybe is used when info has been masked
	Hash::Crc crc = {}    ;
} ;
inline ::string& operator+=( ::string& os , VerboseInfo dvi ) { // START_OF_NO_COV
	/**/          os <<'('<< dvi.ok  ;
	if (+dvi.crc) os <<','<< dvi.crc ;
	return        os <<')'           ;
}                                                               // END_OF_NO_COV
