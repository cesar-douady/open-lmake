// This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)
// Copyright (c) 2023-2025 Doliam
// This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
// This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

#include "app.hh"

#include "rpc_job.hh"

#include "job_support.hh"
#include "record.hh"

enum class Key : uint8_t { None } ;

enum class Flag : uint8_t {
	Dir
,	List
,	Regexpr
,	Write
//
,	Critical
,	Essential
,	Ignore
,	IgnoreError
,	Incremental
,	NoAllow
,	NoExcludeStar
,	NoRequired
,	NoWarning
,	Phony
,	ReaddirOk
,	SourceOk
} ;

int main( int argc , char* argv[]) {
	Syntax<Key,Flag> syntax {{
		{ Flag::Dir     , { .short_name='z' , .has_arg=true , .doc="dir in which to list targets"         } }
	,	{ Flag::List    , { .short_name='l' ,                 .doc="list targets"                         } }
	,	{ Flag::Regexpr , { .short_name='X' ,                 .doc="args are regexprs"                    } }
	,	{ Flag::Write   , { .short_name='W' ,                 .doc="report a write, in addition to flags" } }
	//
	,	{ Flag::Critical      , { .short_name=DflagChars     [+Dflag     ::Critical   ].second , .doc="if files turn out to be deps, make them critical"                                          } }
	,	{ Flag::Essential     , { .short_name=TflagChars     [+Tflag     ::Essential  ].second , .doc="show when generating user oriented graphs"                                                 } }
	,	{ Flag::IgnoreError   , { .short_name=DflagChars     [+Dflag     ::IgnoreError].second , .doc="if files turn out to be deps, ignore if they are in error"                                 } }
	,	{ Flag::Ignore        , { .short_name=ExtraTflagChars[+ExtraTflag::Ignore     ].second , .doc="ignore writes"                                                                             } }
	,	{ Flag::Incremental   , { .short_name=TflagChars     [+Tflag     ::Incremental].second , .doc="do not rm files before job execution"                                                      } }
	,	{ Flag::NoAllow       , { .short_name=ExtraTflagChars[+ExtraTflag::Allow      ].second , .doc="do not declare files as targets, just inform writing to them if reporting writes"          } }
	,	{ Flag::NoExcludeStar , { .short_name=ExtraDflagChars[+ExtraDflag::NoStar     ].second , .doc="accept regexpr-based flags"                                                                } }
	,	{ Flag::NoRequired    , { .short_name=DflagChars     [+Dflag     ::Required   ].second , .doc="if files turn out to be deps, ignore if they cannot be built"                              } }
	,	{ Flag::NoWarning     , { .short_name=TflagChars     [+Tflag     ::NoWarning  ].second , .doc="do not warn user if uniquified or rm'ed while generated by another job"                    } }
	,	{ Flag::Phony         , { .short_name=TflagChars     [+Tflag     ::Phony      ].second , .doc="accept that targets are not physically generated on disk"                                  } }
	,	{ Flag::ReaddirOk     , { .short_name=ExtraDflagChars[+ExtraDflag::ReaddirOk  ].second , .doc="allow readdir"                                                                             } }
	,	{ Flag::SourceOk      , { .short_name=ExtraTflagChars[+ExtraTflag::SourceOk   ].second , .doc="accept if targets are actually sources and accept them to also be deps if not incremental" } }
	}} ;
	CmdLine<Key,Flag> cmd_line { syntax , argc , argv } ;
	int               rc       = 0                      ;
	::string          out      ;
	//
	if (cmd_line.flags[Flag::List]) {
		//
		if ( cmd_line.args.size() > cmd_line.flags[Flag::Regexpr]                    ) syntax.usage("cannot list targets with args other than a single regexpr"                  ) ;
		if ( +( cmd_line.flags & ~BitMap<Flag>(Flag::Dir,Flag::List,Flag::Regexpr) ) ) syntax.usage("the --list flag is exclusive with any other flag except --dir and --regexpr") ;
		//
		::optional_s dir     ; if ( cmd_line.flags[Flag::Dir]                       ) dir     = cmd_line.flag_args[+Flag::Dir] ;
		::optional_s regexpr ; if ( cmd_line.flags[Flag::Regexpr] && +cmd_line.args ) regexpr = cmd_line.args[0]               ;
		//
		try                       { for( ::string const& t : JobSupport::list( {New,Yes/*enabled*/} , Yes/*write*/ , dir , regexpr ) ) out << t <<'\n' ; }
		catch (::string const& e) { exit(Rc::System,e) ;                                                                                                 }
		//
	} else {
		//
		if (!cmd_line.args) return 0 ;                                                                         // fast path : declare no targets
		for( ::string const& f : cmd_line.args ) if (!f) syntax.usage("cannot declare empty file as target") ;
		//
		AccessDigest ad { .flags{.dflags=DflagsDfltDepend,.extra_dflags=ExtraDflagsDfltDepend} } ;
		//
		if ( cmd_line.flags[Flag::Write        ]) ad.write               =  Yes                     ;
		if ( cmd_line.flags[Flag::Essential    ]) ad.flags.tflags       |=  Tflag     ::Essential   ;
		if ( cmd_line.flags[Flag::Incremental  ]) ad.flags.tflags       |=  Tflag     ::Incremental ;
		if ( cmd_line.flags[Flag::NoWarning    ]) ad.flags.tflags       |=  Tflag     ::NoWarning   ;
		if ( cmd_line.flags[Flag::Phony        ]) ad.flags.tflags       |=  Tflag     ::Phony       ;
		if ( cmd_line.flags[Flag::Ignore       ]) ad.flags.extra_tflags |=  ExtraTflag::Ignore      ;
		if (!cmd_line.flags[Flag::NoAllow      ]) ad.flags.extra_tflags |=  ExtraTflag::Allow       ;
		if ( cmd_line.flags[Flag::SourceOk     ]) ad.flags.extra_tflags |=  ExtraTflag::SourceOk    ;
		if ( cmd_line.flags[Flag::Critical     ]) ad.flags.dflags       |=  Dflag     ::Critical    ;
		if ( cmd_line.flags[Flag::IgnoreError  ]) ad.flags.dflags       |=  Dflag     ::IgnoreError ;
		if ( cmd_line.flags[Flag::NoRequired   ]) ad.flags.dflags       &= ~Dflag     ::Required    ;
		if ( cmd_line.flags[Flag::ReaddirOk    ]) ad.flags.extra_dflags |=  ExtraDflag::ReaddirOk   ;
		if ( cmd_line.flags[Flag::NoExcludeStar]) ad.flags.extra_dflags &= ~ExtraDflag::NoStar      ;
		//
		try                       { JobSupport::target( {New,Yes/*enabled*/} , ::move(cmd_line.args) , ad , cmd_line.flags[Flag::Regexpr] ) ; }
		catch (::string const& e) { exit(Rc::Usage,e) ;                                                                                       }
		//
	}
	if (+out) Fd::Stdout.write(out) ;
	return rc ;
}
