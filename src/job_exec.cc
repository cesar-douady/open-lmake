// This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)
// Copyright (c) 2023-2025 Doliam
// This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
// This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

#include "app.hh"
#include "disk.hh"
#include "fd.hh"
#include "hash.hh"
#include "re.hh"
#include "thread.hh"
#include "time.hh"
#include "trace.hh"

#include "autodep/gather.hh"

#include "rpc_job.hh"
#include "rpc_job_exec.hh"

using namespace Caches ;
using namespace Disk   ;
using namespace Hash   ;
using namespace Re     ;
using namespace Time   ;

::vector<ExecTraceEntry>* g_exec_trace      = nullptr      ;
Gather                    g_gather          ;
JobIdx                    g_job             = 0/*garbage*/ ;
SeqId                     g_seq_id          = 0/*garbage*/ ;
::string                  g_phy_repo_root_s ;
::string                  g_service_start   ;
::string                  g_service_mngt    ;
::string                  g_service_end     ;
::vector<RegExpr>         g_star_targets    ; // the Target flag cannot be processed as the other ones : it must be completely predictible, independently of execution as it has an impact on ...
JobStartRpcReply          g_start_info      ; // ... rule selection
::uset_s                  g_static_targets  ;                // .
SeqId                     g_trace_id        = 0/*garbage*/ ;
::vector_s                g_washed          ;

struct Digest {
	::vmap_s<TargetDigest> targets ;
	::vmap_s<DepDigest   > deps    ;
	::vector<NodeIdx     > crcs    ; // index in targets of entry for which we need to compute a crc
	::string               msg     ;
} ;

JobStartRpcReply get_start_info(ServerSockFd const& server_fd) {
	Trace trace("get_start_info",g_service_start) ;
	bool             found_server = false ;
	JobStartRpcReply res          ;
	try {
		ClientSockFd fd { g_service_start } ;
		fd.set_timeout(Delay(100)) ;          // ensure we dont stay stuck in case server is in the coma : 100s = 1000 simultaneous connections, 10 jobs/s
		throw_unless(+fd) ;
		found_server = true ;
		//    vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		/**/  OMsgBuf().send                     ( fd , JobStartRpcReq({g_seq_id,g_job},server_fd.port()) ) ;
		res = IMsgBuf().receive<JobStartRpcReply>( fd                                                     ) ;
		//    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	} catch (::string const& e) {
		trace("no_start_info",STR(found_server),e) ;
		if      (found_server) exit(Rc::Fail                                                    ) ; // this is typically a ^C
		else if (+e          ) exit(Rc::Fail,"cannot connect to server at",g_service_start,':',e) ; // this may be a server config problem, better to report if verbose
		else                   exit(Rc::Fail,"cannot connect to server at",g_service_start      ) ; // .
	}
	g_exec_trace->emplace_back( New/*date*/ , Comment::startInfo , CommentExt::Reply ) ;
	trace(res) ;
	return res ;
}

Digest analyze(Status status=Status::New) {                                                                                       // status==New means job is not done
	Trace trace("analyze",status,g_gather.accesses.size()) ;
	Digest res             ;                 res.deps.reserve(g_gather.accesses.size()) ;                                         // typically most of accesses are deps
	Pdate  prev_first_read = Pdate::Future ;
	bool   readdir_warned  = false         ;
	//
	for( auto& [file,info] : g_gather.accesses ) {
		static constexpr MatchFlags TargetFlags { .tflags=Tflag::Target , .extra_tflags=ExtraTflag::Allow } ; //!          started
		if (g_static_targets.contains(file))                                  info.update( Pdate() , {.flags=TargetFlags} , false ) ;
		else for( RegExpr const& re : g_star_targets ) if (+re.match(file)) { info.update( Pdate() , {.flags=TargetFlags} , false ) ; break ; }
		//
		MatchFlags flags = info.flags ;
		//
		// handle read_dir
		if ( info.read_dir() && !(flags.extra_dflags[ExtraDflag::ReaddirOk]||flags.tflags[Tflag::Incremental]) ) {                // if incremental, user handle previous values
			res.msg << "read dir without readdir_ok : "<<mk_file(file,No)<<'\n' ;
			if (!readdir_warned) {
				res.msg << "  consider (ordered by decreasing reliability) :\n"                                                 ;
				res.msg << "  - if files non-generated by this job exist in this dir, avoid reading it if possible\n"           ; // XXX? : improve by detecting whether condition is met (is it worth?)
				res.msg << "  - if this is due to python imports, call : lmake.report_import()\n"                               ;
				res.msg << "  - set  : "<<g_start_info.rule<<".side_deps = {'READ_DIR':("<<mk_py_str(file)<<",'readdir_ok')}\n" ;
				res.msg << "  - call : lmake.depend("<<mk_file(file,FileDisplay::Py   )<<",readdir_ok=True)\n"                  ;
				res.msg << "    or   : ldepend -D "  <<mk_file(file,FileDisplay::Shell)<<'\n'                                   ;
				res.msg << "  - set  : "<<g_start_info.rule<<".readdir_ok = True\n"                                             ;
				readdir_warned = true ;
			}
			info.clear_readdir() ;
		}
		//
		Accesses accesses    = info.accesses()                  ;
		bool     was_written = info.first_write()<Pdate::Future ;
		//
		if (file==".") { SWEAR( !accesses && !was_written , info ) ; continue ; }                             // . is only reported when reading dir but otherwise is an external file
		//
		Pdate first_read = info.first_read()                                                    ;
		bool  was_read   = first_read        <Pdate::Future                                     ;
		bool  is_dep     = +accesses || (was_read&&!was_written) || flags.dflags[Dflag::Static] ;
		bool  allow      = info.allow()                                                         ;
		bool  is_tgt     = was_written || allow                                                 ;
		//
		if ( !is_dep && !is_tgt ) {
			trace("ignore ",file) ;
			continue ;
		}
		// handle deps
		if (is_dep) {
			DepDigest dd       { accesses , info.dep_info , false/*err*/ , flags.dflags } ;
			bool      unstable = false                                                    ;
			//
			// if file is not old enough, we make it hot and server will ensure job producing dep was done before this job started
			dd.hot          = info.dep_info.is_a<DepInfoKind::Info>() && !info.dep_info.info().date.avail_at(first_read,g_start_info.ddate_prec) ;
			dd.parallel     = first_read<Pdate::Future && first_read==prev_first_read                                                            ;
			prev_first_read = first_read                                                                                                         ;
			// try to transform date into crc as far as possible
			if      ( dd.is_crc                         )   {}                                                // already a crc => nothing to do
			else if ( !accesses                         )   {}                                                // no access     => nothing to do
			else if ( !info.seen()                      ) { dd.may_set_crc(Crc::None ) ; dd.hot   = false ; } // job has been executed without seeing the file (before possibly writing to it)
			else if ( !dd.sig()                         ) { dd.del_crc(              ) ; unstable = true  ; } // file was absent initially but was seen, it is incoherent even if absent finally
			else if ( was_written                       )   {}                                                // cannot check stability, clash will be detected in server if any
			else if ( FileSig sig{file} ; sig!=dd.sig() ) { dd.del_crc(              ) ; unstable = true  ; } // file dates are incoherent from first access to end of job, no stable content
			else if ( sig.tag()==FileTag::Empty         )   dd.may_set_crc(Crc::Empty) ;                      // crc is easy to compute (empty file), record it
			else if ( !Crc::s_sense(accesses,sig.tag()) )   dd.may_set_crc(sig.tag() ) ;                      // just record the tag if enough to match (e.g. accesses==Lnk and tag==Reg)
			//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
			res.deps.emplace_back( file , dd ) ;
			//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			if (status!=Status::New) { // only trace for user at end of job as intermediate analyses are of marginal interest for user
				//                                            Pdate
				if      (unstable) g_exec_trace->emplace_back( New , Comment::unstable , CommentExts() , file ) ;
				else if (dd.hot  ) g_exec_trace->emplace_back( New , Comment::hot      , CommentExts() , file ) ;
			}
			if (dd.hot) trace("dep_hot",dd,info.dep_info,first_read,g_start_info.ddate_prec,file) ;
			else        trace("dep    ",dd,                                                 file) ;
		}
		// handle targets
		if (is_tgt) {
			FileStat     st        ;                                                                                                  if (::lstat(file.c_str(),/*out*/&st)!=0) st.st_mode = 0 ;
			FileSig      sig       { st }                                                                                           ;
			TargetDigest td        { .tflags=flags.tflags , .extra_tflags=flags.extra_tflags }                                      ;
			bool         unlnk     = !sig                                                                                           ;
			bool         mandatory = td.tflags[Tflag::Target] && td.tflags[Tflag::Static] && !td.extra_tflags[ExtraTflag::Optional] ;
			//
			if (is_dep) td.tflags    |= Tflag::Incremental ;                                                           // if is_dep, previous target state is guaranteed by being a dep, use it
			/**/        td.pre_exist  = info.seen()        ;
			/**/        td.written    = was_written        ;
			if ( !allow || (is_dep&&!flags.dep_and_target_ok()) ) {                                                    // if SourceOk => ok to simultaneously be a dep and a target
				const char* written_msg = unlnk ? "unlinked" : was_written ? "written to" : "declared as target" ;
				if (flags.dflags[Dflag::Static]) { //!    date
					if (unlnk) g_exec_trace->emplace_back( New , Comment::staticDepAndTarget , CommentExt::Unlnk , file ) ;
					else       g_exec_trace->emplace_back( New , Comment::staticDepAndTarget , CommentExts()     , file ) ;
					res.msg << "static dep was "<<written_msg<<" : "<<mk_file(file)<<'\n' ;
					if (!flags.extra_tflags[ExtraTflag::SourceOk]) {
						res.msg << "  if file is a source, consider calling :\n"                                  ;
						res.msg << "       lmake.target("<<mk_file(file,FileDisplay::Py   )<<",source_ok=True)\n" ;
						res.msg << "    or ltarget -s "  <<mk_file(file,FileDisplay::Shell)<<'\n'                 ;
					}
				} else if (!unlnk) {                                                                                   // if file is unlinked, ignore writing to it even if not allowed ...
					if (!allow) {                                                                                      // ... as it is common practice to write besides the final target and mv to it
						g_exec_trace->emplace_back( New/*date*/ , Comment::unexpectedTarget , CommentExts() , file ) ;
						res.msg << "file was unexpectedly "<<written_msg<<" : "<<mk_file(file)<<'\n' ;
					} else {
						bool        read_lnk = false   ;
						const char* read     = nullptr ;
						if      (accesses[Access::Reg ]       )   read = "read"        ;
						else if (accesses[Access::Lnk ]       ) { read = "readlink'ed" ; read_lnk = true ; }
						else if (accesses[Access::Stat]       )   read = "stat'ed"     ;
						else if (flags.dflags[Dflag::Required])   read = "required"    ;
						else                                      read = "accessed"    ;
						g_exec_trace->emplace_back( New/*date*/ , Comment::depAndTarget , CommentExts() , file ) ;
						/**/          res.msg << "file was "<<read<<" and later "<<written_msg<<" : "<<mk_file(file)<<'\n'               ;
						if (read_lnk) res.msg << "  note : readlink is implicit when writing to a file while following symbolic links\n" ;
					}
					res.msg << "  consider calling before file is accessed :\n"                ;
					res.msg << "       lmake.target("<<mk_file(file,FileDisplay::Py   )<<")\n" ;
					res.msg << "    or ltarget "     <<mk_file(file,FileDisplay::Shell)<<'\n'  ;
				}
			}
			if (unlnk) {
				td.crc = Crc::None ;
			} else if ( was_written || (+sig&&st.st_nlink>1) ) {                                                           // file may change through another link if any
				if ( status==Status::Killed || !td.tflags[Tflag::Target] ) { td.sig = sig ; td.crc = td.sig.tag() ;      } // no crc if meaningless
				else                                                         res.crcs.emplace_back(res.targets.size()) ;   // record index in res.targets for deferred (parallel) crc computation
			}
			if ( mandatory && !td.tflags[Tflag::Phony] && unlnk && status==Status::Ok )                                    // target is expected, not produced and no more important reason
				res.msg << "missing static target " << mk_file(file,No/*exists*/) << '\n' ;                                // warn specifically
			//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
			res.targets.emplace_back(file,td) ;
			//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			trace("target ",td,STR(unlnk),STR(was_written),st.st_nlink,file) ;
		}
	}
	g_exec_trace->emplace_back( New/*date*/ , Comment::analyzed ) ;
	trace("done",res.deps.size(),res.targets.size(),res.crcs.size(),res.msg) ;
	return res ;
}

void chk_deps_cb( ::vmap_s<TargetDigest>&/*out*/ targets , ::vmap_s<DepDigest>&/*out*/ deps ) {
	Digest digest = analyze() ;
	targets = ::move(digest.targets) ;
	deps    = ::move(digest.deps   ) ;
}

static const ::string StdPath = STD_PATH ;
static const ::uset_s SpecialWords {
	":"       , "."         , "{"        , "}"       , "!"
,	"alias"
,	"bind"    , "break"     , "builtin"
,	"caller"  , "case"      , "cd"       , "command" , "continue" , "coproc"
,	"declare" , "do"        , "done"
,	"echo"    , "elif"      , "else"     , "enable"  , "esac"     , "eval"    , "exec" , "exit" , "export"
,	"fi"      , "for"       , "function"
,	"getopts"
,	"if"      , "in"
,	"hash"    , "help"
,	"let"     , "local"     , "logout"
,	"mapfile"
,	"printf"  , "pwd"
,	"read"    , "readarray" , "readonly" , "return"
,	"select"  , "shift"     , "source"
,	"test"    , "then"      , "time"     , "times"   , "type"     , "typeset" , "trap"
,	"ulimit"  , "umask"     , "unalias"  , "unset"   , "until"
,	"while"
} ;

static const ::vector_s SpecialVars {
	"BASH_ALIASES"
,	"BASH_ENV"
,	"BASHOPTS"
,	"ENV"
,	"IFS"
,	"SHELLOPTS"
} ;

enum class State : uint8_t {
	None
,	SingleQuote
,	DoubleQuote
,	BackSlash
,	DoubleQuoteBackSlash // after a \ within ""
} ;

static bool is_special( char c , int esc_lvl , bool first=false ) {
	switch (c) {
		case '$' :
		case '`' :            return true ;               // recognized even in ""
		case '#' :
		case '&' :
		case '(' : case ')' :
		case '*' :
		case ';' :
		case '<' : case '>' :
		case '?' :
		case '[' : case ']' :
		case '|' :            return esc_lvl<2          ; // recognized anywhere if not quoted
		case '~' :            return esc_lvl<2 && first ; // recognized as first char of any word
		case '=' :            return esc_lvl<1          ; // recognized only in first word
		default  :            return false ;
	}
}

// replace call to BASH by direct execution if a single command can be identified
bool/*done*/ mk_simple( ::vector_s&/*inout*/ res , ::string const& cmd , ::map_ss const& cmd_env ) {
	if (res.size()!=1) return false/*done*/ ;                                                        // options passed to bash
	if (res[0]!=BASH ) return false/*done*/ ;                                                        // not standard bash
	//
	for( ::string const& v : SpecialVars )
		if (cmd_env.contains(v)) return false/*done*/ ;                                              // complex environment
	//
	::vector_s v          { {} }        ;
	State      state      = State::None ;
	bool       slash_seen = false       ;
	bool       word_seen  = false       ;                                                            // if true <=> a new argument has been detected, maybe empty because of quotes
	bool       nl_seen    = false       ;
	bool       cmd_seen   = false       ;
	//
	auto special_cmd = [&]()->bool {
		return v.size()==1 && !slash_seen && SpecialWords.contains(v[0]) ;
	} ;
	//
	for( char c : cmd ) {
		slash_seen |= c=='/' && v.size()==1 ;                                                        // / are only recorgnized in first word
		switch (state) {
			case State::None :
				if (is_special( c , v.size()>1/*esc_lvl*/ , !v.back() )) return false/*done*/ ;      // complex syntax
				switch (c) {
					case '\n' : nl_seen |= cmd_seen ; [[fallthrough]] ;
					case ' '  :
					case '\t' :
						if (cmd_seen) {
							if (special_cmd()) return false/*done*/ ;                                // need to search in $PATH and may be a reserved word or builtin command
							if (word_seen) {
								v.emplace_back() ;
								word_seen = false ;
								cmd_seen  = true  ;
							}
						}
					break ;
					case '\\' : state = State::BackSlash   ;                                      if (nl_seen) return false/*done*/ ; break ; // multi-line
					case '\'' : state = State::SingleQuote ;                                      if (nl_seen) return false/*done*/ ; break ; // .
					case '"'  : state = State::DoubleQuote ;                                      if (nl_seen) return false/*done*/ ; break ; // .
					default   : v.back().push_back(c)      ; word_seen = true ; cmd_seen = true ; if (nl_seen) return false/*done*/ ; break ; // .
				}
			break ;
			case State::BackSlash :
				v.back().push_back(c) ;
				state     = State::None ;
				word_seen = true        ;
			break ;
			case State::SingleQuote :
				if (c=='\'') { state = State::None ; word_seen = true ; }
				else           v.back().push_back(c) ;
			break ;
			case State::DoubleQuote :
				if (is_special( c , 2/*esc_lvl*/ )) return false/*done*/ ;                                                                    // complex syntax
				switch (c) {
					case '\\' : state = State::DoubleQuoteBackSlash ;                    break ;
					case '"'  : state = State::None                 ; word_seen = true ; break ;
					default   : v.back().push_back(c)               ;
				}
			break ;
			case State::DoubleQuoteBackSlash :
				if (!is_special( c , 2/*esc_lvl*/ ))
					switch (c) {
						case '\\' :
						case '\n' :
						case '"'  :                            break ;
						default   : v.back().push_back('\\') ;
					}
				v.back().push_back(c) ;
				state = State::DoubleQuote ;
			break ;
		}
	}
	if (state!=State::None)   return false/*done*/ ;                                                                                          // syntax error
	if (!word_seen        ) { SWEAR(!v.back()) ; v.pop_back() ; }                                                                             // suppress empty entry created by space after last word
	if (!v                )   return false/*done*/ ;                                                                                          // no command
	if (special_cmd()     )   return false/*done*/ ;                                                                                          // complex syntax
	if (!slash_seen) {                                                                                                                        // search PATH
		if (cmd_env.contains("EXECIGNORE")) return false/*done*/ ;                                                                            // complex environment
		auto            it       = cmd_env.find("PATH")                     ;
		::string const& path     = it==cmd_env.end() ? StdPath : it->second ;
		::vector_s      path_vec = split(path,':')                          ;
		::string      &  v0      = v[0]                                     ;
		for( ::string& p : split(path,':') ) {
			::string candidate = with_slash(::move(p)) + v0 ;
			if (FileInfo(candidate).tag()==FileTag::Exe) {
				v0 = ::move(candidate) ;
				goto CmdFound ;
			}
		}
		return false/*done*/ ;                                                                                                                // command not found
	CmdFound : ;
	}
	res = ::move(v) ;
	return true/*done*/ ;
}

::string g_to_unlnk ;                                                             // XXX> : suppress when CentOS7 bug is fixed
::vector_s cmd_line(::map_ss const& cmd_env) {
	static const size_t ArgMax = ::sysconf(_SC_ARG_MAX) ;
	::vector_s res = ::move(g_start_info.interpreter) ;                           // avoid copying as interpreter is used only here
	if (g_start_info.use_script) {
		// XXX> : fix the bug with CentOS7 where the write seems not to be seen and old script is executed instead of new one
	//	::string cmd_file = cat(PrivateAdminDirS,"cmds/",g_start_info.small_id) ; // correct code
		::string cmd_file = cat(PrivateAdminDirS,"cmds/",g_seq_id) ;
		AcFd( dir_guard(cmd_file) , FdAction::Create ).write(g_start_info.cmd) ;
		res.reserve(res.size()+1) ;
		res.push_back(mk_abs(cmd_file,*g_repo_root_s)) ;                          // provide absolute script so as to support cwd
		g_to_unlnk = ::move(cmd_file) ;
	} else {
		// large commands are forced use_script=true in server
		SWEAR( g_start_info.cmd.size()<=ArgMax/2 , g_start_info.cmd.size() ) ;    // env+cmd line must not be larger than ARG_MAX, keep some margin for env
		if (!mk_simple( res , g_start_info.cmd , cmd_env )) {                     // res is set if simple
			res.reserve(res.size()+2) ;
			res.emplace_back("-c"                    ) ;
			res.push_back   (::move(g_start_info.cmd)) ;
		}
	}
	return res ;
}

void crc_thread_func( size_t id , vmap_s<TargetDigest>* targets , ::vector<NodeIdx> const* crcs , ::string* msg , Mutex<MutexLvl::JobExec>* msg_mutex , ::vector<FileInfo>* target_fis , size_t* sz ) {
	static Atomic<NodeIdx> crc_idx = 0 ;
	t_thread_key = '0'+id ;
	Trace trace("crc_thread_func",targets->size(),crcs->size()) ;
	NodeIdx cnt = 0 ;                                                      // cnt is for trace only
	*sz = 0 ;
	for( NodeIdx ci=0 ; (ci=crc_idx++)<crcs->size() ; cnt++ ) {
		NodeIdx                 ti     = (*crcs)[ci]    ;
		::pair_s<TargetDigest>& e      = (*targets)[ti] ;
		Pdate                   before = New            ;
		FileInfo                fi     ;
		try {
			//             vvvvvvvvvvvvvvvvvvvvvvvvvv
			e.second.crc = Crc( e.first , /*out*/fi ) ;
			//             ^^^^^^^^^^^^^^^^^^^^^^^^^^
		} catch (::string const& e) {                                      // START_OF_NO_COV defensive programming
			Lock lock{*msg_mutex} ;
			*msg <<set_nl<< "while computing checksum for "<<e<<" : "<<e ;
		}                                                                  // END_OF_NO_COV
		e.second.sig       = fi.sig() ;
		(*target_fis)[ti]  = fi       ;
		*sz               += fi.sz    ;
		trace("crc_date",ci,before,Pdate(New)-before,e.second.crc,e.second.sig,e.first) ;
		if (!e.second.crc.valid()) {
			Lock lock{*msg_mutex} ;
			*msg <<set_nl<< "cannot compute checksum for "<<e.first ;
		}
	}
	trace("done",cnt) ;
}

::string/*msg*/ compute_crcs( Digest& digest , ::vector<FileInfo>&/*out*/ target_fis , size_t&/*out*/ total_sz ) {
	size_t                            n_threads = thread::hardware_concurrency() ;
	if (n_threads<1                 ) n_threads = 1                              ;
	if (n_threads>8                 ) n_threads = 8                              ;
	if (n_threads>digest.crcs.size()) n_threads = digest.crcs.size()             ;
	//
	Trace trace("compute_crcs",digest.crcs.size(),n_threads) ;
	::string                 msg       ;
	Mutex<MutexLvl::JobExec> msg_mutex ;
	::vector<size_t>         szs       ( n_threads ) ;
	target_fis.resize(digest.targets.size()) ;
	{	::vector<::jthread> crc_threads ; crc_threads.reserve(n_threads) ;
		for( size_t i  : iota(n_threads) ) crc_threads.emplace_back( crc_thread_func , i , &digest.targets , &digest.crcs , &msg , &msg_mutex , &target_fis , &szs[i] ) ;
	}
	total_sz = 0 ;
	for( size_t s : szs ) total_sz += s ;
	g_exec_trace->emplace_back( New/*date*/ , Comment::computedCrcs ) ;
	return msg ;
}

int main( int argc , char* argv[] ) {
	Pdate        start_overhead { New } ;
	ServerSockFd server_fd      { New } ;              // server socket must be listening before connecting to server and last to the very end to ensure we can handle heartbeats
	uint64_t     upload_key     = 0     ;              // key used to identify temporary data uploaded to the cache
	//
	swear_prod(argc==8,argc) ;                         // syntax is : job_exec server:port/*start*/ server:port/*mngt*/ server:port/*end*/ seq_id job_idx repo_root trace_file
	g_service_start   =                     argv[1]  ;
	g_service_mngt    =                     argv[2]  ;
	g_service_end     =                     argv[3]  ;
	g_seq_id          = from_string<SeqId >(argv[4]) ;
	g_job             = from_string<JobIdx>(argv[5]) ;
	g_phy_repo_root_s =                     argv[6]  ; // passed early so we can chdir and trace early
	g_trace_id        = from_string<SeqId >(argv[7]) ;
	//
	g_repo_root_s = new ::string{g_phy_repo_root_s} ;  // no need to search for it
	//
	g_trace_file = new ::string{cat(g_phy_repo_root_s,PrivateAdminDirS,"trace/job_exec/",g_trace_id)} ;
	//
	JobEndRpcReq end_report { {g_seq_id,g_job} } ;
	end_report.digest   = {.status=Status::EarlyErr} ; // prepare to return an error, so we can goto End anytime
	end_report.end_date = start_overhead             ;
	g_exec_trace        = &end_report.exec_trace     ;
	g_exec_trace->emplace_back( start_overhead , Comment::startOverhead ) ;
	//
	if (::chdir(g_phy_repo_root_s.c_str())!=0) {                                                    // START_OF_NO_COV defensive programming
		get_start_info(server_fd) ;                                                                 // getting start_info is useless, but necessary to be allowed to report end
		end_report.msg_stderr.msg << "cannot chdir to root : "<<no_slash(g_phy_repo_root_s)<<'\n' ;
		goto End ;
	}                                                                                               // END_OF_NO_COV
	Trace::s_sz = 10<<20 ;                                                                          // this is more than enough
	block_sigs({SIGCHLD}) ;                                                                         // necessary to capture it using signalfd
	app_init(false/*read_only_ok*/,No/*chk_version*/,Maybe/*cd_root*/) ;                            // dont cd, but check we are in a repo
	//
	{	Trace trace("main",Pdate(New),::span<char*>(argv,argc)) ;
		trace("pid",::getpid(),::getpgrp()) ;
		trace("start_overhead",start_overhead) ;
		//
		g_start_info = get_start_info(server_fd) ;
		if (!g_start_info) return 0 ;                                                                                                   // server ask us to give up
		try                       { g_start_info.job_space.mk_canon(g_phy_repo_root_s) ; }
		catch (::string const& e) { end_report.msg_stderr.msg += e ; goto End ;          }                                              // NO_COV defensive programming
		//
		if (+g_start_info.job_space.repo_view_s) g_repo_root_s = new ::string{g_start_info.job_space.repo_view_s} ;
		//
		NfsGuard nfs_guard { g_start_info.autodep_env.file_sync } ;
		//
		try {
			end_report.msg_stderr.msg += ensure_nl(do_file_actions( /*out*/g_washed , ::move(g_start_info.pre_actions) , nfs_guard )) ;
		} catch (::string const& e) {                                                                                                   // START_OF_NO_COV defensive programming
			trace("bad_file_actions",e) ;
			end_report.msg_stderr.msg += ensure_nl(e)        ;
			end_report.digest.status   = Status::LateLostErr ;
			goto End ;
		}                                                                                                                               // END_OF_NO_COV
		Pdate washed { New } ;
		g_exec_trace->emplace_back( washed , Comment::washed ) ;
		//
		SWEAR( !end_report.phy_tmp_dir_s , end_report.phy_tmp_dir_s ) ;
		{	auto it = g_start_info.env.begin() ;
			for(; it!=g_start_info.env.end() ; it++ ) if (it->first=="TMPDIR") break ;
			if ( it==g_start_info.env.end() || +it->second ) {                                                                          // if TMPDIR is set and empty, no tmp dir is prepared/cleaned
				if (g_start_info.keep_tmp) {
					end_report.phy_tmp_dir_s << g_phy_repo_root_s<<AdminDirS<<"tmp/"<<g_job<<'/' ;
				} else {
					// use seq id instead of small id to make tmp dir to ensure that even if user mistakenly record tmp dir name, there no chance of porosity between jobs
					// as with small id, by the time the (bad) old tmp dir is referenced by a new job, it may be in use by another job
					// such a situation cannot occur with seq id
					if      (it==g_start_info.env.end()       ) {}
					else if (it->second!=PassMrkr             ) end_report.phy_tmp_dir_s << with_slash(it->second       )<<g_start_info.key<<'/'<<g_seq_id<<'/' ;
					else if (has_env("TMPDIR")                ) end_report.phy_tmp_dir_s << with_slash(get_env("TMPDIR"))<<g_start_info.key<<'/'<<g_seq_id<<'/' ;
					if      (!end_report.phy_tmp_dir_s        ) end_report.phy_tmp_dir_s << g_phy_repo_root_s<<AdminDirS<<"auto_tmp/"           <<g_seq_id<<'/' ;
					else if (!is_abs(end_report.phy_tmp_dir_s)) {
						end_report.msg_stderr.msg << "$TMPDIR ("<<end_report.phy_tmp_dir_s<<") must be absolute" ;
						goto End ;
					}
				}
			}
		}
		//
		::map_ss              cmd_env         ;
		::vmap_s<MountAction> enter_actions   ;
		::string              top_repo_root_s ;
		try {
			if (
				g_start_info.enter(
					/*out*/enter_actions
				,	/*out*/cmd_env
				,	/*out*/end_report.dyn_env
				,	/*out*/g_gather.first_pid
				,	/*out*/top_repo_root_s
				,	       *g_lmake_root_s
				,	       g_phy_repo_root_s
				,	       end_report.phy_tmp_dir_s
				,	       g_seq_id
				)
			) {
				RealPath real_path { g_start_info.autodep_env } ;
				for( auto& [f,a] : enter_actions ) {
					RealPath::SolveReport sr = real_path.solve(f,true/*no_follow*/) ;
					for( ::string& l : sr.lnks ) //!                                                                                                    late
						/**/                            { FileInfo fi{l      } ; g_gather.new_access(washed,::move(l      ),{.accesses= Access::Lnk },fi,    Comment::mount,CommentExt::Lnk  ) ; }
					if (sr.file_loc<=FileLoc::Dep) {
						if      (a==MountAction::Read ) { FileInfo fi{sr.real} ; g_gather.new_access(washed,::move(sr.real),{.accesses=~Access::Stat},fi,    Comment::mount,CommentExt::Read ) ; }
						else if (sr.file_accessed==Yes) { FileInfo fi{sr.real} ; g_gather.new_access(washed,::move(sr.real),{.accesses= Access::Lnk },fi,    Comment::mount,CommentExt::Read ) ; }
					}
					if (sr.file_loc<=FileLoc::Repo) {                                                                                   // writing lasts for the whole job
						if      (a==MountAction::Write) { FileInfo fi{       } ; g_gather.new_access(washed,::move(sr.real),{.write=Yes             },fi,Yes,Comment::mount,CommentExt::Write) ; }
					}
				}
				g_exec_trace->emplace_back( New/*date*/ , Comment::enteredNamespace ) ;
			}
			g_start_info.job_space.update_env(
				/*inout*/cmd_env
			,	         *g_lmake_root_s
			,	         g_phy_repo_root_s
			,	         end_report.phy_tmp_dir_s
			,	         g_start_info.autodep_env.sub_repo_s
			,	         g_seq_id
			,	         g_start_info.small_id
			) ;
			//
		} catch (::string const& e) {
			end_report.msg_stderr.msg += e ;
			goto End ;
		}
		g_start_info.autodep_env.fast_host        = host()                                                                      ;       // host on which fast_report_pipe works
		g_start_info.autodep_env.fast_report_pipe = cat(top_repo_root_s,PrivateAdminDirS,"fast_reports/",g_start_info.small_id) ;       // fast_report_pipe is a pipe and only works locally
		g_start_info.autodep_env.views            = g_start_info.job_space.flat_phys()                                          ;
		trace("prepared",g_start_info.autodep_env) ;
		//
		g_gather.addr             =        g_start_info.addr           ;
		g_gather.as_session       =        true                        ;
		g_gather.nice             =        g_start_info.nice           ;
		g_gather.autodep_env      = ::move(g_start_info.autodep_env  ) ;
		g_gather.chk_deps_cb      =        chk_deps_cb                 ;
		g_gather.env              =        &cmd_env                    ;
		g_gather.exec_trace       =        g_exec_trace                ;
		g_gather.job              =        g_job                       ;
		g_gather.kill_sigs        = ::move(g_start_info.kill_sigs    ) ;
		g_gather.live_out         =        g_start_info.live_out       ;
		g_gather.method           =        g_start_info.method         ;
		g_gather.network_delay    =        g_start_info.network_delay  ;
		g_gather.no_tmp           =       !end_report.phy_tmp_dir_s    ;
		g_gather.seq_id           =        g_seq_id                    ;
		g_gather.server_master_fd = ::move(server_fd                 ) ;
		g_gather.service_mngt     =        g_service_mngt              ;
		g_gather.timeout          =        g_start_info.timeout        ;
		//
		if (!g_start_info.method)                                                                             // if no autodep, consider all static deps are fully accessed as we have no precise report
			for( auto& [d,dd_edf] : g_start_info.deps ) if (dd_edf.first.dflags[Dflag::Static]) {
				DepDigest& dd = dd_edf.first ;
				dd.accesses = ~Accesses() ;
				if ( dd.is_crc && !dd.crc().valid() ) dd.set_sig(FileSig(d)) ;
			}
		//
		for( auto& [d,dd_edf] : g_start_info.deps ) {
			DepDigest  & dd       = dd_edf.first          ;
			ExtraDflags& edf      = dd_edf.second         ;
			bool         is_stdin = d==g_start_info.stdin ;
			if (is_stdin) {                                                                                   // stdin is read
				if (!dd.accesses) dd.set_sig(FileInfo(d)) ;                                                   // record now if not previously accessed
				dd.accesses |= Access::Reg ;
			}
			g_gather.new_access( washed , ::move(d) , {.accesses=dd.accesses,.flags{.dflags=dd.dflags,.extra_dflags=edf}} , dd , is_stdin?Comment::stdin:Comment::staticDep ) ;
		}
		for( auto& [dt,mf] : g_start_info.static_matches ) {
			if (mf.tflags[Tflag::Target]) {
				g_static_targets.insert(dt) ;
				mf.tflags       &= ~Tflag     ::Target ;
				mf.extra_tflags &= ~ExtraTflag::Allow  ;
			}
			if (mf.extra_tflags[ExtraTflag::Optional]) {                                                      // consider Optional as a star target with a fixed pattern
				if (+mf) g_gather.pattern_flags.emplace_back( Re::escape(dt) , ::pair(washed,mf) ) ;          // fast path : no need to match against a pattern that brings nothing
			} else {
				g_gather.new_access( washed , ::move(dt) , {.flags=mf} , DepInfo() , Comment::staticMatch ) ; // always insert an entry for static targets, even with no flags
			}
		}
		for( auto& [p ,mf] : g_start_info.star_matches ) {
			if (mf.tflags[Tflag::Target]) {
				g_star_targets.push_back(p) ;                                       // XXX : find a way to compile p only once when put in both g_star_targets and g_gather.pattern_flags
				mf.tflags       &= ~Tflag     ::Target ;
				mf.extra_tflags &= ~ExtraTflag::Allow  ;
			}
			if (+mf) g_gather.pattern_flags.emplace_back( p , ::pair(washed,mf) ) ; // fast path : no need to match against a pattern that brings nothing
		}
		for( ::string& t : g_washed )
			g_gather.new_access( washed , ::move(t) , {.write=Yes} , DepInfo() , No/*late*/ , Comment::wash ) ;
		//                                                                      err_ok
		if (+g_start_info.stdin) g_gather.child_stdin = Fd( g_start_info.stdin , true  ) ;
		else                     g_gather.child_stdin = Fd( "/dev/null"        , false ) ;
		g_gather.child_stdin.no_std() ;
		g_gather.child_stderr = Child::PipeFd ;
		if (!g_start_info.stdout) {
			g_gather.child_stdout = Child::PipeFd ;
		} else {
			g_gather.child_stdout = Fd( dir_guard(g_start_info.stdout) , true/*err_ok*/ , FdAction::Create ) ;
			g_gather.new_access( washed , ::copy(g_start_info.stdout) , {.write=Yes} , DepInfo() , Yes/*late*/ , Comment::stdout ) ; // writing to stdout last for the whole job
			g_gather.child_stdout.no_std() ;
		}
		g_gather.cmd_line = cmd_line(cmd_env) ;
		Status status ;
		//                                   vvvvvvvvvvvvvvvvvvvvv
		try                       { status = g_gather.exec_child() ;            }
		//                                   ^^^^^^^^^^^^^^^^^^^^^
		catch (::string const& e) { end_report.msg_stderr.msg += e ; goto End ; }                                                    // NO_COV defensive programming
		struct rusage rsrcs ; ::getrusage(RUSAGE_CHILDREN,&rsrcs) ;
		//
		if (+g_to_unlnk) unlnk(g_to_unlnk) ;                                                                                         // XXX> : suppress when CentOS7 bug is fixed
		//
		Digest digest = analyze(status) ;
		trace("analysis",g_gather.start_date,g_gather.end_date,status,g_gather.msg,digest.msg) ;
		//
		::vector<FileInfo> target_fis ;
		end_report.msg_stderr.msg += compute_crcs( digest , /*out*/target_fis , /*out*/end_report.total_sz ) ;
		//
		if (g_start_info.cache) {
			try {
				upload_key = g_start_info.cache->upload( digest.targets , target_fis , g_start_info.z_lvl ) ;
				trace("cache",upload_key) ;
			} catch (::string const& e) {
				trace("cache_upload_throw",e) ;
				end_report.msg_stderr.msg <<"cannot cache : "<<e<<'\n' ;
			}
			CommentExts ces ; if (!upload_key) ces |= CommentExt::Err ;
			g_exec_trace->emplace_back( New/*date*/ , Comment::uploadedToCache , ces , cat(g_start_info.cache->tag(),':',g_start_info.z_lvl) ) ;
		}
		//
		if (+g_start_info.autodep_env.file_sync) {                                                                                   // fast path : avoid listing targets & guards if !file_sync
			for( auto const& [t,_] : digest.targets  ) nfs_guard.change(t) ;
			for( auto const&  f    : g_gather.guards ) nfs_guard.change(f) ;
		}
		//
		if ( status==Status::Ok && ( +digest.msg || (+g_gather.stderr&&!g_start_info.stderr_ok) ) )
			status = Status::Err ;
		//
		/**/                        end_report.msg_stderr.msg += g_gather.msg ;
		if (status!=Status::Killed) end_report.msg_stderr.msg += digest  .msg ;
		JobStats stats {
			.mem = size_t(rsrcs.ru_maxrss<<10)
		,	.cpu = Delay(rsrcs.ru_utime) + Delay(rsrcs.ru_stime)
		,	.job = g_gather.end_date-g_gather.start_date
		} ;
		end_report.digest = {
			.upload_key = upload_key
		,	.targets    = ::move(digest.targets)
		,	.deps       = ::move(digest.deps   )
		,	.cache_idx  = g_start_info.cache_idx
		,	.status     = status
		} ;
		end_report.end_date          =        g_gather.end_date  ;
		end_report.stats             = ::move(stats            ) ;
		end_report.msg_stderr.stderr = ::move(g_gather.stderr  ) ;
		end_report.stdout            = ::move(g_gather.stdout  ) ;
		end_report.wstatus           =        g_gather.wstatus   ;
	}
End :
	{	Trace trace("end",end_report.digest.status) ;
		end_report.digest.has_msg_stderr = +end_report.msg_stderr ;
		try {
			ClientSockFd fd           { g_service_end } ;
			Pdate        end_overhead = New             ;
			g_exec_trace->emplace_back( end_overhead , Comment::endOverhead , CommentExts() , cat(end_report.digest.status) ) ;
			end_report.digest.exec_time      = end_overhead - start_overhead ;                                                       // measure overhead as late as possible
			//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
			OMsgBuf().send( fd , end_report ) ;
			//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			trace("done",end_overhead) ;
		} catch (::string const& e) {
			if (+upload_key) g_start_info.cache->dismiss(upload_key) ;                                                               // suppress temporary data if server cannot handle them
			exit(Rc::Fail,"after job execution : ",e) ;
		}
	}
	try                       { g_start_info.exit() ;                             }
	catch (::string const& e) { exit(Rc::Fail,"cannot cleanup namespaces : ",e) ; }                                                  // NO_COV defensive programming
	//
	return 0 ;
}
