diff --git a/Makefile b/Makefile
index 99c2887..e3a65fd 100644
--- a/Makefile
+++ b/Makefile
@@ -3,14 +3,27 @@
 # This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
 # This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
+# notes :
+# - the protection for jemalloc requires a hack which is only available under Linux
+# - syscall() is deprecated under Darwin and is not implemented in autodep
+# - ptrace is not available under Darwin
+# - static libstdc++ is not available under Darwin
+
 VERSION := 24.12
 
-ifneq ($(shell uname),Linux)
-    $(error can only compile under Linux)
+OS := $(shell uname)
+
+# user configurable
+ifeq ($(OS),Linux)
+    MAKEFLAGS := -j$(shell nproc||echo 1)
+endif
+ifeq ($(OS),Darwin)
+    MAKEFLAGS := -j$(shell sysctl hw.ncpu|cut -w -f2||echo 1)
 endif
+MAKEFLAGS += -k
 
-MAKEFLAGS := -r -R                       # mandatory
-MAKEFLAGS += -k -j$(shell nproc||echo 1) # user configurable
+# mandatory
+MAKEFLAGS += -r -R
 
 .DEFAULT_GOAL := DFLT
 
@@ -34,6 +47,7 @@ sys_config.log : _bin/sys_config sys_config.env
 	@echo sys_config
 	@# reread sys_config.env in case it has been modified while reading an old sys_config.mk
 	@set -a ;            \
+	OS=$(OS) ;           \
 	. ./sys_config.env ; \
 	./$< $(@:%.log=%.mk) $(@:%.log=%.h) $(@:%.log=%.sum) $(@:%.log=%.err) 2>$@ ||:
 sys_config.mk  : sys_config.log ;+@[ -f $@ ] || { echo "cannot find $@" ; exit 1 ; }
@@ -84,7 +98,8 @@ include Manifest.inc_stamp # Manifest is used in this makefile
 EXCLUDES := \
 	$(if $(HAS_SLURM)   ,,src/lmakeserver/backends/slurm.cc) \
 	$(if $(HAS_SGE)     ,,src/lmakeserver/backends/sge.cc  ) \
-	$(if $(HAS_LD_AUDIT),,src/autodep/ld_audit.cc          )
+	$(if $(HAS_LD_AUDIT),,src/autodep/ld_audit.cc          ) \
+	$(if $(IS_DARWIN)   , src/autodep/syscall_tab.cc       )
 SRCS := $(filter-out $(EXCLUDES),$(shell cat Manifest 2>/dev/null))
 
 # this is the recommanded way to insert a , when calling functions
@@ -116,7 +131,7 @@ HIDDEN_FLAGS += $(if $(findstring P, $(LMAKE_FLAGS)),-DPROFILING)
 SAN_FLAGS    := $(if $(findstring SA,$(LMAKE_FLAGS)),-fsanitize=address -fsanitize=undefined)
 SAN_FLAGS    += $(if $(findstring ST,$(LMAKE_FLAGS)),-fsanitize=thread)
 # some user codes may have specific (and older) libs, in that case, unless flag l is used, link libstdc++ statically
-LIB_STDCPP := $(if $(findstring l,$(LMAKE_FLAGS)),,-static-libstdc++)
+LIB_STDCPP := $(if $(or $(IS_DARWIN),$(findstring l,$(LMAKE_FLAGS))),,-static-libstdc++)
 #
 WARNING_FLAGS := -Wall -Wextra -Wno-cast-function-type -Wno-type-limits -Werror
 #
@@ -131,7 +146,7 @@ ifeq ($(CXX_FLAVOR),clang)
 endif
 #
 USER_FLAGS := -std=$(CXX_STD) $(EXTRA_FLAGS) $(COVERAGE) $(PROFILE)
-COMPILE1   := PATH=$(CXX_DIR):$$PATH $(CXX) $(USER_FLAGS) $(HIDDEN_FLAGS) -fno-strict-aliasing -pthread $(WARNING_FLAGS) $(if $(NEED_EXPERIMENTAL_LIBRARY),-fexperimental-library)
+COMPILE1   := PATH=$(CXX_DIR):$$PATH $(CXX) $(USER_FLAGS) $(HIDDEN_FLAGS) -fno-strict-aliasing -pthread $(WARNING_FLAGS) $(if $(NEED_EXPERIMENTAL_LIBRARY),-fexperimental-library) $(DARWIN_FIX_FLAGS)
 LINT       := clang-tidy
 LINT_FLAGS := $(USER_FLAGS) $(HIDDEN_FLAGS) $(WARNING_FLAGS) $(CLANG_WARNING_FLAGS)
 LINT_CHKS  := -checks=-clang-analyzer-optin.core.EnumCastOutOfRange
@@ -151,7 +166,7 @@ PY2_LINK_FLAGS := $(if $(PYTHON2),$(if $(PY2_LIB_DIR),$(PY2_LIB_DIR)/$(PY2_LIB_B
 PY3_LINK_FLAGS :=                 $(if $(PY3_LIB_DIR),$(PY3_LIB_DIR)/$(PY3_LIB_BASE),-l:$(PY3_LIB_BASE)) $(patsubst %,-Wl$(COMMA)-rpath$(COMMA)%,$(PY3_LIB_DIR))
 
 PY_CC_FLAGS   = $(if $(and $(PYTHON2),$(findstring -py2,$@)),$(PY2_CC_FLAGS)  ,$(PY3_CC_FLAGS)  )
-PY_LINK_FLAGS = $(if $(and $(PYTHON2),$(findstring 2.so,$@)),$(PY2_LINK_FLAGS),$(PY3_LINK_FLAGS))
+PY_LINK_FLAGS = $(if $(and $(PYTHON2),$(findstring 2.so,$@)),$(PY2_LINK_FLAGS),$(PY3_LINK_FLAGS)) $(if $(IS_DARWIN),-Wl$(COMMA)-rpath$(COMMA)/Library/Developer/CommandLineTools/Library/Frameworks)
 #
 PY_SO         = $(if $(and $(PYTHON2),$(findstring 2.so,             $@)),-py2)
 MOD_SO        = $(if $(and $(HAS_32) ,$(findstring d$(LD_SO_LIB_32)/,$@)),-m32)
@@ -223,7 +238,7 @@ LMAKE_SERVER_FILES := \
 	$(LMAKE_SERVER_PY_FILES)  \
 	$(LMAKE_SERVER_BIN_FILES)
 
-LMAKE_REMOTE_SLIBS := $(if $(HAS_LD_AUDIT),ld_audit.so) ld_preload.so ld_preload_jemalloc.so
+LMAKE_REMOTE_SLIBS := $(if $(HAS_LD_AUDIT),ld_audit.so) ld_preload.so $(if $(IS_LINUX),ld_preload_jemalloc.so)
 LMAKE_REMOTE_FILES := \
 	$(if $(HAS_32),$(patsubst %,_d$(LD_SO_LIB_32)/%,$(LMAKE_REMOTE_SLIBS))) \
 	$(patsubst %,_d$(LD_SO_LIB)/%,$(LMAKE_REMOTE_SLIBS))                    \
@@ -326,6 +341,8 @@ lib/%.py _lib/%.py : _lib/%.src.py sys_config.mk
 		-e 's!\$$BASH!$(BASH)!'                          \
 		-e 's!\$$GIT!$(GIT)!'                            \
 		-e 's!\$$HAS_LD_AUDIT!$(HAS_LD_AUDIT)!'          \
+		-e 's!\$$HAS_NAMESPACES!$(HAS_NAMESPACES)!'      \
+		-e 's!\$$HAS_PTRACE!$(HAS_PTRACE)!'              \
 		-e 's!\$$HAS_SGE!$(HAS_SGE)!'                    \
 		-e 's!\$$HAS_SLURM!$(HAS_SLURM)!'                \
 		-e 's!\$$LD_LIBRARY_PATH!$(PY_LD_LIBRARY_PATH)!' \
@@ -440,7 +457,7 @@ SERVER_SAN_OBJS := \
 	src/autodep/env$(SAN).o                             \
 	src/autodep/ld_server$(SAN).o                       \
 	src/autodep/record$(SAN).o                          \
-	src/autodep/syscall_tab$(SAN).o                     \
+	$(if $(IS_DARWIN),,src/autodep/syscall_tab$(SAN).o) \
 	src/lmakeserver/backend$(SAN).o                     \
 	src/lmakeserver/cache$(SAN).o                       \
 	src/lmakeserver/caches/dir_cache$(SAN).o            \
@@ -456,7 +473,7 @@ SERVER_SAN_OBJS := \
 _bin/lmakeserver : \
 	$(SERVER_SAN_OBJS)                                         \
 	src/autodep/gather$(SAN).o                                 \
-	src/autodep/ptrace$(SAN).o                                 \
+	$(if $(HAS_PTRACE),src/autodep/ptrace$(SAN).o            ) \
 	src/lmakeserver/backends/local$(SAN).o                     \
 	$(if $(HAS_SLURM) ,src/lmakeserver/backends/slurm$(SAN).o) \
 	$(if $(HAS_SGE)   ,src/lmakeserver/backends/sge$(SAN).o  ) \
@@ -467,7 +484,7 @@ _bin/lmakeserver : \
 bin/lrepair : \
 	$(SERVER_SAN_OBJS)                                         \
 	src/autodep/gather$(SAN).o                                 \
-	src/autodep/ptrace$(SAN).o                                 \
+	$(if $(HAS_PTRACE),src/autodep/ptrace$(SAN).o            ) \
 	src/lmakeserver/backends/local$(SAN).o                     \
 	$(if $(HAS_SLURM) ,src/lmakeserver/backends/slurm$(SAN).o) \
 	$(if $(HAS_SGE)   ,src/lmakeserver/backends/sge$(SAN).o  ) \
@@ -551,18 +568,18 @@ BASIC_REMOTE_OBJS := \
 	src/autodep/env.o      \
 	src/autodep/record.o
 
-AUTODEP_OBJS := $(BASIC_REMOTE_OBJS) src/autodep/syscall_tab.o
+AUTODEP_OBJS := $(BASIC_REMOTE_OBJS) $(if $(IS_DARWIN),,src/autodep/syscall_tab.o)
 REMOTE_OBJS  := $(BASIC_REMOTE_OBJS) src/autodep/job_support.o
 
 JOB_EXEC_OBJS := \
-	$(AUTODEP_OBJS)      \
-	src/app.o            \
-	src/py.o             \
-	src/re.o             \
-	src/rpc_job.o        \
-	src/trace.o          \
-	src/autodep/gather.o \
-	src/autodep/ptrace.o \
+	$(AUTODEP_OBJS)                          \
+	src/app.o                                \
+	src/py.o                                 \
+	src/re.o                                 \
+	src/rpc_job.o                            \
+	src/trace.o                              \
+	src/autodep/gather.o                     \
+	$(if $(HAS_PTRACE),src/autodep/ptrace.o) \
 	src/autodep/record.o
 
 _bin/job_exec : $(JOB_EXEC_OBJS) src/job_exec.o
@@ -590,8 +607,8 @@ bin/% :
 
 # remote libs generate errors when -fsanitize=thread # XXXM fix these errors and use $(SAN)
 
-LMAKE_DBG_FILES    += $(if $(HAS_LD_AUDIT),_d$(LD_SO_LIB)/ld_audit.so   ) _d$(LD_SO_LIB)/ld_preload.so    _d$(LD_SO_LIB)/ld_preload_jemalloc.so
-LMAKE_DBG_FILES_32 += $(if $(HAS_LD_AUDIT),_d$(LD_SO_LIB_32)/ld_audit.so) _d$(LD_SO_LIB_32)/ld_preload.so _d$(LD_SO_LIB_32)/ld_preload_jemalloc.so
+LMAKE_DBG_FILES    += $(if $(HAS_LD_AUDIT),_d$(LD_SO_LIB)/ld_audit.so   ) _d$(LD_SO_LIB)/ld_preload.so    $(if $(IS_LINUX),_d$(LD_SO_LIB)/ld_preload_jemalloc.so   )
+LMAKE_DBG_FILES_32 += $(if $(HAS_LD_AUDIT),_d$(LD_SO_LIB_32)/ld_audit.so) _d$(LD_SO_LIB_32)/ld_preload.so $(if $(IS_LINUX),_d$(LD_SO_LIB_32)/ld_preload_jemalloc.so)
 _d$(LD_SO_LIB)/ld_audit.so               : $(AUTODEP_OBJS)             src/autodep/ld_audit.o
 _d$(LD_SO_LIB)/ld_preload.so             : $(AUTODEP_OBJS)             src/autodep/ld_preload.o
 _d$(LD_SO_LIB)/ld_preload_jemalloc.so    : $(AUTODEP_OBJS)             src/autodep/ld_preload_jemalloc.o
diff --git a/TO_DO b/TO_DO
index a7b8e8f..4168aaf 100644
--- a/TO_DO
+++ b/TO_DO
@@ -14,6 +14,10 @@ items :
 ****************************************************************************************************
 
 ! fix compilation with LMAKE_FLAGS=ST
+M missing some deps when reading elf
+	- find a way to reproduce it
+	- it seems that libc.so is missing at least in some occasions
+	- probably fixed by correct default library path code
 
 ****************************************************************************************************
 * LACK (not implemented but necessary for lmake semantic)
@@ -132,12 +136,6 @@ items :
 	? seems to be highly architecture dependent, is it worth ?
 M implement fuse as an autodep method
 	- does not seem doable because read foo/bar first does a lookup(foo)
-M port to Darwin
-	- autodep requires the use of dtrace as there is no way to piggyback calls to libc
-	- dtrace requires admin privileges which obliges job_exec and the like to be suid root
-	- dtrace is *very* different from ptrace, an entirely new code
-	- Darwin support makes code less readable because of numerous #if's
-	- no traction
 
 ****************************************************************************************************
 * OPTIMIZATIONS
diff --git a/_bin/find_cc_ld_library_path b/_bin/find_cc_ld_library_path
index 7421c19..ccf2874 100755
--- a/_bin/find_cc_ld_library_path
+++ b/_bin/find_cc_ld_library_path
@@ -4,6 +4,17 @@
 # This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
 # This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
+if [ "$OS" = Darwin ] ; then
+	realpath() {
+		for f in "$@" ; do
+			case $f in
+				/*) echo "$f"      ;;
+				* ) echo "$PWD/$f" ;;
+			esac
+		done
+	}
+fi
+
 case x"$1" in
 	x      ) echo usage : $0 [-m32] path/to/c-compiler >&2 ; exit 2 ;;
 	x-h    ) echo usage : $0 [-m32] path/to/c-compiler >&2 ; exit 2 ;;
diff --git a/_bin/sys_config b/_bin/sys_config
index 6bc2903..f9a6be1 100755
--- a/_bin/sys_config
+++ b/_bin/sys_config
@@ -5,6 +5,17 @@
 # This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
 # This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
+if [ "$OS" = Darwin ] ; then
+	realpath() {
+		for f in "$@" ; do
+			case $f in
+				/*) echo "$f"      ;;
+				* ) echo "$PWD/$f" ;;
+			esac
+		done
+	}
+fi
+
 MK_FILE=$( realpath ${1:-/dev/null})
 H_FILE=$(  realpath ${2:-/dev/null})
 SUM_FILE=$(realpath ${3:-/dev/null})
@@ -12,7 +23,9 @@ ERR_FILE=$(realpath ${4:-/dev/null})
 
 trial_dir=${MK_FILE%.*}.trial
 
-source /etc/os-release # define ID and VERSION_ID
+if [ "$OS" = Linux ] ; then
+	source /etc/os-release  # define ID and VERSION_ID
+fi
 
 echo SYS_CONFIG_OK := 0 >$MK_FILE  # this will be overwritten at the end, when auto-config has gone through
                         >$H_FILE   # useless, for sanity only
@@ -78,64 +91,90 @@ echo "using $CXX as $CXX_STD compiler (version $CXX_VERSION)" >>$SUM_FILE
 # Python configuration (Python2 is optional)
 #
 
-config_python() {
-	python=$1
-	ver=$2
-	python=${python:-python$ver}
-	p=$(type -p $python || :)
-	[ "$p" ] || { msg="$python not found" ; return 1 ; }
-	python=$p
-	llp=$LD_LIBRARY_PATH                                                                                                                   # save LD_LIBARY_PATH
-	export LD_LIBRARY_PATH="$(dirname $(dirname $python))/lib:$LD_LIBRARY_PATH"
-	py_major=$($python -c 'import sys       ; print(sys.version_info.major                )')
-	py_minor=$($python -c 'import sys       ; print(sys.version_info.minor                )')
-	inc_dir=$( $python -c 'import sysconfig ; print(sysconfig.get_config_var("INCLUDEDIR"))')
-	inc_py=$(  $python -c 'import sysconfig ; print(sysconfig.get_config_var("INCLUDEPY" ))')
-	lib_base=$($python -c 'import sysconfig ; print(sysconfig.get_config_var("LDLIBRARY" ))')
-	lib_dir=$( $python -c 'import sysconfig ; print(sysconfig.get_config_var("LIBDIR"    ))')
-	case $ver in
-		2)	[ $py_major -eq 2 ] || { msg="$python version must be 2.x"          ; return 1 ; }
-			[ $py_minor -ge 7 ] || { msg="$python version must be at least 2.7" ; return 1 ; }
-		;;
-		3)	[ $py_major -eq 3 ] || { msg="$python version must be 3.x"          ; return 1 ; }
-			[ $py_minor -ge 6 ] || { msg="$python version must be at least 3.6" ; return 1 ; }
-		;;
-	esac
-	case $lib_base in
-		*.so | *.a ) ;;
-		*          ) msg="$python library $lib_base is not a python library" ; return 1 ;;
-	esac
-	case $lib_dir/ in
-		/usr/lib/*  ) lib_dir= ;;
-		/usr/lib64/*) lib_dir= ;;
-	esac
-	[ ! "$lib_dir" ] || lib_opt=-L$lib_dir
-	cat <<-"EOF" >probe_python$ver.c
-		#include <Python.h>
-		int main() {
-			PyObject* none = Py_None ;
+case $OS in
+	#
+	Linux)
+		config_python() {
+			python=$1
+			ver=$2
+			python=${python:-python$ver}
+			p=$(type -p $python || :)
+			[ "$p" ] || { msg="$python not found" ; return 1 ; }
+			python=$p
+			llp=$LD_LIBRARY_PATH                                                                    # save LD_LIBARY_PATH
+			export LD_LIBRARY_PATH="$(dirname $(dirname $python))/lib:$LD_LIBRARY_PATH"
+			py_major=$($python -c 'import sys       ; print(sys.version_info.major                )')
+			py_minor=$($python -c 'import sys       ; print(sys.version_info.minor                )')
+			inc_dir=$( $python -c 'import sysconfig ; print(sysconfig.get_config_var("INCLUDEDIR"))')
+			inc_py=$(  $python -c 'import sysconfig ; print(sysconfig.get_config_var("INCLUDEPY" ))')
+			lib_base=$($python -c 'import sysconfig ; print(sysconfig.get_config_var("LDLIBRARY" ))')
+			lib_dir=$( $python -c 'import sysconfig ; print(sysconfig.get_config_var("LIBDIR"    ))')
+			case $ver in
+				2)	[ $py_major -eq 2 ] || { msg="$python version must be 2.x"          ; return 1 ; }
+					[ $py_minor -ge 7 ] || { msg="$python version must be at least 2.7" ; return 1 ; }
+				;;
+				3)	[ $py_major -eq 3 ] || { msg="$python version must be 3.x"          ; return 1 ; }
+					[ $py_minor -ge 6 ] || { msg="$python version must be at least 3.6" ; return 1 ; }
+				;;
+			esac
+			case $lib_base in
+				*.so | *.a ) ;;
+				*          ) msg="$python library $lib_base is not a python library" ; return 1 ;;
+			esac
+			case $lib_dir/ in
+				/usr/lib/*  ) lib_dir= ;;
+				/usr/lib64/*) lib_dir= ;;
+			esac
+			[ ! "$lib_dir" ] || lib_opt=-L$lib_dir
+			cat <<-"EOF" >probe_python$ver.c
+				#include <Python.h>
+				int main() {
+					PyObject* none = Py_None ;
+				}
+			EOF
+			cc -o /dev/null -I$inc_py $lib_opt -xc probe_python$ver.c -l:$lib_base || { msg="$python is unusable as python library" ; return 1 ; } # check if Py_None is available in lib
+			eval "PYTHON${ver#3}=$python"
+			eval "PY${ver}_INCLUDEDIR=$inc_dir"
+			eval "PY${ver}_INCLUDEPY=$inc_py"
+			eval "PY${ver}_LIB_BASE=$lib_base"
+			eval "PY${ver}_LIB_DIR=$lib_dir"
+			case "$lib_base" in
+				*.so) eval "HAS_PY${ver}_DYN=1" ; echo "using $python as python$ver (version $py_major.$py_minor)"                                           >>$SUM_FILE ;;
+				*.a ) eval "HAS_PY${ver}_DYN=0" ; echo "using $python as python$ver (version $py_major.$py_minor) with static library (minimal job support)" >>$SUM_FILE ;;
+			esac
+			LD_LIBRARY_PATH=$llp                                                                    # restore LD_LIBARY_PATH
 		}
-	EOF
-	cc -o /dev/null -I$inc_py $lib_opt -xc probe_python$ver.c -l:$lib_base || { msg="$python is unusable as python library" ; return 1 ; } # check if Py_None is available in lib
-	eval "PYTHON${ver#3}=$python"
-	eval "PY${ver}_INCLUDEDIR=$inc_dir"
-	eval "PY${ver}_INCLUDEPY=$inc_py"
-	eval "PY${ver}_LIB_BASE=$lib_base"
-	eval "PY${ver}_LIB_DIR=$lib_dir"
-	case "$lib_base" in
-		*.so) eval "HAS_PY${ver}_DYN=1" ; echo "using $python as python$ver (version $py_major.$py_minor)"                                           >>$SUM_FILE ;;
-		*.a ) eval "HAS_PY${ver}_DYN=0" ; echo "using $python as python$ver (version $py_major.$py_minor) with static library (minimal job support)" >>$SUM_FILE ;;
-	esac
-	LD_LIBRARY_PATH=$llp                                                                                                                   # restore LD_LIBARY_PATH
-}
-#
-config_python "$PYTHON2" 2 || { echo "no python2 support ($msg)" >>$SUM_FILE ; PYTHON2= ; }                                                # python2 is optional
-config_python "$PYTHON"  3 || { echo                      $msg   >>$ERR_FILE ; exit 1   ; }                                                # python3 is compulsery
-#
-if   [ "$PY2_LIB_DIR" -a "$PY3_LIB_DIR" ] ; then PY_LD_LIBRARY_PATH=$PY3_LIB_DIR:$PY2_LIB_DIR
-elif [ "$PY2_LIB_DIR"                   ] ; then PY_LD_LIBRARY_PATH=$PY2_LIB_DIR
-elif [ "$PY3_LIB_DIR"                   ] ; then PY_LD_LIBRARY_PATH=$PY3_LIB_DIR
-fi
+		#
+		config_python "$PYTHON2" 2 || { echo "no python2 support ($msg)" >>$SUM_FILE ; PYTHON2= ; } # python2 is optional
+		config_python "$PYTHON"  3 || { echo                      $msg   >>$ERR_FILE ; exit 1   ; } # python3 is compulsery
+		#
+		if   [ "$PY2_LIB_DIR" -a "$PY3_LIB_DIR" ] ; then PY_LD_LIBRARY_PATH=$PY3_LIB_DIR:$PY2_LIB_DIR
+		elif [ "$PY2_LIB_DIR"                   ] ; then PY_LD_LIBRARY_PATH=$PY2_LIB_DIR
+		elif [ "$PY3_LIB_DIR"                   ] ; then PY_LD_LIBRARY_PATH=$PY3_LIB_DIR
+		fi
+	;;
+	#
+	Darwin)
+		python=${PYTHON:-python3}
+		p=$(type -p $python)
+		[ "$p" ] || { echo "$python not found">>$ERR_FILE ; exit 1 ; }
+		python=$p
+		py_major=$($python -c 'import sys ; print(sys.version_info.major)')
+		py_minor=$($python -c 'import sys ; print(sys.version_info.minor)')
+		[ $py_major -eq 3 ] || { echo "$python version must be 3.x"          >>$ERR_FILE ; exit 1 ; }
+		[ $py_minor -ge 6 ] || { echo "$python version must be at least 3.6" >>$ERR_FILE ; exit 1 ; }
+		base=$($python -c 'import sysconfig ; print(sysconfig.get_config_var("base"))')
+		#
+		PYTHON=$python
+		PY3_INCLUDEDIR=
+		PY3_INCLUDEPY=$base/Headers
+		PY3_LIB_BASE=libpython3.$py_minor.dylib
+		PY3_LIB_DIR=$base/lib/python3.$py_minor/config-3.$py_minor-darwin
+		HAS_PY3_DYN=1
+		PY_LD_LIBRARY_PATH=$PY3_LIB_DIR
+	;;
+	#
+esac
 
 #
 # ADDR2LINE (ADDR2LINE+HAS_ADDR2LINE)
@@ -155,12 +194,45 @@ HAS_ADDR2LINE=$(ok test "$ADDR2LINE")
 HAS_CLOSE_RANGE=$(ok cc -E --include 'linux/close_range.h' -o /dev/null -xc /dev/null )
 
 #
+# EPOLL & KQUEUE (HAS_EPOLL+HAS_KQUEUE)
 #
-# INC_DIRS (STD_INC_DIRS)
+HAS_EPOLL=$(ok cc -E --include 'sys/epoll.h' -o /dev/null -xc /dev/null )
+cat <<"EOF" >kqueue.c
+	#include <sys/event.h>
+	int main() { kqueue() ; }
+EOF
+HAS_KQUEUE=$(ok cc -o /dev/null -xc kqueue.c) # check if kqueue is available in lib
+
+#
+# FILE_HANDLE (HAS_FILE_HANDLE)
+#
+cat <<"EOF" >file_handle.c
+	#ifndef _GNU_SOURCE
+		#define _GNU_SOURCE
+	#endif
+	#include <fcntl.h>
+	int main() { name_to_handle_at(0,NULL,NULL,NULL,0) ; }
+EOF
+HAS_FILE_HANDLE=$(ok cc -o /dev/null -xc file_handle.c) # check if name_to_handle_at is available in lib
+
+#
+#
+# INC_DIRS (STD_INC_DIRS+DARWIN_FIX_FLAGS)
 #
 cc -v -E -o /dev/null -xc++ -std=$CXX_STD - </dev/null 2>compiler_info
 # get only first word of each inclue dir as there may be info following it
 STD_INC_DIRS="$(echo $(realpath $(sed -e '1,/<.*>.*search starts/d' -e '/End of search/,$d' -e 's/ *\([^ ]*\).*/\1/' compiler_info)) )" # echo is used to replace \n by space
+if [ "$OS" = Darwin ] ; then
+	DARWIN_FIX_FLAGS=
+	for d in $STD_INC_DIRS ; do
+		DARWIN_FIX_FLAGS="$DARWIN_FIX_FLAGS -isystem $d/c++/v1"
+	done
+fi
+
+#
+# ELF (HAS_ELF)
+#
+HAS_ELF=$(ok cc -E --include 'link.h' -o /dev/null -xc /dev/null )
 
 # EXPERIMENTAL_LIBRARY (NEED_EXPERIMENTAL_LIBRARY) - must be after INC_DIRS
 #
@@ -168,20 +240,30 @@ cat <<"EOF" >experimental_library.cc
 	#include <stop_token>
 	std::stop_token st ;
 EOF
-if   cc -c -o /dev/null -std=$CXX_STD                        experimental_library.cc ; then NEED_EXPERIMENTAL_LIBRARY=0
-elif cc -c -o /dev/null -std=$CXX_STD -fexperimental-library experimental_library.cc ; then NEED_EXPERIMENTAL_LIBRARY=1
+if   cc -c -o /dev/null -std=$CXX_STD                        $DARWIN_FIX_FLAGS experimental_library.cc ; then NEED_EXPERIMENTAL_LIBRARY=0
+elif cc -c -o /dev/null -std=$CXX_STD -fexperimental-library $DARWIN_FIX_FLAGS experimental_library.cc ; then NEED_EXPERIMENTAL_LIBRARY=1
 else
 	echo "$CXX does not implement $CXX_STD" >>$ERR_FILE
 	exit 1
 fi
 
+#
+# EVENTFD (HAS_EVENTFD)
+#
+HAS_EVENTFD=$(ok cc -E --include 'sys/eventfd.h' -o /dev/null -xc /dev/null )
+
+#
+# INOTIFY (HAS_INOTIFY)
+#
+HAS_INOTIFY=$(ok cc -E --include 'sys/inotify.h' -o /dev/null -xc /dev/null )
+
 #
 # LD_AUDIT (HAS_LD_AUDIT)
 #
-case $ID/$VERSION_ID in
-	ubuntu/20.04) HAS_LD_AUDIT=0 ;;                      # Ubuntu  fix : Ubuntu 20.04 seems to miss calling auditing code upon ldopen
-	centos/7    ) HAS_LD_AUDIT=0 ;;                      # CentOS7 fix : This is what would answer a real centos-7 system, but we may be running in a docker which has a more recent kernel.
-	*           )
+case $OS/$ID/$VERSION_ID in
+	Linux/ubuntu/20.04) HAS_LD_AUDIT=0 ;; # Ubuntu  fix : Ubuntu 20.04 seems to miss calling auditing code upon ldopen
+	Linux/centos/7    ) HAS_LD_AUDIT=0 ;; # CentOS7 fix : This is what would answer a real centos-7 system, but we may be running in a docker which has a more recent kernel.
+	*                 )
 		cat <<-"EOF" >audited.c
 			#include <stdio.h>
 			int main() { printf("0") ; }
@@ -262,6 +344,29 @@ cat <<"EOF" >memfd.c
 EOF
 HAS_MEMFD=$(ok cc -o /dev/null -xc memfd.c) # check if memfd_create is available in lib
 
+#
+# MMAP (HAS_MREMAP)
+cat <<"EOF" >mremap.c
+	#ifndef _GNU_SOURCE
+		#define _GNU_SOURCE
+	#endif
+	#include <sys/mman.h>
+	int main() { mremap((void*)0,0,0,0) ; }
+EOF
+HAS_MREMAP=$(ok cc -o /dev/null -xc mremap.c) # check if mremap is available in lib
+
+#
+# NAMESPACES (HAS_NAMESPACES)
+#
+cat <<"EOF" >namespaces.c
+	#ifndef _GNU_SOURCE
+		#define _GNU_SOURCE
+	#endif
+	#include <sched.h>
+	int main() { unshare(0) ; }
+EOF
+HAS_NAMESPACES=$(ok cc -o /dev/null -xc namespaces.c) # check if unshare is available in lib
+
 #
 # OBJCOPY
 #
@@ -272,9 +377,24 @@ esac
 [ -x "$OBJCOPY" ] || OBJCOPY=$(type -p objcopy ||:)
 
 #
-# OS (OS_ID)
+# OFF64 (HAS_OFF64)
 #
-OS_ID="$ID-$VERSION_ID"
+cat <<"EOF" >off64.c
+	#ifndef _GNU_SOURCE
+		#define _GNU_SOURCE
+	#endif
+	#include <sys/types.h>
+	off64_t x ;
+EOF
+HAS_OFF64=$(ok cc -c -o /dev/null -xc off64.c)
+
+#
+# OS (IS_LINUX,IS_DARWIN,OS_ID,OS_VERSION_ID)
+#
+IS_LINUX=$(ok  [ "$OS" = Linux  ])
+IS_DARWIN=$(ok [ "$OS" = Darwin ])
+OS_ID="$ID"
+OS_VERSION_ID="$VERSION_ID"
 
 #
 # PATH (STD_PATH)
@@ -296,29 +416,37 @@ HAS_PCRE=$(ok cc -std=$CXX_STD -o /dev/null pcre.cc -lpcre2-8 ) # check if pcre2
 [ $HAS_PCRE = 1 ] || echo "no pcre2 support, fall back to (slower) c++ STL regular expression library" >>$SUM_FILE
 
 #
-# PTRACE (MUST_UNDEF_PTRACE_MACROS+HAS_PTRACE_GET_SYSCALL_INFO)
+# PTRACE (HAS_PTRACE+MUST_UNDEF_PTRACE_MACROS+HAS_PTRACE_GET_SYSCALL_INFO)
 #
-cat <<-"EOF" >undef_ptrace_macros.c
-	#include <sys/ptrace.h>
-	#include <linux/ptrace.h>
-	#undef PTRACE_TRACEME
-	int main() {
-		long rx = ptrace(PTRACE_TRACEME,0,0,0) ;
-	}
-EOF
-MUST_UNDEF_PTRACE_MACROS=$(ok cc -c -idirafter /usr/include/linux -o /dev/null -xc undef_ptrace_macros.c )
-#
-cat <<-"EOF" >get_syscall_info.c
-	#include <sys/ptrace.h>
-	#include <linux/ptrace.h>
-	#if MUST_UNDEF_PTRACE_MACROS
-		#undef PTRACE_GET_SYSCALL_INFO
-	#endif
-	int main() {
-		long rx = ptrace(PTRACE_GET_SYSCALL_INFO,0,0,0) ;
-	}
-EOF
-	HAS_PTRACE_GET_SYSCALL_INFO=$(ok cc -c -idirafter /usr/include/linux -DMUST_UNDEF_PTRACE_MACROS=$MUST_UNDEF_PTRACE_MACROS -o /dev/null -xc get_syscall_info.c )
+case $OS in
+	Darwin)
+		HAS_PTRACE=0
+	;;
+	Linux )
+		HAS_PTRACE=1
+		cat <<-"EOF" >undef_ptrace_macros.c
+			#include <sys/ptrace.h>
+			#include <linux/ptrace.h>
+			#undef PTRACE_TRACEME
+			int main() {
+				long rx = ptrace(PTRACE_TRACEME,0,0,0) ;
+			}
+		EOF
+		MUST_UNDEF_PTRACE_MACROS=$(ok cc -c -idirafter /usr/include/linux -o /dev/null -xc undef_ptrace_macros.c )
+		#
+		cat <<-"EOF" >get_syscall_info.c
+			#include <sys/ptrace.h>
+			#include <linux/ptrace.h>
+			#if MUST_UNDEF_PTRACE_MACROS
+				#undef PTRACE_GET_SYSCALL_INFO
+			#endif
+			int main() {
+				long rx = ptrace(PTRACE_GET_SYSCALL_INFO,0,0,0) ;
+			}
+		EOF
+		HAS_PTRACE_GET_SYSCALL_INFO=$(ok cc -c -idirafter /usr/include/linux -DMUST_UNDEF_PTRACE_MACROS=$MUST_UNDEF_PTRACE_MACROS -o /dev/null -xc get_syscall_info.c )
+	;;
+esac
 
 #
 # SECCOMP (HAS_SECCOMP)
@@ -337,6 +465,11 @@ HAS_SECCOMP=$(ok cc -idirafter /usr/include/linux -o /dev/null -xc seccomp.c -l:
 #
 [ $HAS_SECCOMP = 1 ] || echo "no seccomp support, fall back to (slower when autodep=ptrace) ptrace to trace jobs" >>$SUM_FILE
 
+#
+# SENDFILE (HAS_SENDFILE)
+#
+HAS_SENDFILE=$(ok cc -E --include 'sys/sendfile.h' -o /dev/null -xc /dev/null )
+
 #
 # SGE (HAS_SGE)
 #
@@ -389,11 +522,43 @@ if [ "$OBJCOPY" ] ; then
 	SPLIT_DBG_32=$((!$HAS_STACKTRACE_32))
 fi
 
+#
+# STAT (ST_MTIMESPEC)
+#
+cat <<"EOF" >st_mtimespec.c
+	#include <sys/stat.h>
+	int main() {
+		struct stat     buf ;
+		struct timespec ts  = buf.st_mtimespec ;
+	}
+EOF
+if cc -c -o /dev/null -xc st_mtimespec.c ; then ST_MTIMESPEC=st_mtimespec ; fi
+cat <<"EOF" >st_mtim.c
+	#include <sys/stat.h>
+	int main() {
+		struct stat     buf ;
+		struct timespec ts  = buf.st_mtim ;
+	}
+EOF
+if cc -c -o /dev/null -xc st_mtim.c ; then ST_MTIMESPEC=st_mtim ; fi
+
 #
 # TEXI (HAS_TEXI)
 #
 HAS_TEXI=$(ok type -p texi2any)
 
+#
+# UINT (HAS_UINT)
+# true if ushort, uint and ulong are standard types
+#
+cat <<"EOF" >uint.cc
+	#include <sys/types.h>
+	ushort us ;
+	uint   ui ;
+	ulong  ul ;
+EOF
+HAS_UINT=$(ok cc -c -std=$CXX_STD -o /dev/null uint.cc)
+
 #
 # UNREACHABLE (HAS_UNREACHABLE)
 #
@@ -411,7 +576,10 @@ HAS_UNREACHABLE=$(ok cc -std=$CXX_STD -o /dev/null unreachable.cc) # check if st
 # Linux specifies vfork more precisely than Posix
 # with Linux, we must not map vfork to fork as vfork is *not* a subset of fork, in exchange we can instrument exec in child
 # with posix, we must map vfork to fork as vfork is a subset of fork and instrumenting exec in child is forbidden with vfork
-LINUX_VFORK=0
+case $OS in
+	Linux ) LINUX_VFORK=1 ;;
+	Darwin) LINUX_VFORK=0 ;;
+esac
 
 cat >$MK_FILE <<-EOF
 	SYS_CONFIG_OK := 1
@@ -422,16 +590,22 @@ cat >$MK_FILE <<-EOF
 	CXX_DIR                   := $CXX_DIR
 	CXX_FLAVOR                := $CXX_FLAVOR
 	CXX_STD                   := $CXX_STD
+	DARWIN_FIX_FLAGS          := $DARWIN_FIX_FLAGS
 	GIT                       := $(type -p git)
 	HAS_32                    := ${HAS_32#0}
+	HAS_ELF                   := ${HAS_ELF#0}
 	HAS_LD_AUDIT              := ${HAS_LD_AUDIT#0}
+	HAS_NAMESPACES            := ${HAS_NAMESPACES#0}
 	HAS_PCRE                  := ${HAS_PCRE#0}
+	HAS_PTRACE                := ${HAS_PTRACE#0}
 	HAS_PY2_DYN               := ${HAS_PY2_DYN#0}
 	HAS_PY3_DYN               := ${HAS_PY3_DYN#0}
 	HAS_SECCOMP               := ${HAS_SECCOMP#0}
 	HAS_SGE                   := ${HAS_SGE#0}
 	HAS_SLURM                 := ${HAS_SLURM#0}
 	HAS_TEXI                  := ${HAS_TEXI#0}
+	IS_DARWIN                 := ${IS_DARWIN#0}
+	IS_LINUX                  := ${IS_LINUX#0}
 	LD_SO_LIB                 := $LD_SO_LIB
 	LD_SO_LIB_32              := $LD_SO_LIB_32
 	LIB_STACKTRACE            := $LIB_STACKTRACE
@@ -475,26 +649,42 @@ cat >$H_FILE <<-EOF
 	#define HAS_32                      $HAS_32
 	#define HAS_ADDR2LINE               $HAS_ADDR2LINE
 	#define HAS_CLOSE_RANGE             $HAS_CLOSE_RANGE
+	#define HAS_ELF                     $HAS_ELF
+	#define HAS_EPOLL                   $HAS_EPOLL
+	#define HAS_EVENTFD                 $HAS_EVENTFD
+	#define HAS_FILE_HANDLE             $HAS_FILE_HANDLE
+	#define HAS_INOTIFY                 $HAS_INOTIFY
+	#define HAS_KQUEUE                  $HAS_KQUEUE
 	#define HAS_LD_AUDIT                $HAS_LD_AUDIT
 	#define HAS_MEMFD                   $HAS_MEMFD
+	#define HAS_MREMAP                  $HAS_MREMAP
+	#define HAS_NAMESPACES              $HAS_NAMESPACES
+	#define HAS_OFF64                   $HAS_OFF64
 	#define HAS_PCRE                    $HAS_PCRE
+	#define HAS_PTRACE                  $HAS_PTRACE
 	#define HAS_PTRACE_GET_SYSCALL_INFO $HAS_PTRACE_GET_SYSCALL_INFO
 	#define HAS_SECCOMP                 $HAS_SECCOMP
+	#define HAS_SENDFILE                $HAS_SENDFILE
 	#define HAS_SGE                     $HAS_SGE
 	#define HAS_SLURM                   $HAS_SLURM
 	#define HAS_STACKTRACE              $HAS_STACKTRACE_CUR
+	#define HAS_UINT                    $HAS_UINT
 	#define HAS_UNREACHABLE             $HAS_UNREACHABLE
+	#define IS_DARWIN                   $IS_DARWIN
+	#define IS_LINUX                    $IS_LINUX
 	#define LD_SO_LIB                   "$LD_SO_LIB"
 	#define LD_SO_LIB_32                "$LD_SO_LIB_32"
 	#define LINUX_VFORK                 $LINUX_VFORK
 	#define MAX_PID                     $MAX_PID
 	#define MUST_UNDEF_PTRACE_MACROS    $MUST_UNDEF_PTRACE_MACROS
 	#define OS_ID                       "$OS_ID"
+	#define OS_VERSION_ID               "$OS_VERSION_ID"
 	#define PY_LD_LIBRARY_PATH          "$PY_LD_LIBRARY_PATH"
 	#define PYTHON                      "$PYTHON"
 	#define SLURM_SO                    "$SLURM_SO"
 	#define STD_LIBRARY_PATH            "$STD_LIBRARY_PATH"
 	#define STD_LIBRARY_PATH_32         "$STD_LIBRARY_PATH_32"
 	#define STD_PATH                    "$STD_PATH"
+	#define ST_MTIMESPEC                $ST_MTIMESPEC
 	#define USE_LIBC_START_MAIN         $USE_LIBC_START_MAIN
 EOF
diff --git a/_lib/fmt_rule.src.py b/_lib/fmt_rule.src.py
index 3b60245..4f98db2 100755
--- a/_lib/fmt_rule.src.py
+++ b/_lib/fmt_rule.src.py
@@ -3,6 +3,8 @@
 # This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
 # This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
+HasNamespaces = bool("$HAS_NAMESPACES")
+
 import sys
 
 import os
@@ -17,45 +19,50 @@ pdict = lmake.pdict
 no_imports = set() # may be overridden by external code
 
 # helper constants
-StdAttrs = { #!               type   dynamic
-	'allow_stderr'        : ( bool  , True  )
+StdAttrs = {
+	#                         type   dynamic
+	'job_name'            : ( str   , False )
+,	'name'                : ( str   , False )
+,	'prio'                : ( float , False )
+,	'stems'               : ( dict  , False )
+,	'targets'             : ( dict  , False )
+,	'allow_stderr'        : ( bool  , True  )
 ,	'autodep'             : ( str   , True  )
 ,	'auto_mkdir'          : ( bool  , True  )
 ,	'backend'             : ( str   , True  )
 ,	'cache'               : ( str   , True  )
-,	'chroot_dir'          : ( str   , True  )
-,	'cmd'                 : ( str   , True  ) # when it is a str, such str may be dynamic, i.e. it may be a full f-string
+,	'cmd'                 : ( str   , True  )                  # when it is a str, such str may be dynamic, i.e. it may be a full f-string
+,	'side_deps'           : ( dict  , True  )
 ,	'deps'                : ( dict  , True  )
-,	'environ_ancillary'   : ( dict  , True  )
 ,	'environ'             : ( dict  , True  )
 ,	'environ_resources'   : ( dict  , True  )
+,	'environ_ancillary'   : ( dict  , True  )
 ,	'ete'                 : ( float , False )
 ,	'force'               : ( bool  , False )
 ,	'ignore_stat'         : ( bool  , True  )
-,	'job_name'            : ( str   , False )
 ,	'job_tokens'          : ( int   , True  )
 ,	'keep_tmp'            : ( bool  , True  )
 ,	'kill_sigs'           : ( tuple , True  )
 ,	'max_retries_on_lost' : ( int   , False )
 ,	'max_stderr_len'      : ( int   , True  )
 ,	'max_submits'         : ( int   , False )
-,	'name'                : ( str   , False )
 ,	'order'               : ( list  , False )
-,	'prio'                : ( float , False )
 ,	'python'              : ( tuple , False )
-,	'repo_view'           : ( str   , True  )
 ,	'resources'           : ( dict  , True  )
 ,	'shell'               : ( tuple , False )
-,	'side_deps'           : ( dict  , True  )
-,	'side_targets'        : ( dict  , True  )
 ,	'start_delay'         : ( float , True  )
-,	'stems'               : ( dict  , False )
-,	'targets'             : ( dict  , False )
+,	'side_targets'        : ( dict  , True  )
 ,	'timeout'             : ( float , True  )
-,	'tmp_view'            : ( str   , True  )
 ,	'use_script'          : ( bool  , True  )
-,	'views'               : ( dict  , True  )
 }
+if HasNamespaces :
+	StdAttrs.update({
+		#                type  dynamic
+		'chroot_dir' : ( str  , True )
+	,	'repo_view'  : ( str  , True )
+	,	'tmp_view'   : ( str  , True )
+	,	'views'      : ( dict , True )
+	})
 
 Keywords     = {'dep','deps','resources','stems','target','targets'}
 DictAttrs    = { k for k,v in StdAttrs.items() if v[0]==dict }
@@ -473,13 +480,14 @@ class Handle :
 		self._init()
 		self._handle_val('allow_stderr'                   )
 		self._handle_val('auto_mkdir'                     )
-		self._handle_val('chroot_dir'                     )
 		self._handle_val('env'        ,rep_key='environ'  )
 		self._handle_val('ignore_stat'                    )
 		self._handle_val('interpreter',rep_key=interpreter)
-		self._handle_val('repo_view'                      )
-		self._handle_val('tmp_view'                       )
-		self._handle_val('views'                          )
+		if HasNamespaces :
+			self._handle_val('chroot_dir')
+			self._handle_val('repo_view' )
+			self._handle_val('tmp_view'  )
+			self._handle_val('views'     )
 		self.rule_rep.start_cmd_attrs = self._finalize()
 
 	def handle_start_rsrcs(self) :
diff --git a/_lib/lmake/__init__.src.py b/_lib/lmake/__init__.src.py
index dc74807..62a387d 100644
--- a/_lib/lmake/__init__.src.py
+++ b/_lib/lmake/__init__.src.py
@@ -40,7 +40,8 @@ if top_repo_root==None : top_repo_root = _os.getcwd() ; # .
 root_dir     = repo_root     # XXXM : until backward compatibility can be broken
 top_root_dir = top_repo_root # XXXM : until backward compatibility can be broken
 
-version = ('$VERSION',0) # substituted at build time
+version        = ('$VERSION',0)          # substituted at build time
+has_namespaces = bool('$HAS_NAMESPACES') # .
 
 def check_version(major,minor=0) :
 	if major!=version[0] or minor>version[1] : raise RuntimeError('required version '+str((major,minor))+' is incompatible with native version '+str(version))
diff --git a/_lib/lmake/py_clmake.src.py b/_lib/lmake/py_clmake.src.py
index 35f2809..4490da9 100644
--- a/_lib/lmake/py_clmake.src.py
+++ b/_lib/lmake/py_clmake.src.py
@@ -70,8 +70,10 @@ else :
 	if not repo_root : del repo_root
 #
 autodeps = ()
-if "$HAS_LD_AUDIT" : autodeps += ('ld_audit'  ,                              )
-if True            : autodeps += ('ld_preload','ld_preload_jemalloc','ptrace')
+if "$HAS_LD_AUDIT"              : autodeps += ('ld_audit'           ,)
+if True                         : autodeps += ('ld_preload'         ,)
+if _os.uname().sysname=='Linux' : autodeps += ('ld_preload_jemalloc',)
+if "$HAS_PTRACE"                : autodeps += ('ptrace'             ,)
 #
 backends = ('local',)
 if "$HAS_SGE"   : backends += ('sge'  ,)
diff --git a/debian/changelog.src b/debian/changelog.src
index 728c9c2..5ee9e88 100644
--- a/debian/changelog.src
+++ b/debian/changelog.src
@@ -1,5 +1,5 @@
 open-lmake ($DEBIAN_VERSION) UNRELEASED; urgency=low
 
-  * support namespaces
+  * support Linux namespaces
 
  -- Cesar Douady <cesar.douady@doliam.fr>  $DATE
diff --git a/lmake_env/Lmakefile.py b/lmake_env/Lmakefile.py
index 1e7f2ab..f7588b1 100644
--- a/lmake_env/Lmakefile.py
+++ b/lmake_env/Lmakefile.py
@@ -282,51 +282,51 @@ class LinkExe(LinkRule) :
 class TarLmake(BaseRule) :
 	targets = { 'TAR' : 'lmake.tar.gz' }
 	deps = {
-		'SERIALIZE'           : '_lib/serialize.py'
-	,	'READ_MAKEFILES_PY'   : '_lib/read_makefiles.py'
-	,	'LD_PRELOAD'          : '_lib/ld_preload.so'
-	,	'LD_PRELOAD_JEMALLOC' : '_lib/ld_preload_jemalloc.so'
-	,	'AUTODEP'             : '_bin/lautodep'
-	,	'JOB_EXEC'            : '_bin/job_exec'
-	,	'LDUMP'               : '_bin/ldump'
-	,	'LDUMP_JOB'           : '_bin/ldump_job'
-	,	'LMAKESERVER'         : '_bin/lmakeserver'
-	,	'LIB_UTILS'           : 'lib/lmake/utils.py'
-	,	'LIB_INIT'            : 'lib/lmake/__init__.py'
-	,	'LIB1'                : 'lib/lmake/auto_sources.py'
-	,	'LIB2'                : 'lib/lmake/import_machinery.py'
-	,	'LIB3'                : 'lib/lmake/rules.py'
-	,	'LIB4'                : 'lib/lmake/sources.py'
-	,	'LIB_DBG_UTILS'       : 'lib/lmake_debug/utils.py'
-	,	'LIB_DBG1'            : 'lib/lmake_debug/default.py'
-	,	'LIB_DBG2'            : 'lib/lmake_debug/enter.py'
-	,	'LIB_DBG3'            : 'lib/lmake_debug/gdb.py'
-	,	'LIB_DBG4'            : 'lib/lmake_debug/none.py'
-	,	'LIB_DBG5'            : 'lib/lmake_debug/pudb.py'
-	,	'LIB_DBG6'            : 'lib/lmake_debug/vscode.py'
-	,	'LIB_DBG_RT_UTILS'    : 'lib/lmake_debug/runtime/utils.py'
-	,	'LIB_DBG_RT1'         : 'lib/lmake_debug/runtime/pdb_.py'
-	,	'LIB_DBG_RT2'         : 'lib/lmake_debug/runtime/pudb_.py'
-	,	'LIB_DBG_RT3'         : 'lib/lmake_debug/runtime/vscode.py'
-	,	'CLMAKE'              : 'lib/clmake.so'
-	,	'ALIGN_COMMENTS'      : 'bin/align_comments'
-	,	'LCHECK_DEPS'         : 'bin/lcheck_deps'
-	,	'LDBG'                : 'bin/ldebug'
-	,	'LDECODE'             : 'bin/ldecode'
-	,	'LDEPEND'             : 'bin/ldepend'
-	,	'LENCODE'             : 'bin/lencode'
-	,	'LFORGET'             : 'bin/lforget'
-	,	'LMAKE'               : 'bin/lmake'
-	,	'LMARK'               : 'bin/lmark'
-	,	'LREPAIR'             : 'bin/lrepair'
-	,	'LSHOW'               : 'bin/lshow'
-	,	'LTARGET'             : 'bin/ltarget'
-	,	'XXHSUM'              : 'bin/xxhsum'
-	,	'DOC'                 : 'doc/lmake.html'
+		'SERIALIZE'         : '_lib/serialize.py'
+	,	'READ_MAKEFILES_PY' : '_lib/read_makefiles.py'
+	,	'LD_PRELOAD'        : '_lib/ld_preload.so'
+	,	'AUTODEP'           : '_bin/lautodep'
+	,	'JOB_EXEC'          : '_bin/job_exec'
+	,	'LDUMP'             : '_bin/ldump'
+	,	'LDUMP_JOB'         : '_bin/ldump_job'
+	,	'LMAKESERVER'       : '_bin/lmakeserver'
+	,	'LIB_UTILS'         : 'lib/lmake/utils.py'
+	,	'LIB_INIT'          : 'lib/lmake/__init__.py'
+	,	'LIB1'              : 'lib/lmake/auto_sources.py'
+	,	'LIB2'              : 'lib/lmake/import_machinery.py'
+	,	'LIB3'              : 'lib/lmake/rules.py'
+	,	'LIB4'              : 'lib/lmake/sources.py'
+	,	'LIB_DBG_UTILS'     : 'lib/lmake_debug/utils.py'
+	,	'LIB_DBG1'          : 'lib/lmake_debug/default.py'
+	,	'LIB_DBG2'          : 'lib/lmake_debug/enter.py'
+	,	'LIB_DBG3'          : 'lib/lmake_debug/gdb.py'
+	,	'LIB_DBG4'          : 'lib/lmake_debug/none.py'
+	,	'LIB_DBG5'          : 'lib/lmake_debug/pudb.py'
+	,	'LIB_DBG6'          : 'lib/lmake_debug/vscode.py'
+	,	'LIB_DBG_RT_UTILS'  : 'lib/lmake_debug/runtime/utils.py'
+	,	'LIB_DBG_RT1'       : 'lib/lmake_debug/runtime/pdb_.py'
+	,	'LIB_DBG_RT2'       : 'lib/lmake_debug/runtime/pudb_.py'
+	,	'LIB_DBG_RT3'       : 'lib/lmake_debug/runtime/vscode.py'
+	,	'CLMAKE'            : 'lib/clmake.so'
+	,	'ALIGN_COMMENTS'    : 'bin/align_comments'
+	,	'LCHECK_DEPS'       : 'bin/lcheck_deps'
+	,	'LDBG'              : 'bin/ldebug'
+	,	'LDECODE'           : 'bin/ldecode'
+	,	'LDEPEND'           : 'bin/ldepend'
+	,	'LENCODE'           : 'bin/lencode'
+	,	'LFORGET'           : 'bin/lforget'
+	,	'LMAKE'             : 'bin/lmake'
+	,	'LMARK'             : 'bin/lmark'
+	,	'LREPAIR'           : 'bin/lrepair'
+	,	'LSHOW'             : 'bin/lshow'
+	,	'LTARGET'           : 'bin/ltarget'
+	,	'XXHSUM'            : 'bin/xxhsum'
+	,	'DOC'               : 'doc/lmake.html'
 	}
 	def gen_files() :
 		files = list(deps.values())
-		if sys_config('HAS_LD_AUDIT') : files.append('_lib/ld_audit.so')
+		if os.uname().sysname=='Linux' : files.append('_lib/ld_preload_jemalloc.so')
+		if sys_config('HAS_LD_AUDIT')  : files.append('_lib/ld_audit.so'           )
 		return files
 	cmd = '''
 		for f in       {' '.join(gen_files())} ; do echo $f ; done
diff --git a/museum/src/autodep/fuse.cc b/museum/src/autodep/fuse.cc
index 1300d16..0780ad4 100644
--- a/museum/src/autodep/fuse.cc
+++ b/museum/src/autodep/fuse.cc
@@ -546,10 +546,10 @@ namespace Fuse {
 					{ .tv_sec=0 , .tv_nsec=UTIME_OMIT }
 				,	{ .tv_sec=0 , .tv_nsec=UTIME_OMIT }
 				} ;
-				if      ( valid & FUSE_SET_ATTR_ATIME_NOW ) tv[0].tv_nsec = UTIME_NOW     ;
-				else if ( valid & FUSE_SET_ATTR_ATIME     ) tv[0]         = attr->st_atim ;
-				if      ( valid & FUSE_SET_ATTR_MTIME_NOW ) tv[1].tv_nsec = UTIME_NOW     ;
-				else if ( valid & FUSE_SET_ATTR_MTIME     ) tv[1]         = attr->st_mtim ;
+				if      ( valid & FUSE_SET_ATTR_ATIME_NOW ) tv[0].tv_nsec = UTIME_NOW          ;
+				else if ( valid & FUSE_SET_ATTR_ATIME     ) tv[0]         = attr->st_atim      ;
+				if      ( valid & FUSE_SET_ATTR_MTIME_NOW ) tv[1].tv_nsec = UTIME_NOW          ;
+				else if ( valid & FUSE_SET_ATTR_MTIME     ) tv[1]         = attr->ST_MTIMESPEC ;
 				if (fi) { int rc = ::futimens ( fi->fh   ,                              tv     ) ; if (rc<0) throw errno ; }
 				else    { int rc = ::utimensat( AT_FDCWD , self.fds.proc(ino).c_str() , tv , 0 ) ; if (rc<0) throw errno ; }
 			}
diff --git a/src/autodep/clmake.cc b/src/autodep/clmake.cc
index f410b8d..ecefd40 100644
--- a/src/autodep/clmake.cc
+++ b/src/autodep/clmake.cc
@@ -279,12 +279,12 @@ PyMODINIT_FUNC
 	_g_record = {New,Yes/*enabled*/} ;
 	//
 	//
-	Ptr<Tuple> py_ads { HAS_LD_AUDIT+3} ; // PER_AUTODEP_METHOD : add entries here
+	Ptr<Tuple> py_ads { HAS_LD_AUDIT+1+IS_LINUX+HAS_PTRACE } ; // PER_AUTODEP_METHOD : add entries here
 	size_t i = 0 ;
 	if (HAS_LD_AUDIT) py_ads->set_item( i++ , *Ptr<Str>("ld_audit"           ) ) ;
 	/**/              py_ads->set_item( i++ , *Ptr<Str>("ld_preload"         ) ) ;
-	/**/              py_ads->set_item( i++ , *Ptr<Str>("ld_preload_jemalloc") ) ;
-	/**/              py_ads->set_item( i++ , *Ptr<Str>("ptrace"             ) ) ;
+	if (IS_LINUX    ) py_ads->set_item( i++ , *Ptr<Str>("ld_preload_jemalloc") ) ;
+	if (HAS_PTRACE  ) py_ads->set_item( i++ , *Ptr<Str>("ptrace"             ) ) ;
 	SWEAR(i==py_ads->size(),i,py_ads->size()) ;
 	//
 	Ptr<Tuple>  py_bes { 1+HAS_SGE+HAS_SLURM } ;      // PER_BACKEND : add entries here
diff --git a/src/autodep/gather.cc b/src/autodep/gather.cc
index 1a04b86..10544a4 100644
--- a/src/autodep/gather.cc
+++ b/src/autodep/gather.cc
@@ -6,7 +6,9 @@
 #include "app.hh"
 #include "thread.hh"
 
-#include "ptrace.hh"
+#if HAS_PTRACE
+	#include "ptrace.hh"
+#endif
 #include "record.hh"
 
 #include "gather.hh"
@@ -149,28 +151,34 @@ void Gather::_send_to_server( Fd fd , Jerr&& jerr ) {
 	}
 }
 
-void Gather::_ptrace_child( Fd report_fd , ::latch* ready ) {
-	t_thread_key = 'T' ;
-	AutodepPtrace::s_init(autodep_env) ;
-	_child.pre_exec = AutodepPtrace::s_prepare_child  ;
-	//vvvvvvvvvvvv
-	_child.spawn() ;                                                      // /!\ although not mentioned in man ptrace, child must be launched by the tracing thread
-	//^^^^^^^^^^^^
-	ready->count_down() ;                                                 // signal main thread that _child.pid is available
-	AutodepPtrace autodep_ptrace{_child.pid} ;
-	wstatus = autodep_ptrace.process() ;
-	_child.waited() ;                                                     // _child is already waited by autodep_ptrace.process
-	ssize_t cnt = write(report_fd,&::ref(char()),1) ; SWEAR(cnt==1,cnt) ; // report child end
-	Record::s_close_report() ;
+#if HAS_PTRACE
+	void Gather::_ptrace_child( Fd report_fd , ::latch* ready ) {
+		t_thread_key = 'T' ;
+		AutodepPtrace::s_init(autodep_env) ;
+		_child.pre_exec = AutodepPtrace::s_prepare_child  ;
+		//vvvvvvvvvvvv
+		_child.spawn() ;                                                      // /!\ although not mentioned in man ptrace, child must be launched by the tracing thread
+		//^^^^^^^^^^^^
+		ready->count_down() ;                                                 // signal main thread that _child.pid is available
+		AutodepPtrace autodep_ptrace{_child.pid} ;
+		wstatus = autodep_ptrace.process() ;
+		_child.waited() ;                                                     // _child is already waited by autodep_ptrace.process
+		ssize_t cnt = write(report_fd,&::ref(char()),1) ; SWEAR(cnt==1,cnt) ; // report child end
+		Record::s_close_report() ;
 	}
+#endif
 
 Fd Gather::_spawn_child() {
 	SWEAR(+cmd_line) ;
 	Trace trace("_spawn_child",child_stdin,child_stdout,child_stderr) ;
 	//
 	Fd child_fd ;
-	Fd   report_fd ;
-	bool is_ptrace = method==AutodepMethod::Ptrace ;
+	#if HAS_PTRACE
+		Fd   report_fd ;
+		bool is_ptrace = method==AutodepMethod::Ptrace ;
+	#else
+		bool is_ptrace = false ;
+	#endif
 	//
 	_add_env          = { {"LMAKE_AUTODEP_ENV",autodep_env} } ;                                  // required even with method==None or ptrace to allow support (ldepend, lmake module, ...) to work
 	_child.as_session = as_session                            ;
@@ -179,12 +187,15 @@ Fd Gather::_spawn_child() {
 	_child.stderr_fd  = child_stderr                          ;
 	_child.first_pid  = first_pid                             ;
 	if (is_ptrace) {                                                                             // PER_AUTODEP_METHOD : handle case
-		// we split the responsability into 2 threads :
-		// - parent watches for data (stdin, stdout, stderr & incoming connections to report deps)
-		// - child launches target process using ptrace and watches it using direct wait (without signalfd) then report deps using normal socket report
-		Pipe pipe{New,true/*no_std*/} ;
-		child_fd  = pipe.read  ;
-		report_fd = pipe.write ;
+		SWEAR(HAS_PTRACE) ;
+		#if HAS_PTRACE
+			// we split the responsability into 2 threads :
+			// - parent watches for data (stdin, stdout, stderr & incoming connections to report deps)
+			// - child launches target process using ptrace and watches it using direct wait (without signalfd) then report deps using normal socket report
+			Pipe pipe{New,true/*no_std*/} ;
+			child_fd  = pipe.read  ;
+			report_fd = pipe.write ;
+		#endif
 	} else {
 		if (method>=AutodepMethod::Ld) {                                                         // PER_AUTODEP_METHOD : handle case
 			::string env_var ;
@@ -198,7 +209,9 @@ Fd Gather::_spawn_child() {
 					case AutodepMethod::LdAudit           : env_var = "LD_AUDIT"   ; _add_env[env_var] = *g_lmake_root_s + "_d" DOLLAR_LIB "/ld_audit.so"            ; break ;
 				#endif
 					case AutodepMethod::LdPreload         : env_var = "LD_PRELOAD" ; _add_env[env_var] = *g_lmake_root_s + "_d" DOLLAR_LIB "/ld_preload.so"          ; break ;
+				#if IS_LINUX
 					case AutodepMethod::LdPreloadJemalloc : env_var = "LD_PRELOAD" ; _add_env[env_var] = *g_lmake_root_s + "_d" DOLLAR_LIB "/ld_preload_jemalloc.so" ; break ;
+				#endif
 				#undef DOLLAR_LIB
 			DF}
 			if (env) { if (env->contains(env_var)) _add_env[env_var] += ':' + env->at(env_var) ; }
@@ -212,9 +225,12 @@ Fd Gather::_spawn_child() {
 	_child.add_env  = &_add_env ;
 	_child.cwd_s    = cwd_s     ;
 	if (is_ptrace) {
-		::latch ready{1} ;
-		_ptrace_thread = ::jthread( _s_ptrace_child , this , report_fd , &ready ) ;              // /!\ _child must be spawned from tracing thread
-		ready.wait() ;                                                                           // wait until _child.pid is available
+		SWEAR(HAS_PTRACE) ;
+		#if HAS_PTRACE
+			::latch ready{1} ;
+			_ptrace_thread = ::jthread( _s_ptrace_child , this , report_fd , &ready ) ;          // /!\ _child must be spawned from tracing thread
+			ready.wait() ;                                                                       // wait until _child.pid is available
+		#endif
 	} else {
 		//vvvvvvvvvvvv
 		_child.spawn() ;
@@ -222,7 +238,7 @@ Fd Gather::_spawn_child() {
 	}
 	if (+timeout) { _end_timeout = start_date + timeout ; trace("set_timeout",timeout,_end_timeout) ; }
 	trace("child_pid",_child.pid) ;
-	return child_fd ;                                                                            // child_fd is only used with ptrace
+	return child_fd ;
 }
 Status Gather::exec_child() {
 	using Event = Epoll<Kind>::Event ;
diff --git a/src/autodep/gather.hh b/src/autodep/gather.hh
index 188cd40..ae3c80b 100644
--- a/src/autodep/gather.hh
+++ b/src/autodep/gather.hh
@@ -89,7 +89,9 @@ struct Gather {
 	} ;
 	// statics
 private :
-	static void _s_ptrace_child( void* self_ , Fd report_fd , ::latch* ready ) { reinterpret_cast<Gather*>(self_)->_ptrace_child(report_fd,ready) ; }
+	#if HAS_PTRACE
+		static void _s_ptrace_child( void* self_ , Fd report_fd , ::latch* ready ) { reinterpret_cast<Gather*>(self_)->_ptrace_child(report_fd,ready) ; }
+	#endif
 	// services
 	void _solve( Fd , Jerr& jerr) ;
 	// Fd for trace purpose only
@@ -122,8 +124,10 @@ public : //!
 	//
 	void reorder(bool at_end) ;                                                                       // reorder accesses by first read access and suppress superfluous accesses
 private :
-	Fd   _spawn_child (                               ) ;
-	void _ptrace_child( Fd report_fd , ::latch* ready ) ;
+	Fd _spawn_child() ;
+	#if HAS_PTRACE
+		void _ptrace_child( Fd report_fd , ::latch* ready ) ;
+	#endif
 	// data
 public :
 	::vector_s                        cmd_line         ;
@@ -168,5 +172,7 @@ private :
 	NodeIdx             _parallel_id   = 0          ;                                                 // id to identify parallel deps
 	bool                _timeout_fired = false      ;
 	BitMap<Kind>        _wait          ;                                                              // events we are waiting for
-	::jthread           _ptrace_thread ;
+	#if HAS_PTRACE
+		::jthread _ptrace_thread ;
+	#endif
 } ;
diff --git a/src/autodep/ld_common.x.cc b/src/autodep/ld_common.x.cc
index ccfb12b..3a263b5 100644
--- a/src/autodep/ld_common.x.cc
+++ b/src/autodep/ld_common.x.cc
@@ -15,7 +15,12 @@
 
 #include "disk.hh"
 
-#define NE noexcept
+#if IS_DARWIN
+	#include <crt_externs.h> // _GetNSEnviron
+	#define NE               // Darwin does not define exception specifications
+#else
+	#define NE noexcept
+#endif
 
 #include "gather.hh"
 #include "record.hh"
@@ -39,7 +44,7 @@
 	#define O_TMPFILE 0 // no check for O_TMPFILE if it does not exist0
 #endif
 
-#define NEED_ELF (!LD_AUDIT) // else elf dependencies are captured by auditing code or unavailable
+#define NEED_ELF ( !LD_AUDIT && HAS_ELF ) // else elf dependencies are captured by auditing code or unavailable
 
 #if NEED_ELF
 	#include <dlfcn.h> // dlopen
@@ -71,7 +76,6 @@ using namespace Disk ;
 extern "C" {
 	// the following libcalls are defined in libc not always in #include's, so they may be called by application code
 	// they may not be defined on all systems, but it does not hurt to redeclare them if they are already declared, so filter may be loose
-	extern int     __clone2        ( int (*fn)(void*) , void *stack_base , size_t stack_size , int flags , void *arg , ...    ) ;
 	extern int     __close         (         int fd                                                                           )    ;
 	extern int     __dup2          (         int oldfd , int newfd                                                            ) NE ;
 	extern pid_t   __fork          (                                                                                          ) NE ;
@@ -91,21 +95,24 @@ extern "C" {
 	extern int     faccessat2      (         int dirfd , const char* pth , int mod , int flgs                                 ) NE ;
 	extern int     renameat2       (         int odfd  , const char* op  , int ndfd , const char* np , uint flgs              ) NE ;
 	extern int     statx           (         int dirfd , const char* pth , int flgs , uint msk , struct statx* buf            ) NE ;
-	//
-	extern int __open64         (                   const char* pth , int flgs , ...                )    ;
-	extern int __open64_nocancel(                   const char* pth , int flgs , ...                )    ;
-	extern int __open64_2       (                   const char* pth , int flgs                      )    ;
-	extern int __openat64_2     (         int dfd , const char* pth , int flgs                      )    ;
-	extern int __xstat64        ( int v ,           const char* pth , struct stat64* buf            ) NE ;
-	extern int __lxstat64       ( int v ,           const char* pth , struct stat64* buf            ) NE ;
-	extern int __fxstatat64     ( int v , int dfd , const char* pth , struct stat64* buf , int flgs ) NE ;
-	//
 	#if HAS_CLOSE_RANGE
 		extern int close_range( uint fd1 , uint fd2 , int flgs ) NE ;
 	#endif
+	#if HAS_NAMESPACES
+		int __clone2( int (*fn)(void*) , void *stack_base , size_t stack_size , int flags , void *arg , ... ) ;
+	#endif
 	#if !LINUX_VFORK
 		extern pid_t __vfork() NE ;
 	#endif
+	#if HAS_OFF64
+		extern int __open64         (                   const char* pth , int flgs , ...                )    ;
+		extern int __open64_nocancel(                   const char* pth , int flgs , ...                )    ;
+		extern int __open64_2       (                   const char* pth , int flgs                      )    ;
+		extern int __openat64_2     (         int dfd , const char* pth , int flgs                      )    ;
+		extern int __xstat64        ( int v ,           const char* pth , struct stat64* buf            ) NE ;
+		extern int __lxstat64       ( int v ,           const char* pth , struct stat64* buf            ) NE ;
+		extern int __fxstatat64     ( int v , int dfd , const char* pth , struct stat64* buf , int flgs ) NE ;
+	#endif
 }
 
 static              Mutex<MutexLvl::Autodep2> _g_mutex ;         // ensure exclusivity between threads
@@ -359,45 +366,47 @@ struct Mkstemp : WSolve {
 	int chmod   (      CC* p,mode_t m      ) NE { HEADER1(chmod   ,false,p,(  p,m  )) ; Chmod r{   p ,EXE(m),false   ,"chmod"   } ; return r(orig(  p,m  )) ; }
 	int fchmodat(int d,CC* p,mode_t m,int f) NE { HEADER1(fchmodat,false,p,(d,p,m,f)) ; Chmod r{{d,p},EXE(m),ASLNF(f),"fchmodat"} ; return r(orig(d,p,m,f)) ; }
 
-	// clone
-	// cf fork about why this wrapper is necessary
-	static int (*_clone_fn)(void*) ;       // variable to hold actual function to call
-	static int _call_clone_fn(void* arg) {
-		_t_loop = false ;
-		_g_mutex.unlock(MutexLvl::None) ;  // contrarily to fork, clone does not proceed but calls a function and the lock must be released in both parent and child (we are the only thread here)
-		return _clone_fn(arg) ;
-	}
-	int clone( int (*fn)(void*) , void *stack , int flags , void *arg , ... ) NE {
-		va_list args ;
-		va_start(args,arg) ;
-		pid_t* parent_tid = va_arg(args,pid_t*) ;
-		void * tls        = va_arg(args,void *) ;
-		pid_t* child_tid  = va_arg(args,pid_t*) ;
-		va_end(args) ;
-		//
-		ORIG(clone) ;
-		if ( _t_loop || !started() || flags&CLONE_VM ) return (*atomic_orig)(fn,stack,flags,arg,parent_tid,tls,child_tid) ; // if flags contains CLONE_VM, lock is not duplicated : nothing to do
-		NO_SERVER(clone) ;
-		Lock lock{_g_mutex} ;                                                                                               // no need to set _t_loop as clone calls no other piggy-backed function
-		_clone_fn = fn ;                                                                                                    // _g_mutex is held, so there is no risk of clash
-		return (*atomic_orig)(_call_clone_fn,stack,flags,arg,parent_tid,tls,child_tid) ;
-	}
-	int __clone2( int (*fn)(void*) , void *stack , size_t stack_size , int flags , void *arg , ... ) {
-		va_list args ;
-		va_start(args,arg) ;
-		pid_t* parent_tid = va_arg(args,pid_t*) ;
-		void * tls        = va_arg(args,void *) ;
-		pid_t* child_tid  = va_arg(args,pid_t*) ;
-		va_end(args) ;
-		//
-		ORIG(__clone2) ;
-		if ( _t_loop || !started() || flags&CLONE_VM ) return (*atomic_orig)(fn,stack,stack_size,flags,arg,parent_tid,tls,child_tid) ; // cf clone
-		Lock lock{_g_mutex} ;                                                                                                          // cf clone
-		//
-		NO_SERVER(__clone2) ;
-		_clone_fn = fn ;                                                                                                               // cf clone
-		return (*atomic_orig)(_call_clone_fn,stack,stack_size,flags,arg,parent_tid,tls,child_tid) ;
+	#if HAS_NAMESPACES
+		// clone
+		// cf fork about why this wrapper is necessary
+		static int (*_clone_fn)(void*) ;       // variable to hold actual function to call
+		static int _call_clone_fn(void* arg) {
+			_t_loop = false ;
+			_g_mutex.unlock(MutexLvl::None) ;  // contrarily to fork, clone does not proceed but calls a function and the lock must be released in both parent and child (we are the only thread here)
+			return _clone_fn(arg) ;
 		}
+		int clone( int (*fn)(void*) , void *stack , int flags , void *arg , ... ) NE {
+			va_list args ;
+			va_start(args,arg) ;
+			pid_t* parent_tid = va_arg(args,pid_t*) ;
+			void * tls        = va_arg(args,void *) ;
+			pid_t* child_tid  = va_arg(args,pid_t*) ;
+			va_end(args) ;
+			//
+			ORIG(clone) ;
+			if ( _t_loop || !started() || flags&CLONE_VM ) return (*atomic_orig)(fn,stack,flags,arg,parent_tid,tls,child_tid) ; // if flags contains CLONE_VM, lock is not duplicated : nothing to do
+			NO_SERVER(clone) ;
+			Lock lock{_g_mutex} ;                                                                                               // no need to set _t_loop as clone calls no other piggy-backed function
+			_clone_fn = fn ;                                                                                                    // _g_mutex is held, so there is no risk of clash
+			return (*atomic_orig)(_call_clone_fn,stack,flags,arg,parent_tid,tls,child_tid) ;
+		}
+		int __clone2( int (*fn)(void*) , void *stack , size_t stack_size , int flags , void *arg , ... ) {
+			va_list args ;
+			va_start(args,arg) ;
+			pid_t* parent_tid = va_arg(args,pid_t*) ;
+			void * tls        = va_arg(args,void *) ;
+			pid_t* child_tid  = va_arg(args,pid_t*) ;
+			va_end(args) ;
+			//
+			ORIG(__clone2) ;
+			if ( _t_loop || !started() || flags&CLONE_VM ) return (*atomic_orig)(fn,stack,stack_size,flags,arg,parent_tid,tls,child_tid) ; // cf clone
+			Lock lock{_g_mutex} ;                                                                                                          // cf clone
+			//
+			NO_SERVER(__clone2) ;
+			_clone_fn = fn ;                                                                                                               // cf clone
+			return (*atomic_orig)(_call_clone_fn,stack,stack_size,flags,arg,parent_tid,tls,child_tid) ;
+		}
+	#endif
 
 	#if !IN_SERVER
 		// close
@@ -453,12 +462,18 @@ struct Mkstemp : WSolve {
 			Lock lock { _g_mutex       } ;               \
 			Exec( path , no_follow , envp , #libcall ) ; \
 		}
+	#if IS_DARWIN
+		#define environ (*_NSGetEnviron())
+	#endif
 	//                                                                                                                 no_follow
 	int execv   (         CC* p , char* const argv[]                                 ) NE { HEADER_EXEC(Exec ,execv   ,false      ,               p ,environ) ; return orig(  p,argv          ) ; }
 	int execve  (         CC* p , char* const argv[] , char* const envp[]            ) NE { HEADER_EXEC(Exec ,execve  ,false      ,               p ,envp   ) ; return orig(  p,argv,envp     ) ; }
 	int execvp  (         CC* p , char* const argv[]                                 ) NE { HEADER_EXEC(Execp,execvp  ,false      ,               p ,environ) ; return orig(  p,argv          ) ; }
 	int execvpe (         CC* p , char* const argv[] , char* const envp[]            ) NE { HEADER_EXEC(Execp,execvpe ,false      ,               p ,envp   ) ; return orig(  p,argv,envp     ) ; }
 	int execveat( int d , CC* p , char* const argv[] , char *const envp[] , int flgs ) NE { HEADER_EXEC(Exec ,execveat,ASLNF(flgs),Record::Path(d,p),envp   ) ; return orig(d,p,argv,envp,flgs) ; }
+	#if IS_DARWIN
+		#undef environ
+	#endif
 	// execl
 	#define MK_ARGS(end_action,value) \
 		char*   cur         = const_cast<char*>(arg)            ;            \
@@ -483,9 +498,10 @@ struct Mkstemp : WSolve {
 	// fopen                                             is_stat
 	FILE* fopen  (CC* p,CC* m         ) { HEADER1(fopen  ,false,p,(p,m   )) ; Fopen r{p,m,"fopen"  } ; return r(orig(p,m   )) ; }
 	FILE* freopen(CC* p,CC* m,FILE* fp) { HEADER1(freopen,false,p,(p,m,fp)) ; Fopen r{p,m,"freopen"} ; return r(orig(p,m,fp)) ; }
-	//                                                       is_stat
+	#if HAS_OFF64 //!                                        is_stat
 	FILE* fopen64  (CC* p,CC* m         ) { HEADER1(fopen64  ,false,p,(p,m   )) ; Fopen r{p,m,"fopen64"  } ; return r(orig(p,m   )) ; }
 	FILE* freopen64(CC* p,CC* m,FILE* fp) { HEADER1(freopen64,false,p,(p,m,fp)) ; Fopen r{p,m,"freopen64"} ; return r(orig(p,m,fp)) ; }
+	#endif
 
 	// fork
 	// not recursively called by auditing code
@@ -516,51 +532,60 @@ struct Mkstemp : WSolve {
 	int mkostemp (char* t,int f       ) { HEADER0(mkostemp ,false,(t,f   )) ; Mkstemp r{t,   "mkostemp" } ; return r(orig(t,f   )) ; }
 	int mkstemps (char* t,      int sl) { HEADER0(mkstemps ,false,(t,  sl)) ; Mkstemp r{t,sl,"mkstemps" } ; return r(orig(t,  sl)) ; }
 	int mkostemps(char* t,int f,int sl) { HEADER0(mkostemps,false,(t,f,sl)) ; Mkstemp r{t,sl,"mkostemps"} ; return r(orig(t,f,sl)) ; }
-	//                                                         is_stat
-	int mkstemp64  (char* t             ) { HEADER0(mkstemp64  ,false,(t     )) ; Mkstemp r{t,   "mkstemp64"  } ; return r(orig(t     )) ; }
-	int mkostemp64 (char* t,int f       ) { HEADER0(mkostemp64 ,false,(t,f   )) ; Mkstemp r{t,   "mkostemp64" } ; return r(orig(t,f   )) ; }
-	int mkstemps64 (char* t,      int sl) { HEADER0(mkstemps64 ,false,(t,  sl)) ; Mkstemp r{t,sl,"mkstemps64" } ; return r(orig(t,  sl)) ; }
-	int mkostemps64(char* t,int f,int sl) { HEADER0(mkostemps64,false,(t,f,sl)) ; Mkstemp r{t,sl,"mkostemps64"} ; return r(orig(t,f,sl)) ; }
-
-	// mount
-	int mount(CC* sp,CC* tp,CC* fst,ulong f,const void* d) {
-		HEADER( mount , false/*is_stat*/ , !(f&MS_BIND) || (Record::s_is_simple(sp)&&Record::s_is_simple(tp)) , (sp,tp,fst,f,d) ) ;
-		Mount r{sp,tp,"mount"} ;
-		return r(orig(sp,tp,fst,f,d)) ;
+	#if HAS_OFF64 //!                                              is_stat
+		int mkstemp64  (char* t             ) { HEADER0(mkstemp64  ,false,(t     )) ; Mkstemp r{t,   "mkstemp64"  } ; return r(orig(t     )) ; }
+		int mkostemp64 (char* t,int f       ) { HEADER0(mkostemp64 ,false,(t,f   )) ; Mkstemp r{t,   "mkostemp64" } ; return r(orig(t,f   )) ; }
+		int mkstemps64 (char* t,      int sl) { HEADER0(mkstemps64 ,false,(t,  sl)) ; Mkstemp r{t,sl,"mkstemps64" } ; return r(orig(t,  sl)) ; }
+		int mkostemps64(char* t,int f,int sl) { HEADER0(mkostemps64,false,(t,f,sl)) ; Mkstemp r{t,sl,"mkostemps64"} ; return r(orig(t,f,sl)) ; }
+	#endif
+
+	#if HAS_NAMESPACES
+		// mount
+		int mount(CC* sp,CC* tp,CC* fst,ulong f,const void* d) {
+			HEADER( mount , false/*is_stat*/ , !(f&MS_BIND) || (Record::s_is_simple(sp)&&Record::s_is_simple(tp)) , (sp,tp,fst,f,d) ) ;
+			Mount r{sp,tp,"mount"} ;
+			return r(orig(sp,tp,fst,f,d)) ;
 		}
+	#endif
 
-	// name_to_handle_at
-	int name_to_handle_at( int d , CC* p , struct ::file_handle *h , int *mount_id , int f ) NE {
-		HEADER1( name_to_handle_at , false/*is_stat*/ , p , (d,p,h,mount_id,f) ) ;
-		Open r{{d,p},f,"name_to_handle_at"} ;
-		return r(orig(d,p,h,mount_id,f)) ;
-	}
+	#if HAS_FILE_HANDLE
+		// name_to_handle_at
+		int name_to_handle_at( int d , CC* p , struct ::file_handle *h , int *mount_id , int f ) NE {
+			HEADER1( name_to_handle_at , false/*is_stat*/ , p , (d,p,h,mount_id,f) ) ;
+			Open r{{d,p},f,"name_to_handle_at"} ;
+			return r(orig(d,p,h,mount_id,f)) ;
+		}
+	#endif
 
 	// open
 	static_assert( ::is_unsigned_v<mode_t> && sizeof(mode_t)<=sizeof(uint) ) ;
 	#define MOD mode_t m = 0 ; if ( f & (O_CREAT|O_TMPFILE) ) { va_list lst ; va_start(lst,f) ; m = mode_t(va_arg(lst,uint)) ; va_end(lst) ; }
-	//                                                                        is_stat
-	int open           (      CC* p,int f,...) { MOD ; HEADER1(open           ,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"open"           } ; return r(orig(  p,f,m)) ; }
-	int __open         (      CC* p,int f,...) { MOD ; HEADER1(__open         ,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"__open"         } ; return r(orig(  p,f,m)) ; }
-	int __open_nocancel(      CC* p,int f,...) { MOD ; HEADER1(__open_nocancel,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"__open_nocancel"} ; return r(orig(  p,f,m)) ; }
-	int __open_2       (      CC* p,int f    ) {       HEADER1(__open_2       ,false,p,(  p,f  )) ; Open r{   p ,f                         ,"__open_2"       } ; return r(orig(  p,f  )) ; }
-	int openat         (int d,CC* p,int f,...) { MOD ; HEADER1(openat         ,false,p,(d,p,f,m)) ; Open r{{d,p},f                         ,"openat"         } ; return r(orig(d,p,f,m)) ; }
-	int __openat_2     (int d,CC* p,int f    ) {       HEADER1(__openat_2     ,false,p,(d,p,f  )) ; Open r{{d,p},f                         ,"__openat_2"     } ; return r(orig(d,p,f  )) ; }
-	int creat          (      CC* p,mode_t m ) {       HEADER1(creat          ,false,p,(  p,  m)) ; Open r{   p ,(O_CREAT|O_WRONLY|O_TRUNC),"creat"          } ; return r(orig(  p,  m)) ; }
-	//                                                                            is_stat
-	int open64           (      CC* p,int f,...) { MOD ; HEADER1(open64           ,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"open64"           } ; return r(orig(  p,f,m)) ; }
-	int __open64         (      CC* p,int f,...) { MOD ; HEADER1(__open64         ,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"__open64"         } ; return r(orig(  p,f,m)) ; }
-	int __open64_nocancel(      CC* p,int f,...) { MOD ; HEADER1(__open64_nocancel,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"__open64_nocancel"} ; return r(orig(  p,f,m)) ; }
-	int __open64_2       (      CC* p,int f    ) {       HEADER1(__open64_2       ,false,p,(  p,f  )) ; Open r{   p ,f                         ,"__open64_2"       } ; return r(orig(  p,f  )) ; }
-	int openat64         (int d,CC* p,int f,...) { MOD ; HEADER1(openat64         ,false,p,(d,p,f,m)) ; Open r{{d,p},f                         ,"openat64"         } ; return r(orig(d,p,f,m)) ; }
-	int __openat64_2     (int d,CC* p,int f    ) {       HEADER1(__openat64_2     ,false,p,(d,p,f  )) ; Open r{{d,p},f                         ,"__openat64_2"     } ; return r(orig(d,p,f  )) ; }
-	int creat64          (      CC* p,mode_t m ) {       HEADER1(creat64          ,false,p,(  p,  m)) ; Open r{   p ,(O_CREAT|O_WRONLY|O_TRUNC),"creat64"          } ; return r(orig(  p,  m)) ; }
+	//                                                                          is_stat
+	int open           (      CC* p,int f,...) { MOD ; HEADER1(open             ,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"open"             } ; return r(orig(  p,f,m)) ; }
+	int __open         (      CC* p,int f,...) { MOD ; HEADER1(__open           ,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"__open"           } ; return r(orig(  p,f,m)) ; }
+	int __open_nocancel(      CC* p,int f,...) { MOD ; HEADER1(__open_nocancel  ,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"__open_nocancel"  } ; return r(orig(  p,f,m)) ; }
+	int __open_2       (      CC* p,int f    ) {       HEADER1(__open_2         ,false,p,(  p,f  )) ; Open r{   p ,f                         ,"__open_2"         } ; return r(orig(  p,f  )) ; }
+	int openat         (int d,CC* p,int f,...) { MOD ; HEADER1(openat           ,false,p,(d,p,f,m)) ; Open r{{d,p},f                         ,"openat"           } ; return r(orig(d,p,f,m)) ; }
+	int __openat_2     (int d,CC* p,int f    ) {       HEADER1(__openat_2       ,false,p,(d,p,f  )) ; Open r{{d,p},f                         ,"__openat_2"       } ; return r(orig(d,p,f  )) ; }
+	int creat          (      CC* p,mode_t m ) {       HEADER1(creat            ,false,p,(  p,  m)) ; Open r{   p ,(O_CREAT|O_WRONLY|O_TRUNC),"creat"            } ; return r(orig(  p,  m)) ; }
+	#if HAS_OFF64 //!                                                                 is_stat
+		int open64           (      CC* p,int f,...) { MOD ; HEADER1(open64           ,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"open64"           } ; return r(orig(  p,f,m)) ; }
+		int __open64         (      CC* p,int f,...) { MOD ; HEADER1(__open64         ,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"__open64"         } ; return r(orig(  p,f,m)) ; }
+		int __open64_nocancel(      CC* p,int f,...) { MOD ; HEADER1(__open64_nocancel,false,p,(  p,f,m)) ; Open r{   p ,f                         ,"__open64_nocancel"} ; return r(orig(  p,f,m)) ; }
+		int __open64_2       (      CC* p,int f    ) {       HEADER1(__open64_2       ,false,p,(  p,f  )) ; Open r{   p ,f                         ,"__open64_2"       } ; return r(orig(  p,f  )) ; }
+		int openat64         (int d,CC* p,int f,...) { MOD ; HEADER1(openat64         ,false,p,(d,p,f,m)) ; Open r{{d,p},f                         ,"openat64"         } ; return r(orig(d,p,f,m)) ; }
+		int __openat64_2     (int d,CC* p,int f    ) {       HEADER1(__openat64_2     ,false,p,(d,p,f  )) ; Open r{{d,p},f                         ,"__openat64_2"     } ; return r(orig(d,p,f  )) ; }
+		int creat64          (      CC* p,mode_t m ) {       HEADER1(creat64          ,false,p,(  p,  m)) ; Open r{   p ,(O_CREAT|O_WRONLY|O_TRUNC),"creat64"          } ; return r(orig(  p,  m)) ; }
+	#endif
 	#undef MOD
 	DIR* opendir(CC* p) { HEADER1(opendir,false/*is_stat*/,p,(p)) ; Solve r{p,true/*no_follow*/,false/*read*/,false/*create*/,"opendir"  } ; return r(orig(p)) ; }
 
 	// readlink
 	#define RL Readlink
 	#if LD_PRELOAD_JEMALLOC
+		#if !IS_LINUX                                                      // we need the __readlink_chk hack, which is only available under Linux
+			#error cannot implement ld_preload_jemalloc if not under Linux
+		#endif
 		// jemalloc does a readlink of its config file (/etc/jemalloc.conf) during its init phase
 		// under some circumstances (not really understood), dlsym, which is necessary to find the original readlink function calls malloc
 		// this creates a loop, leading to a deadlock in jemalloc as it takes a mutex during its init phase
@@ -604,8 +629,9 @@ struct Mkstemp : WSolve {
 
 	// truncate                                      is_stat
 	int truncate(CC* p,off_t l) NE { HEADER1(truncate,false,p,(p,l)) ; Open r{p,l?O_RDWR:O_WRONLY,"truncate"} ; return r(orig(p,l)) ; }
-	//                                                     is_stat
-	int truncate64(CC* p,off64_t l) NE { HEADER1(truncate64,false,p,(p,l)) ; Open r{p,l?O_RDWR:O_WRONLY,"truncate64"} ; return r(orig(p,l)) ; }
+	#if HAS_OFF64 //!                                          is_stat
+		int truncate64(CC* p,off64_t l) NE { HEADER1(truncate64,false,p,(p,l)) ; Open r{p,l?O_RDWR:O_WRONLY,"truncate64"} ; return r(orig(p,l)) ; }
+	#endif
 
 	// unlink                                            is_stat
 	int unlink  (      CC* p      ) NE { HEADER1(unlink  ,false,p,(  p  )) ; Unlnk r{   p ,false/*rmdir*/      ,"unlink"  } ; return r(orig(  p  )) ; }
@@ -632,13 +658,14 @@ struct Mkstemp : WSolve {
 	int stat      (            CC* p,struct stat  * b      ) NE { HEADER1(stat      ,true ,p,(    p,b  )) ; Stat r{   p ,false   ,~Accesses(),"stat"      } ; return r(orig(    p,b  )) ; }
 	int lstat     (            CC* p,struct stat  * b      ) NE { HEADER1(lstat     ,true ,p,(    p,b  )) ; Stat r{   p ,true    ,~Accesses(),"lstat"     } ; return r(orig(    p,b  )) ; }
 	int fstatat   (      int d,CC* p,struct stat  * b,int f) NE { HEADER1(fstatat   ,true ,p,(  d,p,b,f)) ; Stat r{{d,p},ASLNF(f),~Accesses(),"fstatat"   } ; return r(orig(  d,p,b,f)) ; }
-	//                                                                                  is_stat                             no_follow accesses
-	int __xstat64   (int v,      CC* p,struct stat64* b      ) NE { HEADER1(__xstat64   ,true ,p,(v,  p,b  )) ; Stat r{   p ,false   ,~Accesses(),"__xstat64"   } ; return r(orig(v,  p,b  )) ; }
-	int __lxstat64  (int v,      CC* p,struct stat64* b      ) NE { HEADER1(__lxstat64  ,true ,p,(v,  p,b  )) ; Stat r{   p ,true    ,~Accesses(),"__lxstat64"  } ; return r(orig(v,  p,b  )) ; }
-	int __fxstatat64(int v,int d,CC* p,struct stat64* b,int f) NE { HEADER1(__fxstatat64,true ,p,(v,d,p,b,f)) ; Stat r{{d,p},ASLNF(f),~Accesses(),"__fxstatat64"} ; return r(orig(v,d,p,b,f)) ; }
-	int stat64      (            CC* p,struct stat64* b      ) NE { HEADER1(stat64      ,true ,p,(    p,b  )) ; Stat r{   p ,false   ,~Accesses(),"stat64"      } ; return r(orig(    p,b  )) ; }
-	int lstat64     (            CC* p,struct stat64* b      ) NE { HEADER1(lstat64     ,true ,p,(    p,b  )) ; Stat r{   p ,true    ,~Accesses(),"lstat64"     } ; return r(orig(    p,b  )) ; }
-	int fstatat64   (      int d,CC* p,struct stat64* b,int f) NE { HEADER1(fstatat64   ,true ,p,(  d,p,b,f)) ; Stat r{{d,p},ASLNF(f),~Accesses(),"fstatat64"   } ; return r(orig(  d,p,b,f)) ; }
+	#if HAS_OFF64 //!                                                                       is_stat                             no_follow accesses
+		int __xstat64   (int v,      CC* p,struct stat64* b      ) NE { HEADER1(__xstat64   ,true ,p,(v,  p,b  )) ; Stat r{   p ,false   ,~Accesses(),"__xstat64"   } ; return r(orig(v,  p,b  )) ; }
+		int __lxstat64  (int v,      CC* p,struct stat64* b      ) NE { HEADER1(__lxstat64  ,true ,p,(v,  p,b  )) ; Stat r{   p ,true    ,~Accesses(),"__lxstat64"  } ; return r(orig(v,  p,b  )) ; }
+		int __fxstatat64(int v,int d,CC* p,struct stat64* b,int f) NE { HEADER1(__fxstatat64,true ,p,(v,d,p,b,f)) ; Stat r{{d,p},ASLNF(f),~Accesses(),"__fxstatat64"} ; return r(orig(v,d,p,b,f)) ; }
+		int stat64      (            CC* p,struct stat64* b      ) NE { HEADER1(stat64      ,true ,p,(    p,b  )) ; Stat r{   p ,false   ,~Accesses(),"stat64"      } ; return r(orig(    p,b  )) ; }
+		int lstat64     (            CC* p,struct stat64* b      ) NE { HEADER1(lstat64     ,true ,p,(    p,b  )) ; Stat r{   p ,true    ,~Accesses(),"lstat64"     } ; return r(orig(    p,b  )) ; }
+		int fstatat64   (      int d,CC* p,struct stat64* b,int f) NE { HEADER1(fstatat64   ,true ,p,(  d,p,b,f)) ; Stat r{{d,p},ASLNF(f),~Accesses(),"fstatat64"   } ; return r(orig(  d,p,b,f)) ; }
+	#endif
 	//
 	int statx(int d,CC* p,int f,uint msk,struct statx* b) NE {                   // statx must exist even if statx is not supported by the system as it appears in ENUMERATE_LIBCALLS
 		HEADER1(statx,true/*is_stat*/,p,(d,p,f,msk,b)) ;
@@ -665,57 +692,60 @@ struct Mkstemp : WSolve {
 	//                                                                  is_stat                               no_follow read  create
 	int scandir  (      CC* p,NmLst nl,Fltr f,Cmp c) { HEADER1(scandir  ,false,p,(  p,nl,f,c)) ; Solve r{   p ,true    ,false,false,"scandir"  } ; return r(orig(  p,nl,f,c)) ; }
 	int scandirat(int d,CC* p,NmLst nl,Fltr f,Cmp c) { HEADER1(scandirat,false,p,(d,p,nl,f,c)) ; Solve r{{d,p},true    ,false,false,"scandirat"} ; return r(orig(d,p,nl,f,c)) ; }
-	//
-	using NmLst64 = struct dirent64***                                       ;
-	using Fltr64  = int (*)(const struct dirent64*                         ) ;
-	using Cmp64   = int (*)(const struct dirent64**,const struct dirent64**) ;
-	//                                                                            is_stat                               no_follow read  create
-	int scandir64  (      CC* p,NmLst64 nl,Fltr64 f,Cmp64 c) { HEADER1(scandir64  ,false,p,(  p,nl,f,c)) ; Solve r{   p ,true    ,false,false,"scandir64"  } ; return r(orig(  p,nl,f,c)) ; }
-	int scandirat64(int d,CC* p,NmLst64 nl,Fltr64 f,Cmp64 c) { HEADER1(scandirat64,false,p,(d,p,nl,f,c)) ; Solve r{{d,p},true    ,false,false,"scandirat64"} ; return r(orig(d,p,nl,f,c)) ; }
+	#if HAS_OFF64
+		using NmLst64 = struct dirent64***                                       ;
+		using Fltr64  = int (*)(const struct dirent64*                         ) ;
+		using Cmp64   = int (*)(const struct dirent64**,const struct dirent64**) ;
+		//                                                                            is_stat                               no_follow read  create
+		int scandir64  (      CC* p,NmLst64 nl,Fltr64 f,Cmp64 c) { HEADER1(scandir64  ,false,p,(  p,nl,f,c)) ; Solve r{   p ,true    ,false,false,"scandir64"  } ; return r(orig(  p,nl,f,c)) ; }
+		int scandirat64(int d,CC* p,NmLst64 nl,Fltr64 f,Cmp64 c) { HEADER1(scandirat64,false,p,(d,p,nl,f,c)) ; Solve r{{d,p},true    ,false,false,"scandirat64"} ; return r(orig(d,p,nl,f,c)) ; }
+	#endif
 
 	#undef CC
 
-	// syscall
-	// /!\ we must be very careful to avoid dead-lock :
-	// - mutex calls futex management, which sometimes call syscall
-	// - so filter on s_tab must be done before locking (in HEADER)
-	// - this requires that s_tab does no memory allocation as memory allocation may call brk
-	// - hence it is a ::array, not a ::umap (which would be simpler)
-	long syscall( long n , ... ) {
-		static constexpr SyscallDescr NoSyscallDescr ;
-		uint64_t args[6] ;
-		{	va_list lst ; va_start(lst,n) ;
-			args[0] = va_arg(lst,uint64_t) ;
-			args[1] = va_arg(lst,uint64_t) ;
-			args[2] = va_arg(lst,uint64_t) ;
-			args[3] = va_arg(lst,uint64_t) ;
-			args[4] = va_arg(lst,uint64_t) ;
-			args[5] = va_arg(lst,uint64_t) ;
-			va_end(lst) ;
+	#if !IS_DARWIN                                                                                       // syscall is deprecated with Darwin ==> ignore
+		// syscall
+		// /!\ we must be very careful to avoid dead-lock :
+		// - mutex calls futex management, which sometimes call syscall
+		// - so filter on s_tab must be done before locking (in HEADER)
+		// - this requires that s_tab does no memory allocation as memory allocation may call brk
+		// - hence it is a ::array, not a ::umap (which would be simpler)
+		decltype(syscall(0)) syscall( long n , ... ) {                                                   // syscall may return int (Darwin) or long (Linux)
+			static constexpr SyscallDescr NoSyscallDescr ;
+			uint64_t args[6] ;
+			{	va_list lst ; va_start(lst,n) ;
+				args[0] = va_arg(lst,uint64_t) ;
+				args[1] = va_arg(lst,uint64_t) ;
+				args[2] = va_arg(lst,uint64_t) ;
+				args[3] = va_arg(lst,uint64_t) ;
+				args[4] = va_arg(lst,uint64_t) ;
+				args[5] = va_arg(lst,uint64_t) ;
+				va_end(lst) ;
+			}
+			SyscallDescr::Tab const& tab   = SyscallDescr::s_tab                                       ;
+			SyscallDescr      const& descr = n>=0&&n<SyscallDescr::NSyscalls ? tab[n] : NoSyscallDescr ; // protect against arbitrary invalid syscall numbers
+			HEADER(
+				syscall
+			,	false/*is_stat*/
+			,	!descr || (descr.filter&&Record::s_is_simple(reinterpret_cast<const char*>(args[descr.filter-1])))
+			,	(n,args[0],args[1],args[2],args[3],args[4],args[5])
+			) ;
+			void* descr_ctx = nullptr ;
+			Ctx audit_ctx ;                                                                              // save user errno when required
+			//               vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
+			if (descr.entry) descr.entry( descr_ctx , auditor() , 0/*pid*/ , args , descr.comment ) ;
+			//               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+			audit_ctx.restore_errno() ;
+			//         vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
+			long res = orig(n,args[0],args[1],args[2],args[3],args[4],args[5]) ;
+			//         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+			audit_ctx.save_errno() ;
+			//                     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
+			if (descr.exit) return descr.exit( descr_ctx , auditor() , 0/*pid*/ , res ) ;
+			else            return res                                                  ;
+			//                     ^^^
 		}
-		SyscallDescr::Tab const& tab   = SyscallDescr::s_tab                                       ;
-		SyscallDescr      const& descr = n>=0&&n<SyscallDescr::NSyscalls ? tab[n] : NoSyscallDescr ; // protect against arbitrary invalid syscall numbers
-		HEADER(
-			syscall
-		,	false/*is_stat*/
-		,	!descr || (descr.filter&&Record::s_is_simple(reinterpret_cast<const char*>(args[descr.filter-1])))
-		,	(n,args[0],args[1],args[2],args[3],args[4],args[5])
-		) ;
-		void* descr_ctx = nullptr ;
-		Ctx audit_ctx ;                                                                              // save user errno when required
-		//               vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
-		if (descr.entry) descr.entry( descr_ctx , auditor() , 0/*pid*/ , args , descr.comment ) ;
-		//               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-		audit_ctx.restore_errno() ;
-		//         vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
-		long res = orig(n,args[0],args[1],args[2],args[3],args[4],args[5]) ;
-		//         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-		audit_ctx.save_errno() ;
-		//                     vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
-		if (descr.exit) return descr.exit( descr_ctx , auditor() , 0/*pid*/ , res ) ;
-		else            return res                                                  ;
-		//                     ^^^
-	}
+	#endif
 
 	#undef NO_SERVER
 	#undef HEADER2
diff --git a/src/autodep/ptrace.cc b/src/autodep/ptrace.cc
index c1c08ed..eb57b76 100644
--- a/src/autodep/ptrace.cc
+++ b/src/autodep/ptrace.cc
@@ -14,6 +14,11 @@
 
 #include "ptrace.hh"
 
+#if !HAS_PTRACE
+	#error cannot compile ptrace.cc without HAS_PTRACE
+#endif
+
+
 #if HAS_PTRACE_GET_SYSCALL_INFO
 	#include <linux/audit.h>    // AUDIT_ARCH_*
 #endif
diff --git a/src/autodep/ptrace.hh b/src/autodep/ptrace.hh
index 6a6ebb8..1b2ed91 100644
--- a/src/autodep/ptrace.hh
+++ b/src/autodep/ptrace.hh
@@ -5,11 +5,15 @@
 
 #pragma once
 
-#include <sys/ptrace.h>
-
 #include "gather.hh"
 #include "record.hh"
 
+#if !HAS_PTRACE
+	#error cannot include ptrace.hh without HAS_PTRACE
+#endif
+
+#include <sys/ptrace.h>
+
 #if HAS_PTRACE_GET_SYSCALL_INFO        // must be after utils.hh include, use portable calls if implemented
 	#include <linux/ptrace.h>          // for struct ptrace_syscall_info, must be after sys/ptrace.h to avoid stupid request macro definitions
 	#if MUST_UNDEF_PTRACE_MACROS       // must be after utils.hh include
diff --git a/src/autodep/record.cc b/src/autodep/record.cc
index 39dcd92..cf8cd3c 100644
--- a/src/autodep/record.cc
+++ b/src/autodep/record.cc
@@ -58,12 +58,14 @@ bool Record::s_is_simple(const char* file) {
 			else if (strncmp(file+4,"32/",3)   ) top_sz = 7 ;     // in lib32    => simple
 			else if (strncmp(file+4,"64/",3)   ) top_sz = 7 ;     // in lib64    => simple
 		break ;                                                   // else        => not simple
-		case 'p' :                                                // for /proc, must be a somewhat surgical because of jemalloc accesses and making these simple is the easiest way to avoid malloc's
-			if ( strncmp(file+1,"proc/",5)!=0 ) break ;           // not in /proc      => not simple
-			if ( file[6]>='0' && file[6]<='9' ) break ;           // in /proc/<pid>    => not simple
-			if ( strncmp(file+6,"self/",5)==0 ) break ;           // not in /proc/self => not simple
-			top_sz = 6 ;                                          // else              => simple
-		break ;
+		#if IS_LINUX
+			case 'p' :                                            // for /proc, must be a somewhat surgical because of jemalloc accesses and making these simple is the easiest way to avoid malloc's
+				if ( strncmp(file+1,"proc/",5)!=0 ) break ;       // not in /proc      => not simple
+				if ( file[6]>='0' && file[6]<='9' ) break ;       // in /proc/<pid>    => not simple
+				if ( strncmp(file+6,"self/",5)==0 ) break ;       // not in /proc/self => not simple
+				top_sz = 6 ;                                      // else              => simple
+			break ;
+		#endif
 	DN}
 	if (!top_sz) return false ;
 	int depth = 0 ;
diff --git a/src/autodep/syscall_tab.cc b/src/autodep/syscall_tab.cc
index 034ecc0..1efae56 100644
--- a/src/autodep/syscall_tab.cc
+++ b/src/autodep/syscall_tab.cc
@@ -6,7 +6,11 @@
 #include <syscall.h>   // for SYS_* macros
 #include <sys/mount.h>
 
-#include "ptrace.hh"
+#include "utils.hh" // HAS_PTRACE
+
+#if HAS_PTRACE
+	#include "ptrace.hh"
+#endif
 #include "record.hh"
 
 #include "syscall_tab.hh"
@@ -14,48 +18,54 @@
 // return null terminated string pointed by src in process pid's space
 [[maybe_unused]] static ::string _get_str( pid_t pid , uint64_t src ) {
 	if (!pid) return {reinterpret_cast<const char*>(src)} ;
-	::string res ;
-	errno = 0 ;
-	for(;;) {
-		uint64_t offset = src%sizeof(long)                                               ;
-		long     word   = ::ptrace( PTRACE_PEEKDATA , pid , src-offset , nullptr/*data*/ ) ;
-		if (errno) throw errno ;
-		char buf[sizeof(long)] ; ::memcpy( buf , &word , sizeof(long) ) ;
-		for( uint64_t len : iota(sizeof(long)-offset) ) if (!buf[offset+len]) { res.append( buf+offset , len                 ) ; return res ; }
-		/**/                                                                    res.append( buf+offset , sizeof(long)-offset ) ;
-		src += sizeof(long)-offset ;
-	}
+	#if HAS_PTRACE
+		::string res ;
+		errno = 0 ;
+		for(;;) {
+			uint64_t offset = src%sizeof(long)                                               ;
+			long     word   = ::ptrace( PTRACE_PEEKDATA , pid , src-offset , nullptr/*data*/ ) ;
+			if (errno) throw errno ;
+			char buf[sizeof(long)] ; ::memcpy( buf , &word , sizeof(long) ) ;
+			for( uint64_t len : iota(sizeof(long)-offset) ) if (!buf[offset+len]) { res.append( buf+offset , len                 ) ; return res ; }
+			/**/                                                                    res.append( buf+offset , sizeof(long)-offset ) ;
+			src += sizeof(long)-offset ;
+		}
+	#else
+		FAIL() ;
+	#endif
 }
 
-// copy process pid's space @ src to dst
-[[maybe_unused]] static void _peek( pid_t pid , char* dst , uint64_t src , size_t sz ) {
-	SWEAR(pid) ;
-	errno = 0 ;
-	for( size_t chunk ; sz ; src+=chunk , dst+=chunk , sz-=chunk) {                   // invariant : copy src[i:sz] to dst
-		size_t offset = src%sizeof(long) ;
-		long   word   = ::ptrace( PTRACE_PEEKDATA , pid , src-offset , nullptr/*data*/ ) ;
-		if (errno) throw errno ;
-		chunk = ::min( sizeof(long) - offset , sz ) ;
-		::memcpy( dst , reinterpret_cast<char*>(&word)+offset , chunk ) ;
-	}
-}
-// copy src to process pid's space @ dst
-[[maybe_unused]] static void _poke( pid_t pid , uint64_t dst , const char* src , size_t sz ) {
-	SWEAR(pid) ;
-	errno = 0 ;
-	for( size_t chunk ; sz ; src+=chunk , dst+=chunk , sz-=chunk) {                   // invariant : copy src[i:sz] to dst
-		size_t offset = dst%sizeof(long) ;
-		long   word   = 0/*garbage*/     ;
-		chunk = ::min( sizeof(long) - offset , sz ) ;
-		if ( offset || offset+chunk<sizeof(long) ) {                                  // partial word
-			word = ::ptrace( PTRACE_PEEKDATA , pid , dst-offset , nullptr/*data*/ ) ;
+#if HAS_PTRACE
+	// copy process pid's space @ src to dst
+	[[maybe_unused]] static void _peek( pid_t pid , char* dst , uint64_t src , size_t sz ) {
+		SWEAR(pid) ;
+		errno = 0 ;
+		for( size_t chunk ; sz ; src+=chunk , dst+=chunk , sz-=chunk) { // invariant : copy src[i:sz] to dst
+			size_t offset = src%sizeof(long) ;
+			long   word   = ::ptrace( PTRACE_PEEKDATA , pid , src-offset , nullptr/*data*/ ) ;
 			if (errno) throw errno ;
+			chunk = ::min( sizeof(long) - offset , sz ) ;
+			::memcpy( dst , reinterpret_cast<char*>(&word)+offset , chunk ) ;
 		}
-		::memcpy( reinterpret_cast<char*>(&word)+offset , src , chunk ) ;
-		::ptrace( PTRACE_POKEDATA , pid , dst-offset , word ) ;
-		if (errno) throw errno ;
 	}
+	// copy src to process pid's space @ dst
+	[[maybe_unused]] static void _poke( pid_t pid , uint64_t dst , const char* src , size_t sz ) {
+		SWEAR(pid) ;
+		errno = 0 ;
+		for( size_t chunk ; sz ; src+=chunk , dst+=chunk , sz-=chunk) {                 // invariant : copy src[i:sz] to dst
+			size_t offset = dst%sizeof(long) ;
+			long   word   = 0/*garbage*/     ;
+			chunk = ::min( sizeof(long) - offset , sz ) ;
+			if ( offset || offset+chunk<sizeof(long) ) {                                // partial word
+				word = ::ptrace( PTRACE_PEEKDATA , pid , dst-offset , nullptr/*data*/ ) ;
+				if (errno) throw errno ;
+			}
+			::memcpy( reinterpret_cast<char*>(&word)+offset , src , chunk ) ;
+			::ptrace( PTRACE_POKEDATA , pid , dst-offset , word ) ;
+			if (errno) throw errno ;
+		}
 	}
+#endif
 
 template<bool At> [[maybe_unused]] static Record::Path _path( pid_t pid , uint64_t const* args ) {
 	::string arg = _get_str(pid,args[At]) ;
@@ -182,10 +192,14 @@ template<bool At> [[maybe_unused]] static void _entry_read_lnk( void* & ctx , Re
 	if (ctx) {
 		RLB* rlb = static_cast<RLB*>(ctx) ;
 		SWEAR( res<=ssize_t(rlb->first.sz) , res , rlb->first.sz ) ;
-		if ( pid && res>=0 ) _peek( pid , rlb->first.buf , rlb->second , res ) ;
+		#if HAS_PTRACE
+			if ( pid && res>=0 ) _peek( pid , rlb->first.buf , rlb->second , res ) ;
+		#endif
 		res = (rlb->first)(r,res) ;
 		if (pid) {
-			if ( rlb->first.emulated && res>=0 ) _poke( pid , rlb->second , rlb->first.buf , res ) ; // access to backdoor was emulated, we must transport result to actual user space
+			#if HAS_PTRACE
+				if ( rlb->first.emulated && res>=0 ) _poke( pid , rlb->second , rlb->first.buf , res ) ; // access to backdoor was emulated, we must transport result to actual user space
+			#endif
 			delete[] rlb->first.buf ;
 		}
 		delete rlb ;
diff --git a/src/autodep/syscall_tab.hh b/src/autodep/syscall_tab.hh
index 4971a4d..60fd364 100644
--- a/src/autodep/syscall_tab.hh
+++ b/src/autodep/syscall_tab.hh
@@ -51,6 +51,19 @@ struct SyscallDescr {
 //
 // mere path accesses, no actual accesses to file data */
 //
+#if HAS_OFF64
+	#define ENUMERATE_PATH_LIBCALLS_64 /*is_stat*/ \
+	,	LIBCALL_ENTRY(fstatat64          ,true ) \
+	,	LIBCALL_ENTRY(__fxstatat64       ,true ) \
+	,	LIBCALL_ENTRY(lstat64            ,true ) \
+	,	LIBCALL_ENTRY(__lxstat64         ,true ) \
+	,	LIBCALL_ENTRY(scandir64          ,false) \
+	,	LIBCALL_ENTRY(scandirat64        ,false) \
+	,	LIBCALL_ENTRY(stat64             ,true ) \
+	,	LIBCALL_ENTRY(__xstat64          ,true )
+#else
+	#define ENUMERATE_PATH_LIBCALLS_64
+#endif
 #define ENUMERATE_PATH_LIBCALLS       /*is_stat*/ \
 ,	LIBCALL_ENTRY(access                ,true ) \
 ,	LIBCALL_ENTRY(canonicalize_file_name,false) \
@@ -68,16 +81,27 @@ struct SyscallDescr {
 ,	LIBCALL_ENTRY(statx                 ,true ) \
 ,	LIBCALL_ENTRY(stat                  ,true ) \
 ,	LIBCALL_ENTRY(__xstat               ,true ) \
-\
-,	LIBCALL_ENTRY(fstatat64             ,true ) \
-,	LIBCALL_ENTRY(__fxstatat64          ,true ) \
-,	LIBCALL_ENTRY(lstat64               ,true ) \
-,	LIBCALL_ENTRY(__lxstat64            ,true ) \
-,	LIBCALL_ENTRY(scandir64             ,false) \
-,	LIBCALL_ENTRY(scandirat64           ,false) \
-,	LIBCALL_ENTRY(stat64                ,true ) \
-,	LIBCALL_ENTRY(__xstat64             ,true )
+	ENUMERATE_PATH_LIBCALLS_64
 
+#if HAS_OFF64
+	#define ENUMERATE_LIBCALLS_64    /*is_stat*/ \
+	,	LIBCALL_ENTRY(creat64          ,false) \
+	,	LIBCALL_ENTRY(fopen64          ,false) \
+	,	LIBCALL_ENTRY(freopen64        ,false) \
+	,	LIBCALL_ENTRY(mkostemp64       ,false) \
+	,	LIBCALL_ENTRY(mkostemps64      ,false) \
+	,	LIBCALL_ENTRY(mkstemp64        ,false) \
+	,	LIBCALL_ENTRY(mkstemps64       ,false) \
+	,	LIBCALL_ENTRY(open64           ,false) \
+	,	LIBCALL_ENTRY(__open64         ,false) \
+	,	LIBCALL_ENTRY(__open64_nocancel,false) \
+	,	LIBCALL_ENTRY(__open64_2       ,false) \
+	,	LIBCALL_ENTRY(openat64         ,false) \
+	,	LIBCALL_ENTRY(__openat64_2     ,false) \
+	,	LIBCALL_ENTRY(truncate64       ,false)
+#else
+	#define ENUMERATE_LIBCALLS_64
+#endif
 #define ENUMERATE_LIBCALLS       /*is_stat*/ \
 	LIBCALL_ENTRY(chdir            ,false) \
 ,	LIBCALL_ENTRY(chmod            ,false) \
@@ -137,22 +161,7 @@ struct SyscallDescr {
 ,	LIBCALL_ENTRY(utime            ,false) \
 ,	LIBCALL_ENTRY(utimensat        ,false) \
 ,	LIBCALL_ENTRY(utimes           ,false) \
-\
-,	LIBCALL_ENTRY(creat64          ,false) \
-,	LIBCALL_ENTRY(fopen64          ,false) \
-,	LIBCALL_ENTRY(freopen64        ,false) \
-,	LIBCALL_ENTRY(mkostemp64       ,false) \
-,	LIBCALL_ENTRY(mkostemps64      ,false) \
-,	LIBCALL_ENTRY(mkstemp64        ,false) \
-,	LIBCALL_ENTRY(mkstemps64       ,false) \
-,	LIBCALL_ENTRY(open64           ,false) \
-,	LIBCALL_ENTRY(__open64         ,false) \
-,	LIBCALL_ENTRY(__open64_nocancel,false) \
-,	LIBCALL_ENTRY(__open64_2       ,false) \
-,	LIBCALL_ENTRY(openat64         ,false) \
-,	LIBCALL_ENTRY(__openat64_2     ,false) \
-,	LIBCALL_ENTRY(truncate64       ,false) \
-\
+	ENUMERATE_LIBCALLS_64                  \
 	ENUMERATE_LD_PRELOAD_LIBCALLS          \
 	ENUMERATE_PATH_LIBCALLS                \
 	ENUMERATE_VFORK_LIBCALLS
diff --git a/src/disk.cc b/src/disk.cc
index 054e80a..beb649a 100644
--- a/src/disk.cc
+++ b/src/disk.cc
@@ -4,11 +4,14 @@
 // This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
 #include <sys/mman.h>
-#include <sys/sendfile.h>
 
 #include "disk.hh"
 #include "hash.hh"
 
+#if HAS_SENDFILE
+	#include <sys/sendfile.h>
+#endif
+
 using namespace filesystem ;
 
 // ENUM macro does not work inside namespace's
@@ -220,8 +223,8 @@ namespace Disk {
 		return rc==0 && st.st_nlink>1 ;
 	}
 
-	bool/*done*/ uniquify( Fd at , ::string const& file ) {                                 // uniquify file so as to ensure modifications do not alter other hard links
-		SWEAR(+file) ;                                                                      // cannot unlink at without file
+	bool/*done*/ uniquify( Fd at , ::string const& file ) {                                      // uniquify file so as to ensure modifications do not alter other hard links
+		SWEAR(+file) ;                                                                           // cannot unlink at without file
 		const char*   f   = file.c_str() ;
 		const char*   msg = nullptr      ;
 		{
@@ -239,8 +242,8 @@ namespace Disk {
 				if (cnt<0 ) throw "cannot read "+file ;
 				wfd.write({buf,sizeof(buf)}) ;
 			}
-			struct ::timespec times[2] = { {.tv_sec=0,.tv_nsec=UTIME_OMIT} , st.st_mtim } ;
-			::futimens(wfd,times) ;                                                         // maintain original date
+			struct ::timespec times[2] = { {.tv_sec=0,.tv_nsec=UTIME_OMIT} , st.ST_MTIMESPEC } ;
+			::futimens(wfd,times) ;                                                              // maintain original date
 			//
 			return true/*done*/ ;
 		}
@@ -321,7 +324,11 @@ namespace Disk {
 				dir_guard(dst_at,dst_file) ;
 				AcFd rfd {             src_at , src_file }                                                                                                                             ;
 				AcFd wfd { ::openat( dst_at , dst_file.c_str() , O_WRONLY|O_CREAT|O_NOFOLLOW|O_CLOEXEC|O_TRUNC , 0777 & ~(tag==FileTag::Exe?0000:0111) & ~(mk_read_only?0222:0000) ) } ;
-				::sendfile( wfd , rfd , nullptr , fi.sz ) ;
+				#if HAS_SENDFILE
+					::sendfile( wfd , rfd , nullptr , fi.sz ) ;
+				#else
+					wfd.write( rfd.read(fi.sz) ) ;
+				#endif
 			} break ;
 			case FileTag::Lnk :
 				dir_guard(dst_at,dst_file) ;
@@ -436,8 +443,10 @@ namespace Disk {
 	// /!\ : this code must be in sync with RealPath::solve
 	FileLoc RealPathEnv::file_loc(::string const& real) const {
 		::string abs_real   = mk_abs(real,repo_root_s) ;
-		if (abs_real.starts_with(tmp_dir_s  )) return FileLoc::Tmp  ;
-		if (abs_real.starts_with("/proc/"   )) return FileLoc::Proc ;
+		if (abs_real.starts_with(tmp_dir_s )) return FileLoc::Tmp  ;
+		#if IS_LINUX
+			if (abs_real.starts_with("/proc/")) return FileLoc::Proc ;
+		#endif
 		if (abs_real.starts_with(repo_root_s)) {
 			if ((mk_lcl(abs_real,repo_root_s)+'/').starts_with(AdminDirS)) return FileLoc::Admin ;
 			else                                                           return FileLoc::Repo  ;
@@ -449,7 +458,7 @@ namespace Disk {
 		}
 	}
 
-	void RealPath::_Dvg::update( ::string const& domain , ::string const& chk ) {
+	void RealPath::_DvgReal::update( ::string const& domain , ::string const& chk ) {
 		size_t start = dvg ;
 		ok  = domain.size() <= chk.size()     ;
 		dvg = ok ? domain.size() : chk.size() ;
@@ -506,18 +515,28 @@ namespace Disk {
 		::string      tmp_dir       = +_env->tmp_dir_s?no_slash(_env->tmp_dir_s  ):""s ;
 		::string      real          ; real.reserve(file.size()) ;                        // canonical (link free, absolute, no ., .. nor empty component). Empty instead of '/'. Anticipate no link
 		if (!pos) {                                                                      // file is relative, meaning relative to at
-			if      (at==Fd::Cwd) real = cwd()                                 ;
-			else if (pid        ) real = read_lnk(s_proc+'/'+pid+"/fd/"+at.fd) ;
-			else                  real = read_lnk(s_proc+"/self/fd/"   +at.fd) ;
+			if      (at==Fd::Cwd)                     real = cwd()                                 ;
+			else if (pid        ) { SWEAR(IS_LINUX) ; real = read_lnk(s_proc+'/'+pid+"/fd/"+at.fd) ; }
+			else {
+				#if IS_LINUX
+					real = read_lnk(s_proc+"/self/fd/"   +at.fd) ;
+				#elif IS_DARWIN
+					real.resize(PATH_MAX) ;
+					::fcntl( at.fd , F_GETPATH , real.data() ) ;
+					real.resize(::strlen(real.data())) ;
+				#else
+					#error dont know how to make a file name from a file descriptor
+				#endif
+			}
 			//
 			if (!is_abs(real) ) return {} ;                                              // user code might use the strangest at, it will be an error but we must support it
 			if (real.size()==1) real.clear() ;                                           // if '/', we must substitute the empty string to enforce invariant
 		}
-		_Dvg in_repo   { repo_root  , real }         ;                                   // keep track of where we are w.r.t. repo       , track symlinks according to lnk_support policy
-		_Dvg in_tmp    { tmp_dir    , real }         ;                                   // keep track of where we are w.r.t. tmp        , always track symlinks
-		_Dvg in_admin  { _admin_dir , real }         ;                                   // keep track of where we are w.r.t. repo/LMAKE , never track symlinks, like files in no domain
-		_Dvg in_proc   { s_proc     , real }         ;                                   // keep track of where we are w.r.t. /proc      , always track symlinks
-		bool is_in_tmp = +_env->tmp_dir_s && +in_tmp ;
+		_Dvg<true/*Real*/> in_repo   { repo_root  , real }         ;                     // keep track of where we are w.r.t. repo       , track symlinks according to lnk_support policy
+		_Dvg<true/*Real*/> in_tmp    { tmp_dir    , real }         ;                     // keep track of where we are w.r.t. tmp        , always track symlinks
+		_Dvg<true/*Real*/> in_admin  { _admin_dir , real }         ;                     // keep track of where we are w.r.t. repo/LMAKE , never track symlinks, like files in no domain
+		_Dvg<IS_LINUX    > in_proc   { s_proc     , real }         ;                     // keep track of where we are w.r.t. /proc      , always track symlinks
+		bool               is_in_tmp = +_env->tmp_dir_s && +in_tmp ;
 		// loop INVARIANT : accessed file is real+'/'+cur.substr(pos)
 		// when pos>cur.size(), we are done and result is real
 		size_t   end       ;
@@ -638,6 +657,9 @@ namespace Disk {
 	}
 
 	void RealPath::chdir() {
+		#if !IS_LINUX
+			SWEAR(!pid,pid) ; // need /proc to find cwd of pid
+		#endif
 		if (pid)   _cwd = read_lnk("/proc/"s+pid+"/cwd") ;
 		else     { _cwd = no_slash(cwd_s())              ; _cwd_pid = ::getpid() ; }
 	}
diff --git a/src/disk.hh b/src/disk.hh
index 208188b..3a3345b 100644
--- a/src/disk.hh
+++ b/src/disk.hh
@@ -7,7 +7,7 @@
 
 #include <dirent.h>
 #include <fcntl.h>
-#include <sys/stat.h> // fstatat, fchmodat
+#include <sys/stat.h>  // fstatat, fchmodat
 
 #include "types.hh"
 #include "fd.hh"
@@ -295,9 +295,13 @@ namespace Disk {
 	inline Ddate           file_date     ( ::string const& file  , bool no_follow=true                                       ) { return file_date     (Fd::Cwd,file ,no_follow           ) ; }
 
 	inline ::string cwd_s() {
-		char cwd[PATH_MAX] ;                                   // use posix, not linux extension that allows to pass nullptr as argument and malloc's the returned string
-		if (!::getcwd(cwd,PATH_MAX)) throw "cannot get cwd"s ;
-		return with_slash(cwd) ;                               // cwd is "/" not empty when at root dir, so dont simply append '/'
+		char buf[PATH_MAX] ;                          // use posix, not linux extension that allows to pass nullptr as argument and malloc's the returned string
+		char* cwd          = ::getcwd(buf,PATH_MAX) ;
+		if (!cwd) throw "cannot get cwd"s ;
+		::string res{cwd} ;
+		SWEAR( res[0]=='/' , res[0] ) ;
+		if (res.size()==1) return res     ;           // special case / as ::getcwd returns /, not empty
+		else               return res+'/' ;
 	}
 
 	/**/   FileTag cpy( Fd dst_at , ::string const& dst_file , Fd src_at , ::string const& src_file , bool unlnk_dst=false , bool mk_read_only=false ) ;
@@ -348,9 +352,9 @@ namespace Disk {
 		} ;
 	private :
 		// helper class to help recognize when we are in repo or in tmp
-		struct _Dvg {
+		struct _DvgReal {
 			// cxtors & casts
-			_Dvg( ::string const& domain , ::string const& chk ) { update(domain,chk) ; }
+			_DvgReal( ::string const& domain , ::string const& chk ) { update(domain,chk) ; }
 			// accesses
 			bool operator+() const { return ok ; }
 			// services
@@ -359,6 +363,15 @@ namespace Disk {
 			bool   ok  = false ;
 			size_t dvg = 0     ;
 		} ;
+		struct _DvgFake {
+			// cxtors & casts
+			_DvgFake( ::string const& domain , ::string const& chk ) { update(domain,chk) ; }
+			// accesses
+			bool operator+() const { return false ; }
+			// services
+			void update( ::string const& /*domain*/ , ::string const& /*chk*/ ) {}
+		} ;
+		template<bool Real=true> using _Dvg = ::conditional_t<Real,_DvgReal,_DvgFake> ;
 		// statics
 	private :
 		// if No <=> no file, if Maybe <=> a regular file, if Yes <=> a link
@@ -385,11 +398,11 @@ namespace Disk {
 		SolveReport solve(         const char*     file , bool no_follow=false ) { return solve( Fd::Cwd ,               file  , no_follow ) ; }
 		SolveReport solve( Fd at ,                        bool no_follow=false ) { return solve( at      , ::string()          , no_follow ) ; }
 		//
-		vmap_s<Accesses> exec(SolveReport&) ;                             // arg is updated to reflect last interpreter
+		vmap_s<Accesses> exec(SolveReport&) ;             // arg is updated to reflect last interpreter
 		//
 		void chdir() ;
 		::string cwd() {
-			if ( !pid && ::getpid()!=_cwd_pid ) chdir() ;                 // refresh _cwd if it was updated in the child part of a clone
+			if ( !pid && ::getpid()!=_cwd_pid ) chdir() ; // refresh _cwd if it was updated in the child part of a clone
 			return _cwd ;
 		}
 	private :
@@ -400,10 +413,10 @@ namespace Disk {
 	private :
 		RealPathEnv const* _env            ;
 		::string           _admin_dir      ;
-		::vector_s         _abs_src_dirs_s ;                              // this is an absolute version of src_dirs
+		::vector_s         _abs_src_dirs_s ;              // this is an absolute version of src_dirs
 		size_t             _repo_root_sz   ;
 		::string           _cwd            ;
-		pid_t              _cwd_pid        = 0 ;                          // pid for which _cwd is valid if pid==0
+		pid_t              _cwd_pid        = 0 ;          // pid for which _cwd is valid if pid==0
 	} ;
 	::string& operator+=( ::string& , RealPath::SolveReport const& ) ;
 
diff --git a/src/fd.cc b/src/fd.cc
index 77e79f8..d980e73 100644
--- a/src/fd.cc
+++ b/src/fd.cc
@@ -14,7 +14,9 @@
 
 using namespace Time ;
 
-::uset<int>* _s_epoll_sigs = new ::uset<int> ;
+#if HAS_EPOLL
+	::uset<int>* _s_epoll_sigs = new ::uset<int> ;
+#endif
 
 ::string& operator+=( ::string& os , Fd           const& fd ) { return os << "Fd("           << fd.fd <<')' ; }
 ::string& operator+=( ::string& os , AcFd         const& fd ) { return os << "AcFd("         << fd.fd <<')' ; }
diff --git a/src/fd.hh b/src/fd.hh
index 045a16a..46b045e 100644
--- a/src/fd.hh
+++ b/src/fd.hh
@@ -5,13 +5,21 @@
 
 #pragma once
 
-#include <sys/epoll.h>
-#include <sys/eventfd.h>
-#include <sys/signalfd.h>
 #include <sys/socket.h>
 
 #include "time.hh"
 
+#if HAS_EVENTFD
+	#include <sys/eventfd.h>
+#endif
+
+#if HAS_EPOLL
+	#include <sys/epoll.h>
+	#include <sys/signalfd.h>
+#elif HAS_KQUEUE
+	#include <sys/event.h>
+#endif
+
 #ifndef SOCK_CLOEXEC
 	#define SOCK_CLOEXEC 0 // CLOEXEC is just defensive programming, not really needed
 #endif
@@ -230,148 +238,220 @@ struct Pipe {
 // EventFd
 //
 
-struct EventFd : AcFd {
-	EventFd(NewType) : AcFd{::eventfd(0,O_CLOEXEC),true/*no_std*/} {}
-	EventFd(Fd fd_ ) : AcFd{fd_                                  } {}
-	void wakeup() const {
-		static constexpr uint64_t One = 1 ;
-		ssize_t cnt = ::write(self,&One,sizeof(One)) ;
-		SWEAR( cnt==sizeof(One) , cnt,self ) ;
-	}
-	void flush() const {
-		uint64_t one ;
-		ssize_t  cnt = ::read(self,&one,sizeof(one)) ;
-		SWEAR( cnt==sizeof(one) , cnt,self ) ;
-	}
-} ;
+#if HAS_EVENTFD
+	struct EventFd : AcFd {
+		EventFd(NewType) : AcFd{::eventfd(0,O_CLOEXEC),true/*no_std*/} {}
+		EventFd(Fd fd_ ) : AcFd{fd_                                  } {}
+		void wakeup() const {
+			static constexpr uint64_t One = 1 ;
+			ssize_t cnt = ::write(self,&One,sizeof(One)) ;
+			SWEAR( cnt==sizeof(One) , cnt,self ) ;
+		}
+		void flush() const {
+			uint64_t one ;
+			ssize_t  cnt = ::read(self,&one,sizeof(one)) ;
+			SWEAR( cnt==sizeof(one) , cnt,self ) ;
+		}
+	} ;
+#else
+	struct EventFd : AcFd {
+		EventFd(NewType) {
+			Pipe pipe { New } ;
+			AcFd::operator=(pipe.read) ;
+			_write = pipe.write ;
+		}
+		EventFd(Fd fd_) : AcFd{fd_} {}
+		void wakeup() const {
+			static constexpr char Zero = 0 ;
+			ssize_t cnt = ::write(_write,&Zero,1) ;
+			SWEAR( cnt==1 , cnt,self ) ;
+		}
+		void flush() const {
+			char    zero ;
+			ssize_t cnt  = ::read(self,&zero,1) ;
+			SWEAR( cnt==1 , cnt,self ) ;
+		}
+		// data
+	private :
+		AcFd _write ;
+	} ;
+#endif
 
 //
 // Epoll
 //
 
-extern ::uset<int>* _s_epoll_sigs ; // use pointer to avoid troubles when freeing at end of execution, cannot wait for the same signal on several instances
-template<StdEnum E> struct _Epoll {
-	struct Event : ::epoll_event {
+#if HAS_EPOLL
+
+	extern ::uset<int>* _s_epoll_sigs ; // use pointer to avoid troubles when freeing at end of execution, cannot wait for the same signal on several instances
+	template<StdEnum E> struct _Epoll {
+		struct Event : ::epoll_event {
+			// cxtors & casts
+			using ::epoll_event::epoll_event ;
+			Event(                             ) : ::epoll_event{ .events=0                      , .data{.u64=                     uint32_t(Fd())} } {}
+			Event( bool write , Fd fd , E data ) : ::epoll_event{ .events=write?EPOLLOUT:EPOLLIN , .data{.u64=(uint64_t(data)<<32)|uint32_t(fd  )} } {}
+			// access
+			bool operator+(                ) const { return +fd()                                 ; }
+			int sig       (_Epoll const& ep) const { return ep._fd_infos.at(fd()).first           ; }
+			Fd  fd        (                ) const { return uint32_t(::epoll_event::data.u64    ) ; }
+			E   data      (                ) const { return E       (::epoll_event::data.u64>>32) ; }
+		} ;
 		// cxtors & casts
-		using ::epoll_event::epoll_event ;
-		Event(                             ) : ::epoll_event{ .events=0                      , .data{.u64=                     uint32_t(Fd())} } {}
-		Event( bool write , Fd fd , E data ) : ::epoll_event{ .events=write?EPOLLOUT:EPOLLIN , .data{.u64=(uint64_t(data)<<32)|uint32_t(fd  )} } {}
-		// access
-		bool operator+(                ) const { return +fd()                                 ; }
-		int sig       (_Epoll const& ep) const { return ep._fd_infos.at(fd()).first           ; }
-		Fd  fd        (                ) const { return uint32_t(::epoll_event::data.u64    ) ; }
-		E   data      (                ) const { return E       (::epoll_event::data.u64>>32) ; }
-	} ;
-	// cxtors & casts
-	~_Epoll() {
-		for( auto [fd,sig_pid] : _fd_infos ) _s_epoll_sigs->erase(sig_pid.first) ;
-	}
-	// services
-	void init() {
-		_fd = AcFd( ::epoll_create1(EPOLL_CLOEXEC) , true/*no_std*/ ) ;
-	}
-	void add( bool write , Fd fd , E data ) {
-		Event event { write , fd , data } ;
-		if (::epoll_ctl( _fd , EPOLL_CTL_ADD , fd , &event )<0) fail_prod("cannot add",fd,"to epoll",_fd,'(',::strerror(errno),')') ;
-	}
-	void del( bool /*write*/ , Fd fd ) {
-		if (::epoll_ctl( _fd , EPOLL_CTL_DEL , fd , nullptr )<0) fail_prod("cannot del",fd,"from epoll",_fd,'(',::strerror(errno),')') ;
-	}
-	void add_sig( int sig , E data , pid_t pid=0 ) {
-		SWEAR(is_blocked_sig(sig)) ;
-		::sigset_t sig_set  ;                                                          sigemptyset(&sig_set) ; sigaddset(&sig_set,sig) ; // sigemptyset and sigaddset can be macros
-		Fd         fd       = ::signalfd( -1 , &sig_set , SFD_CLOEXEC|SFD_NONBLOCK ) ;
-		bool       inserted = _sig_infos   . try_emplace(sig,fd     ).second          ; SWEAR(inserted,fd,sig    ) ;
-		/**/       inserted = _fd_infos    . try_emplace(fd ,sig,pid).second          ; SWEAR(inserted,fd,sig,pid) ;
-		/**/       inserted = _s_epoll_sigs->insert     (sig        ).second          ; SWEAR(inserted,fd,sig    ) ;
-		add( false/*write*/ , fd , data ) ;
-		_n_sigs++ ;
-	}
-	void del_sig(int sig) {
-		auto it = _sig_infos.find(sig) ; SWEAR(it!=_sig_infos.end(),sig) ;
-		SWEAR(_n_sigs) ; _n_sigs-- ;
-		del( false/*write*/ , it->second ) ;
-		_fd_infos    . erase(it->second) ;                          // must be done before next line as it is not valid after erasing it
-		_sig_infos   . erase(it        ) ;
-		_s_epoll_sigs->erase(sig       ) ;
-	}
-	void add_pid( pid_t pid , E data ) { add_sig(SIGCHLD,data,pid) ; }
-	void del_pid (pid_t              ) { del_sig(SIGCHLD         ) ; }
-	::vector<Event> wait( Time::Delay timeout , uint cnt ) const {
-		struct ::timespec now ;
-		struct ::timespec end ;
-		bool has_timeout = timeout>Time::Delay() && timeout!=Time::Delay::Forever ;
-		if (has_timeout) {
-			::clock_gettime(CLOCK_MONOTONIC,&now) ;
-			end.tv_sec  = now.tv_sec  + timeout.sec()       ;
-			end.tv_nsec = now.tv_nsec + timeout.nsec_in_s() ;
-			if (end.tv_nsec>=1'000'000'000l) {
-				end.tv_nsec -= 1'000'000'000l ;
-				end.tv_sec  += 1              ;
-			}
+		~_Epoll() {
+			for( auto [fd,sig_pid] : _fd_infos ) _s_epoll_sigs->erase(sig_pid.first) ;
+		}
+		// services
+		void init() {
+			_fd = AcFd( ::epoll_create1(EPOLL_CLOEXEC) , true/*no_std*/ ) ;
+		}
+		void add( bool write , Fd fd , E data ) {
+			Event event { write , fd , data } ;
+			if (::epoll_ctl( _fd , EPOLL_CTL_ADD , fd , &event )<0) fail_prod("cannot add",fd,"to epoll",_fd,'(',::strerror(errno),')') ;
 		}
-		for(;;) {                                                   // manage case where timeout is longer than the maximum allowed timeout by looping over partial timeouts
-			::vector<Event> events        ( cnt ) ;
-			int             cnt_          ;
-			int             wait_ms       = -1    ;
-			bool            wait_overflow = false ;
+		void del( bool /*write*/ , Fd fd ) {
+			if (::epoll_ctl( _fd , EPOLL_CTL_DEL , fd , nullptr )<0) fail_prod("cannot del",fd,"from epoll",_fd,'(',::strerror(errno),')') ;
+		}
+		void add_sig( int sig , E data , pid_t pid=0 ) {
+			SWEAR(is_blocked_sig(sig)) ;
+			::sigset_t sig_set  ;                                                          sigemptyset(&sig_set) ; sigaddset(&sig_set,sig) ; // sigemptyset and sigaddset can be macros
+			Fd         fd       = ::signalfd( -1 , &sig_set , SFD_CLOEXEC|SFD_NONBLOCK ) ;
+			bool       inserted = _sig_infos   . try_emplace(sig,fd     ).second          ; SWEAR(inserted,fd,sig    ) ;
+			/**/       inserted = _fd_infos    . try_emplace(fd ,sig,pid).second          ; SWEAR(inserted,fd,sig,pid) ;
+			/**/       inserted = _s_epoll_sigs->insert     (sig        ).second          ; SWEAR(inserted,fd,sig    ) ;
+			add( false/*write*/ , fd , data ) ;
+			_n_sigs++ ;
+		}
+		void del_sig(int sig) {
+			auto it = _sig_infos.find(sig) ; SWEAR(it!=_sig_infos.end(),sig) ;
+			SWEAR(_n_sigs) ; _n_sigs-- ;
+			del( false/*write*/ , it->second ) ;
+			_fd_infos    . erase(it->second) ;                          // must be done before next line as it is not valid after erasing it
+			_sig_infos   . erase(it        ) ;
+			_s_epoll_sigs->erase(sig       ) ;
+		}
+		void add_pid( pid_t pid , E data ) { add_sig(SIGCHLD,data,pid) ; }
+		void del_pid (pid_t              ) { del_sig(SIGCHLD         ) ; }
+		::vector<Event> wait( Time::Delay timeout , uint cnt ) const {
+			struct ::timespec now ;
+			struct ::timespec end ;
+			bool has_timeout = timeout>Time::Delay() && timeout!=Time::Delay::Forever ;
 			if (has_timeout) {
-				time_t wait_s   = end.tv_sec - now.tv_sec               ;
-				time_t wait_max = ::numeric_limits<int>::max()/1000 - 1 ;
-				if ((wait_overflow=(wait_s>wait_max))) wait_s = wait_max ;
-				wait_ms  = wait_s                    * 1'000      ;
-				wait_ms += (end.tv_nsec-now.tv_nsec) / 1'000'000l ; // protect against possible conversion to time_t which may be unsigned
-			} else {
-				wait_ms = +timeout ? -1 : 0 ;
+				::clock_gettime(CLOCK_MONOTONIC,&now) ;
+				end.tv_sec  = now.tv_sec  + timeout.sec()       ;
+				end.tv_nsec = now.tv_nsec + timeout.nsec_in_s() ;
+				if (end.tv_nsec>=1'000'000'000l) {
+					end.tv_nsec -= 1'000'000'000l ;
+					end.tv_sec  += 1              ;
+				}
 			}
-			cnt_ = ::epoll_wait( _fd , events.data() , int(cnt) , wait_ms ) ;
-			switch (cnt_) {
-				case  0 :                                                                                                   // timeout
-					if (wait_overflow) ::clock_gettime(CLOCK_MONOTONIC,&now) ;
-					else               return {} ;
-				break ;
-				case -1 :
-					SWEAR( errno==EINTR , errno ) ;
-				break ;
-				default :
-					events.resize(cnt_) ;
-					if (_n_sigs) {                                                                                          // fast path : avoid looping over events if not necessary
-						bool shorten = false ;
-						for( Event& e : events ) {
-							Fd                        fd        = e.fd()             ; SWEAR(+fd) ;                         // it is non-sense to have an event for non-existent fd
-							auto                      it        = _fd_infos.find(fd) ; if (it==_fd_infos.end() ) continue ;
-							auto                      [sig,pid] = it->second         ;
-							bool                      found     = !pid               ;                                      // if not waiting for a particular pid, event is always ok
-							struct ::signalfd_siginfo si        ;
-							ssize_t                   n         ;                                                           // we are supposed to read at least once, so init with error case
-							while ( (n=::read(fd,&si,sizeof(si)))==sizeof(si) ) {                                           // flush signal fd, including possibly left-over old sigs
-								SWEAR(int(si.ssi_signo)==sig,si.ssi_signo,sig) ;
-								found |= pid_t(si.ssi_pid)==pid ;
+			for(;;) {                                                   // manage case where timeout is longer than the maximum allowed timeout by looping over partial timeouts
+				::vector<Event> events        ( cnt ) ;
+				int             cnt_          ;
+				int             wait_ms       = -1    ;
+				bool            wait_overflow = false ;
+				if (has_timeout) {
+					time_t wait_s   = end.tv_sec - now.tv_sec               ;
+					time_t wait_max = ::numeric_limits<int>::max()/1000 - 1 ;
+					if ((wait_overflow=(wait_s>wait_max))) wait_s = wait_max ;
+					wait_ms  = wait_s                    * 1'000      ;
+					wait_ms += (end.tv_nsec-now.tv_nsec) / 1'000'000l ; // protect against possible conversion to time_t which may be unsigned
+				} else {
+					wait_ms = +timeout ? -1 : 0 ;
+				}
+				cnt_ = ::epoll_wait( _fd , events.data() , int(cnt) , wait_ms ) ;
+				switch (cnt_) {
+					case  0 :                                                                                                   // timeout
+						if (wait_overflow) ::clock_gettime(CLOCK_MONOTONIC,&now) ;
+						else               return {} ;
+					break ;
+					case -1 :
+						SWEAR( errno==EINTR , errno ) ;
+					break ;
+					default :
+						events.resize(cnt_) ;
+						if (_n_sigs) {                                                                                          // fast path : avoid looping over events if not necessary
+							bool shorten = false ;
+							for( Event& e : events ) {
+								Fd                        fd        = e.fd()             ; SWEAR(+fd) ;                         // it is non-sense to have an event for non-existent fd
+								auto                      it        = _fd_infos.find(fd) ; if (it==_fd_infos.end() ) continue ;
+								auto                      [sig,pid] = it->second         ;
+								bool                      found     = !pid               ;                                      // if not waiting for a particular pid, event is always ok
+								struct ::signalfd_siginfo si        ;
+								ssize_t                   n         ;                                                           // we are supposed to read at least once, so init with error case
+								while ( (n=::read(fd,&si,sizeof(si)))==sizeof(si) ) {                                           // flush signal fd, including possibly left-over old sigs
+									SWEAR(int(si.ssi_signo)==sig,si.ssi_signo,sig) ;
+									found |= pid_t(si.ssi_pid)==pid ;
+								}
+								SWEAR( n<0 && (errno==EAGAIN||errno==EWOULDBLOCK) , n,fd,errno ) ;                              // fd is non-blocking
+								if (!found) { e = {} ; shorten = true ; }                                                       // event is supposed to represent that pid is terminated
 							}
-							SWEAR( n<0 && (errno==EAGAIN||errno==EWOULDBLOCK) , n,fd,errno ) ;                              // fd is non-blocking
-							if (!found) { e = {} ; shorten = true ; }                                                       // event is supposed to represent that pid is terminated
-						}
-						if (shorten) {
-							size_t j = 0 ;
-							for( size_t i : iota(events.size()) ) {
-								if (!events[i]) continue ;
-								if (j<i) events[j] = events[i] ;
-								j++ ;
+							if (shorten) {
+								size_t j = 0 ;
+								for( size_t i : iota(events.size()) ) {
+									if (!events[i]) continue ;
+									if (j<i) events[j] = events[i] ;
+									j++ ;
+								}
+								events.resize(j) ;
 							}
-							events.resize(j) ;
 						}
-					}
-					return events ;
+						return events ;
+				}
 			}
 		}
-	}
-	// data
-private :
-	AcFd                                        _fd        ;
-	::umap<int/*sig*/,Fd                      > _sig_infos ;
-	::umap<Fd        ,::pair<int/*sig*/,pid_t>> _fd_infos  ;
-	uint                                        _n_sigs    = 0 ;
-} ;
+		// data
+	private :
+		AcFd                                        _fd        ;
+		::umap<int/*sig*/,Fd                      > _sig_infos ;
+		::umap<Fd        ,::pair<int/*sig*/,pid_t>> _fd_infos  ;
+		uint                                        _n_sigs    = 0 ;
+	} ;
+
+#elif HAS_KQUEUE
+
+	template<StdEnum E=NewType/*when unused*/> struct _Epoll {
+		struct Event : ::kevent {
+			using Base = struct ::kevent ;
+			// cxtors & casts
+			Event(                                            ) = default ;
+			Event( bool write , Fd  fd  , uint16_t f , E d={} ) : Base{.ident=uintptr_t(fd ),.filter=int16_t(write?EVFILT_WRITE:EVFILT_READ),.flags=f,.udata=reinterpret_cast<void*>(uint32_t(d))} {}
+			Event( int sig              , uint16_t f , E d={} ) : Base{.ident=uintptr_t(sig),.filter=        EVFILT_SIGNAL                  ,.flags=f,.udata=reinterpret_cast<void*>(uint32_t(d))} {}
+			// access
+			int sig (_Epoll const&) const { SWEAR(filter==EVFILT_SIGNAL) ; return ident                                 ; }
+			Fd  fd  (             ) const { SWEAR(filter!=EVFILT_SIGNAL) ; return ident                                 ; }
+			E   data(             ) const {                                return E(reinterpret_cast<uintptr_t>(udata)) ; }
+		} ;
+		// services
+		void init() {
+			_fd = AcFd(::kqueue()) ;
+		}
+		#define N  nullptr
+		#define ES ::strerror(errno)
+		void add( bool write , Fd fd , E data ) { if (::kevent( _fd , &::ref(Event(write,fd,EV_ADD   ,data)),1 , N,0 , N )<0) fail_prod("cannot add"       ,fd ,"to kqueue"  ,_fd,'(',ES,')') ; }
+		void del( bool write , Fd fd          ) { if (::kevent( _fd , &::ref(Event(write,fd,EV_DELETE     )),1 , N,0 , N )<0) fail_prod("cannot del"       ,fd ,"from kqueue",_fd,'(',ES,')') ; }
+		void add_sig( int sig        , E data ) { if (::kevent( _fd , &::ref(Event(sig     ,EV_ADD   ,data)),1 , N,0 , N )<0) fail_prod("cannot add signal",sig,"to kqueue"  ,_fd,'(',ES,')') ; }
+		void del_sig( int sig                 ) { if (::kevent( _fd , &::ref(Event(sig     ,EV_DELETE     )),1 , N,0 , N )<0) fail_prod("cannot del signal",sig,"from kqueue",_fd,'(',ES,')') ; }
+		#undef ES
+		#undef N
+		void add_pid( pid_t , E data ) { add_sig(SIGCHLD,data) ; }
+		void del_pid( pid_t          ) { del_sig(SIGCHLD     ) ; }
+		//
+		::vector<Event> wait( Time::Delay timeout , uint cnt ) const {
+			::vector<Event>   res ( cnt     ) ;
+			struct ::timespec ts  ( timeout ) ;
+			int rc ;
+			if (timeout<Time::Delay::Forever) rc = ::kevent( _fd , nullptr,0 , res.data(),int(cnt) , &ts     ) ;
+			else                              rc = ::kevent( _fd , nullptr,0 , res.data(),int(cnt) , nullptr ) ;
+			SWEAR(rc>=0) ;
+			res.resize(rc) ;
+			return res ;
+		}
+		// data
+	private :
+		AcFd _fd ;
+	} ;
+
+#endif
 
 template<StdEnum E=NewType/*when_unused*/> struct Epoll : _Epoll<E> {
 	using Base  = _Epoll<E>            ;
diff --git a/src/lmakeserver/main.cc b/src/lmakeserver/main.cc
index 45e97ee..c941607 100644
--- a/src/lmakeserver/main.cc
+++ b/src/lmakeserver/main.cc
@@ -3,8 +3,6 @@
 // This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
 // This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-#include <sys/inotify.h>
-
 #include "core.hh" // must be first to include Python.h first
 
 #include "rpc_client.hh"
@@ -12,6 +10,10 @@
 #include "cmd.hh"
 #include "makefiles.hh"
 
+#if HAS_INOTIFY
+	#include <sys/inotify.h>
+#endif
+
 using namespace Disk   ;
 using namespace Engine ;
 using namespace Time   ;
@@ -31,7 +33,9 @@ static ::atomic<bool> _g_done           = false  ;
 static bool           _g_server_running = false  ;
 static ::string       _g_host           = host() ;
 static bool           _g_seen_make      = false  ;
-static Fd             _g_watch_fd       ;          // watch LMAKE/server
+#if HAS_INOTIFY
+	static Fd _g_watch_fd ; // watch LMAKE/server
+#endif
 
 static ::pair_s<int> _get_mrkr_host_pid() {
 	try {
@@ -68,14 +72,14 @@ static bool/*crashed*/ _start_server() {
 	::pair_s<pid_t> mrkr = _get_mrkr_host_pid() ;
 	if ( +mrkr.first && mrkr.first!=_g_host ) {
 		trace("already_existing_elsewhere",mrkr) ;
-		return false/*unused*/ ;                   // if server is running on another host, we cannot qualify with a kill(pid,0), be pessimistic
+		return false/*unused*/ ;                       // if server is running on another host, we cannot qualify with a kill(pid,0), be pessimistic
 	}
 	if (mrkr.second) {
-		if (kill_process(mrkr.second,0)) {         // another server exists
+		if (kill_process(mrkr.second,0)) {             // another server exists
 			trace("already_existing",mrkr) ;
 			return false/*unused*/ ;
 		}
-		unlnk(ServerMrkr) ;                        // before doing anything, we create the marker, which is unlinked at the end, so it is a marker of a crash
+		unlnk(ServerMrkr) ;                            // before doing anything, we create the marker, which is unlinked at the end, so it is a marker of a crash
 		crashed = true ;
 		trace("vanished",mrkr) ;
 	}
@@ -91,12 +95,14 @@ static bool/*crashed*/ _start_server() {
 		//vvvvvvvvvvvvvvvvvvvvvv
 		::atexit(_server_cleanup) ;
 		//^^^^^^^^^^^^^^^^^^^^^^
-		_g_server_running = true ;                 // while we link, pretend we run so cleanup can be done if necessary
+		_g_server_running = true ;                     // while we link, pretend we run so cleanup can be done if necessary
 		fence() ;
 		//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
 		_g_server_running = ::link( tmp.c_str() , ServerMrkr )==0 ;
 		//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-		_g_watch_fd = ::inotify_init1(O_CLOEXEC) ; // start watching file as soon as possible (ideally would be before)
+		#if HAS_INOTIFY
+			_g_watch_fd = ::inotify_init1(O_CLOEXEC) ; // start watching file as soon as possible (ideally would be before)
+		#endif
 		unlnk(tmp) ;
 		trace("started",STR(crashed),STR(_g_is_daemon),STR(_g_server_running)) ;
 	}
@@ -104,6 +110,9 @@ static bool/*crashed*/ _start_server() {
 }
 
 static void _chk_os() {
+	#if !IS_LINUX
+		return ;  // XXXM : dont know how to check os release
+	#endif
 	static constexpr const char* ReleaseFile = "/etc/os-release" ;
 	::vector_s lines      = AcFd(ReleaseFile).read_lines(true/*no_file_ok*/) ;
 	::string   id         ;
@@ -115,11 +124,11 @@ static void _chk_os() {
 	}
 	if ( id        .starts_with('"') && id        .ends_with('"') ) id         = id        .substr(1,id        .size()-2) ;
 	if ( version_id.starts_with('"') && version_id.ends_with('"') ) version_id = version_id.substr(1,version_id.size()-2) ;
+	//
 	if (!id                      ) exit(Rc::System,"cannot find ID in"        ,ReleaseFile) ;
+	if (id!=OS_ID                ) exit(Rc::System,"bad ID in"                ,ReleaseFile,':',id        ,"!=",OS_ID        ) ;
 	if (!version_id              ) exit(Rc::System,"cannot find VERSION_ID in",ReleaseFile) ;
-	//
-	id << '-'<<version_id ;
-	if (id!=OS_ID) exit(Rc::System,"bad OS in",ReleaseFile,':',id,"!=",OS_ID) ;
+	if (version_id!=OS_VERSION_ID) exit(Rc::System,"bad VERSION_ID in"        ,ReleaseFile,':',version_id,"!=",OS_VERSION_ID) ;
 }
 
 static void _record_targets(Job job) {
@@ -146,10 +155,12 @@ static void _reqs_thread_func( ::stop_token stop , Fd in_fd , Fd out_fd ) {
 	if (g_writable) { epoll.add_read( _g_server_fd , EventKind::Master ) ; trace("read_master",_g_server_fd) ; } // if read-only, we do not expect additional connections
 	/**/            { epoll.add_sig ( SIGHUP       , EventKind::Int    ) ; trace("read_hup"                ) ; }
 	/**/            { epoll.add_sig ( SIGINT       , EventKind::Int    ) ; trace("read_int"                ) ; }
-	if ( +_g_watch_fd && ::inotify_add_watch( _g_watch_fd , ServerMrkr , IN_DELETE_SELF | IN_MOVE_SELF | IN_MODIFY )>=0 ) {
-		trace("read_watch",_g_watch_fd) ;
-		epoll.add_read( _g_watch_fd , EventKind::Watch ) ; // if server marker is touched by user, we do as we received a ^C
-	}
+	#if HAS_INOTIFY
+		if ( +_g_watch_fd && ::inotify_add_watch( _g_watch_fd , ServerMrkr , IN_DELETE_SELF | IN_MOVE_SELF | IN_MODIFY )>=0 ) {
+			trace("read_watch",_g_watch_fd) ;
+			epoll.add_read( _g_watch_fd , EventKind::Watch ) ; // if server marker is touched by user, we do as we received a ^C
+		}
+	#endif
 	//
 	if (!_g_is_daemon) {
 		in_tab[in_fd] ;
@@ -185,11 +196,13 @@ static void _reqs_thread_func( ::stop_token stop , Fd in_fd , Fd out_fd ) {
 						case EventKind::Int :
 							EventFd(fd).flush() ;
 						break ;
-						case EventKind::Watch : {
-							struct inotify_event event ;
-							ssize_t              cnt   = ::read( _g_watch_fd , &event , sizeof(event) ) ;
-							SWEAR(cnt==sizeof(event),cnt) ;
-						} break ;
+						#if HAS_INOTIFY
+							case EventKind::Watch : {
+								struct inotify_event event ;
+								ssize_t              cnt   = ::read( _g_watch_fd , &event , sizeof(event) ) ;
+								SWEAR(cnt==sizeof(event),cnt) ;
+							} break ;
+						#endif
 					DF}
 					for( Req r : Req::s_reqs_by_start ) {
 						trace("all_zombie",r) ;
@@ -226,7 +239,7 @@ static void _reqs_thread_func( ::stop_token stop , Fd in_fd , Fd out_fd ) {
 							//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 							trace("make",r) ;
 						} break ;
-						case ReqProc::Debug  :             // PER_CMD : handle request coming from receiving thread, just add your Proc here if the request is answered immediately
+						case ReqProc::Debug  :                 // PER_CMD : handle request coming from receiving thread, just add your Proc here if the request is answered immediately
 						case ReqProc::Forget :
 						case ReqProc::Mark   :
 							SWEAR(g_writable) ;
diff --git a/src/lmakeserver/makefiles.cc b/src/lmakeserver/makefiles.cc
index d3e77fb..0a7041f 100644
--- a/src/lmakeserver/makefiles.cc
+++ b/src/lmakeserver/makefiles.cc
@@ -10,6 +10,10 @@
 #include "autodep/gather.hh"
 #include "makefiles.hh"
 
+#if IS_DARWIN
+	#include <crt_externs.h>
+#endif
+
 using namespace Disk ;
 using namespace Re   ;
 using namespace Time ;
@@ -227,9 +231,14 @@ namespace Engine::Makefiles {
 			{	::string content ;
 				First    first   ;
 				size_t   w       = 0 ;
-				for( char** e=environ ; *e ; e++ ) if ( const char* eq = ::strchr(*e,'=') ) w = ::max(w,size_t(eq-*e)) ;
+				#if IS_DARWIN
+					 char** env = *_NSGetEnviron() ;
+				#else
+					 char** env = environ ;
+				#endif
+				for( char** e=env ; *e ; e++ ) if ( const char* eq = ::strchr(*e,'=') ) w = ::max(w,size_t(eq-*e)) ;
 				content << '{' ;
-				for( char** e=environ ; *e ; e++ )
+				for( char** e=env ; *e ; e++ )
 					if ( const char* eq = ::strchr(*e,'=') )
 						content << first("",",")<<'\t'<< widen(mk_py_str(::string_view(*e,eq-*e)),w) <<" : "<< mk_py_str(::string(eq+1)) << '\n' ;
 				content << "}\n" ;
diff --git a/src/lmakeserver/rule.x.hh b/src/lmakeserver/rule.x.hh
index ee94684..d88e8d9 100644
--- a/src/lmakeserver/rule.x.hh
+++ b/src/lmakeserver/rule.x.hh
@@ -204,15 +204,17 @@ namespace Engine {
 		void init  ( bool /*is_dynamic*/ , Py::Dict const* py_src , ::umap_s<CmdIdx> const& ) { update(*py_src) ; }
 		void update(                       Py::Dict const& py_dct                           ) {
 			using namespace Attrs ;
-			Attrs::acquire_from_dct( allow_stderr           , py_dct , "allow_stderr" ) ;
-			Attrs::acquire_from_dct( auto_mkdir             , py_dct , "auto_mkdir"   ) ;
-			Attrs::acquire_from_dct( job_space.chroot_dir_s , py_dct , "chroot_dir"   ) ; if (+job_space.chroot_dir_s) job_space.chroot_dir_s = with_slash(job_space.chroot_dir_s) ;
-			Attrs::acquire_env     ( env                    , py_dct , "env"          ) ;
-			Attrs::acquire_from_dct( ignore_stat            , py_dct , "ignore_stat"  ) ;
-			Attrs::acquire_from_dct( interpreter            , py_dct , "interpreter"  ) ;
-			Attrs::acquire_from_dct( job_space.repo_view_s  , py_dct , "repo_view"    ) ; if (+job_space.repo_view_s ) job_space.repo_view_s  = with_slash(job_space.repo_view_s ) ;
-			Attrs::acquire_from_dct( job_space.tmp_view_s   , py_dct , "tmp_view"     ) ; if (+job_space.tmp_view_s  ) job_space.tmp_view_s   = with_slash(job_space.tmp_view_s  ) ;
-			Attrs::acquire_from_dct( job_space.views        , py_dct , "views"        ) ;
+			Attrs::acquire_from_dct( interpreter  , py_dct , "interpreter"  ) ;
+			Attrs::acquire_from_dct( allow_stderr , py_dct , "allow_stderr" ) ;
+			Attrs::acquire_from_dct( auto_mkdir   , py_dct , "auto_mkdir"   ) ;
+			Attrs::acquire_env     ( env          , py_dct , "env"          ) ;
+			Attrs::acquire_from_dct( ignore_stat  , py_dct , "ignore_stat"  ) ;
+			#if HAS_NAMESPACES
+				Attrs::acquire_from_dct( job_space.chroot_dir_s , py_dct , "chroot_dir" ) ; if (+job_space.chroot_dir_s) job_space.chroot_dir_s = with_slash(job_space.chroot_dir_s) ;
+				Attrs::acquire_from_dct( job_space.repo_view_s  , py_dct , "repo_view"  ) ; if (+job_space.repo_view_s ) job_space.repo_view_s  = with_slash(job_space.repo_view_s ) ;
+				Attrs::acquire_from_dct( job_space.tmp_view_s   , py_dct , "tmp_view"   ) ; if (+job_space.tmp_view_s  ) job_space.tmp_view_s   = with_slash(job_space.tmp_view_s  ) ;
+				Attrs::acquire_from_dct( job_space.views        , py_dct , "views"      ) ;
+			#endif
 			::sort( env                                                                                                                                   ) ; // stabilize cmd crc
 			::sort( job_space.views , [](::pair_s<JobSpace::ViewDescr> const& a,::pair_s<JobSpace::ViewDescr> const&b)->bool { return a.first<b.first ; } ) ; // .
 		}
diff --git a/src/non_portable.cc b/src/non_portable.cc
index 504f938..855dee7 100644
--- a/src/non_portable.cc
+++ b/src/non_portable.cc
@@ -3,19 +3,23 @@
 // This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
 // This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-#include <elf.h>        // NT_PRSTATUS definition on ARM
-#include <sys/ptrace.h>
-
 #include "utils.hh"
 
 #include "non_portable.hh"
 
+#if HAS_PTRACE
+	#include <elf.h>        // NT_PRSTATUS definition on ARM
+	#include <sys/ptrace.h>
+#endif
+
 #if __x86_64__ + __i386__ + __aarch64__ + __arm__ != 1
 	#error "unknown architecture"                      // if situation arises, please provide the adequate code using other cases as a template
 #endif
 
 using namespace std ;
 
+#if HAS_PTRACE
+
 	using UserRegsStruct = struct ::user_regs_struct ;
 	using Iovec          = struct ::iovec            ;
 	#if __x86_64__
@@ -44,81 +48,83 @@ using namespace std ;
 
 	// info from : https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls
 
-::array<uint64_t,6> np_ptrace_get_args( pid_t pid , uint8_t word_sz ) {                 // info come from man 2 syscall
-	SWEAR(word_sz==NpWordSz,word_sz) ;                                                  // XXXM : implement 32 bits tracee from 64 bits tracer
-	UserRegsStruct      regs = _get(pid,6/*n_words*/) ;
-	::array<uint64_t,6> res  ;
-	#if __x86_64__
-		res[0] = regs.rdi ;                                                             // full struct is retrieved with x86
-		res[1] = regs.rsi ;
-		res[2] = regs.rdx ;
-		res[3] = regs.r10 ;
-		res[4] = regs.r8  ;
-		res[5] = regs.r9  ;
-	#elif __i386__
-		res[0] = regs.ebx ;                                                             // full struct is retrieved with x86
-		res[1] = regs.ecx ;
-		res[2] = regs.edx ;
-		res[3] = regs.esi ;
-		res[4] = regs.edi ;
-		res[5] = regs.ebp ;
-	#elif __aarch64__
-		res[0] = regs.regs[0] ; static_assert(offsetof(UserRegsStruct,regs)==0) ;       // else adjust n_words
-		res[1] = regs.regs[1] ;
-		res[2] = regs.regs[2] ;
-		res[3] = regs.regs[3] ;
-		res[4] = regs.regs[4] ;
-		res[5] = regs.regs[5] ;
-	#elif __arm__
-		res[0] = regs.r0 ; static_assert(offsetof(UserRegsStruct,r0)<=5*sizeof(Word)) ; // else adjust n_words
-		res[1] = regs.r1 ; static_assert(offsetof(UserRegsStruct,r1)<=5*sizeof(Word)) ; // .
-		res[2] = regs.r2 ; static_assert(offsetof(UserRegsStruct,r2)<=5*sizeof(Word)) ; // .
-		res[3] = regs.r3 ; static_assert(offsetof(UserRegsStruct,r3)<=5*sizeof(Word)) ; // .
-		res[4] = regs.r4 ; static_assert(offsetof(UserRegsStruct,r4)<=5*sizeof(Word)) ; // .
-		res[5] = regs.r5 ; static_assert(offsetof(UserRegsStruct,r5)<=5*sizeof(Word)) ; // .
-	#endif
-	return res ;
-}
+	::array<uint64_t,6> np_ptrace_get_args( pid_t pid , uint8_t word_sz ) {                 // info come from man 2 syscall
+		SWEAR(word_sz==NpWordSz,word_sz) ;                                                  // XXXM : implement 32 bits tracee from 64 bits tracer
+		UserRegsStruct      regs = _get(pid,6/*n_words*/) ;
+		::array<uint64_t,6> res  ;
+		#if __x86_64__
+			res[0] = regs.rdi ;                                                             // full struct is retrieved with x86
+			res[1] = regs.rsi ;
+			res[2] = regs.rdx ;
+			res[3] = regs.r10 ;
+			res[4] = regs.r8  ;
+			res[5] = regs.r9  ;
+		#elif __i386__
+			res[0] = regs.ebx ;                                                             // full struct is retrieved with x86
+			res[1] = regs.ecx ;
+			res[2] = regs.edx ;
+			res[3] = regs.esi ;
+			res[4] = regs.edi ;
+			res[5] = regs.ebp ;
+		#elif __aarch64__
+			res[0] = regs.regs[0] ; static_assert(offsetof(UserRegsStruct,regs)==0) ;       // else adjust n_words
+			res[1] = regs.regs[1] ;
+			res[2] = regs.regs[2] ;
+			res[3] = regs.regs[3] ;
+			res[4] = regs.regs[4] ;
+			res[5] = regs.regs[5] ;
+		#elif __arm__
+			res[0] = regs.r0 ; static_assert(offsetof(UserRegsStruct,r0)<=5*sizeof(Word)) ; // else adjust n_words
+			res[1] = regs.r1 ; static_assert(offsetof(UserRegsStruct,r1)<=5*sizeof(Word)) ; // .
+			res[2] = regs.r2 ; static_assert(offsetof(UserRegsStruct,r2)<=5*sizeof(Word)) ; // .
+			res[3] = regs.r3 ; static_assert(offsetof(UserRegsStruct,r3)<=5*sizeof(Word)) ; // .
+			res[4] = regs.r4 ; static_assert(offsetof(UserRegsStruct,r4)<=5*sizeof(Word)) ; // .
+			res[5] = regs.r5 ; static_assert(offsetof(UserRegsStruct,r5)<=5*sizeof(Word)) ; // .
+		#endif
+		return res ;
+	}
 
-int64_t np_ptrace_get_res( pid_t pid , uint8_t word_sz ) {
-	SWEAR(word_sz==NpWordSz,word_sz) ;                                             // XXXM : implement 32 bits tracee from 64 bits tracer
-	UserRegsStruct regs = _get(pid,1/*n_words*/) ;
-	#if __x86_64__
-		return regs.rax     ;                                                      // full struct is retrieved with x86
-	#elif __i386__
-		return regs.eax     ;                                                      // .
-	#elif __aarch64__
-		return regs.regs[0] ; static_assert(offsetof(UserRegsStruct,regs[0])==0) ; // else adjust n_words
-	#elif __arm__
-		return regs.r0      ; static_assert(offsetof(UserRegsStruct,r0     )==0) ; // .
-	#endif
-}
+	int64_t np_ptrace_get_res( pid_t pid , uint8_t word_sz ) {
+		SWEAR(word_sz==NpWordSz,word_sz) ;                                             // XXXM : implement 32 bits tracee from 64 bits tracer
+		UserRegsStruct regs = _get(pid,1/*n_words*/) ;
+		#if __x86_64__
+			return regs.rax     ;                                                      // full struct is retrieved with x86
+		#elif __i386__
+			return regs.eax     ;                                                      // .
+		#elif __aarch64__
+			return regs.regs[0] ; static_assert(offsetof(UserRegsStruct,regs[0])==0) ; // else adjust n_words
+		#elif __arm__
+			return regs.r0      ; static_assert(offsetof(UserRegsStruct,r0     )==0) ; // .
+		#endif
+	}
 
-long np_ptrace_get_nr( pid_t pid , uint8_t word_sz ) {
-	SWEAR(word_sz==NpWordSz,word_sz) ;                                                           // XXXM : implement 32 bits tracee from 64 bits tracer
-	UserRegsStruct regs = _get(pid,9/*n_words*/) ;
-	#if __x86_64__
-		return regs.orig_rax ;                                                                   // full struct is retrieved with x86
-	#elif __i386__
-		return regs.orig_eax ;                                                                   // .
-	#elif __aarch64__
-		return regs.regs[8]  ; static_assert(offsetof(UserRegsStruct,regs[8])<=8*sizeof(Word)) ; // else adjust n_words
-	#elif __arm__
-		return regs.r7       ; static_assert(offsetof(UserRegsStruct,r7     )<=8*sizeof(Word)) ; // .
-	#endif
-}
+	long np_ptrace_get_nr( pid_t pid , uint8_t word_sz ) {
+		SWEAR(word_sz==NpWordSz,word_sz) ;                                                           // XXXM : implement 32 bits tracee from 64 bits tracer
+		UserRegsStruct regs = _get(pid,9/*n_words*/) ;
+		#if __x86_64__
+			return regs.orig_rax ;                                                                   // full struct is retrieved with x86
+		#elif __i386__
+			return regs.orig_eax ;                                                                   // .
+		#elif __aarch64__
+			return regs.regs[8]  ; static_assert(offsetof(UserRegsStruct,regs[8])<=8*sizeof(Word)) ; // else adjust n_words
+		#elif __arm__
+			return regs.r7       ; static_assert(offsetof(UserRegsStruct,r7     )<=8*sizeof(Word)) ; // .
+		#endif
+	}
 
-void np_ptrace_set_res( pid_t pid , int64_t val , uint8_t word_sz ) {
-	SWEAR(word_sz==NpWordSz,word_sz) ;                                            // XXXM : implement 32 bits tracee from 64 bits tracer
-	UserRegsStruct regs = _get(pid,1/*n_words*/)  ;
-	#if __x86_64__
-		regs.rax     = val ;                                                      // full struct is retrieved with x86
-	#elif __i386__
-		regs.eax     = val ;                                                      // .
-	#elif __aarch64__
-		regs.regs[0] = val ; static_assert(offsetof(UserRegsStruct,regs[0])==0) ; // else adjust n_words
-	#elif __arm__
-		regs.r0      = val ; static_assert(offsetof(UserRegsStruct,r0     )==0) ; // .
-	#endif
-	_set(pid,1,regs) ;
-}
+	void np_ptrace_set_res( pid_t pid , int64_t val , uint8_t word_sz ) {
+		SWEAR(word_sz==NpWordSz,word_sz) ;                                            // XXXM : implement 32 bits tracee from 64 bits tracer
+		UserRegsStruct regs = _get(pid,1/*n_words*/)  ;
+		#if __x86_64__
+			regs.rax     = val ;                                                      // full struct is retrieved with x86
+		#elif __i386__
+			regs.eax     = val ;                                                      // .
+		#elif __aarch64__
+			regs.regs[0] = val ; static_assert(offsetof(UserRegsStruct,regs[0])==0) ; // else adjust n_words
+		#elif __arm__
+			regs.r0      = val ; static_assert(offsetof(UserRegsStruct,r0     )==0) ; // .
+		#endif
+		_set(pid,1,regs) ;
+	}
+
+#endif
diff --git a/src/non_portable.hh b/src/non_portable.hh
index 046b0b5..d03611a 100644
--- a/src/non_portable.hh
+++ b/src/non_portable.hh
@@ -21,7 +21,9 @@ static constexpr bool NpStackGrowsDownward = true               ; // XXXM : find
 	static constexpr uint8_t NpWordSz = 32 ;
 #endif
 
-::array<uint64_t,6> np_ptrace_get_args( pid_t pid ,               uint8_t word_sz ) ; // word_sz must be 32 or 64
-int64_t             np_ptrace_get_res ( pid_t pid ,               uint8_t word_sz ) ; // .
-long                np_ptrace_get_nr  ( pid_t pid ,               uint8_t word_sz ) ; // .
-void                np_ptrace_set_res ( pid_t pid , int64_t val , uint8_t word_sz ) ; // .
+#if HAS_PTRACE
+	::array<uint64_t,6> np_ptrace_get_args( pid_t pid ,               uint8_t word_sz ) ; // word_sz must be 32 or 64
+	int64_t             np_ptrace_get_res ( pid_t pid ,               uint8_t word_sz ) ; // .
+	long                np_ptrace_get_nr  ( pid_t pid ,               uint8_t word_sz ) ; // .
+	void                np_ptrace_set_res ( pid_t pid , int64_t val , uint8_t word_sz ) ; // .
+#endif
diff --git a/src/process.cc b/src/process.cc
index d13c757..ed7da65 100644
--- a/src/process.cc
+++ b/src/process.cc
@@ -3,10 +3,16 @@
 // This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
 // This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-#include <sched.h>
-#include <sys/mount.h>
-
 #include "disk.hh"
+
+#if IS_DARWIN
+	#include <crt_externs.h>
+#endif
+#if HAS_NAMESPACES
+	#include <sched.h>
+	#include <sys/mount.h>
+#endif
+
 #include "process.hh"
 
 using namespace Disk ;
@@ -63,47 +69,51 @@ using namespace Disk ;
 		//::close_range(3,~0u,CLOSE_RANGE_UNSHARE) ; // activate this code (uncomment) as an alternative to set CLOEXEC in Fd(::string)
 	#endif
 	//
-	if (first_pid) {
-		SWEAR(first_pid>1,first_pid) ;
-		// mount is not signal-safe and we are only allowed signal-safe functions here, but this is a syscall, should be ok
-		if (::mount(nullptr,"/proc","proc",0,nullptr)!=0) {
-			::perror("cannot mount /proc ") ;
-			_exit(Rc::System,"cannot mount /proc") ;
-		}
-		{	char                     first_pid_buf[30] ;                                                // /!\ cannot use ::string as we are only allowed signal-safe functions
-			int                      first_pid_sz      = sprintf(first_pid_buf,"%d",first_pid-1  )    ; // /!\ .
-			AcFd                     fd                { "/proc/sys/kernel/ns_last_pid" , Fd::Write } ;
-			[[maybe_unused]] ssize_t _                 = ::write(fd,first_pid_buf,first_pid_sz)       ; // dont care about errors, this is best effort
-		}
-		pid_t pid = ::clone( _s_do_child , _child_stack_ptr , SIGCHLD , this ) ;
-		//
-		if (pid==-1) _exit(Rc::System,"cannot spawn sub-process") ;
-		for(;;) {
-			int   wstatus   ;
-			pid_t child_pid = ::wait(&wstatus) ;
-			if (child_pid==pid) {                                                                       // XXXM : find a way to simulate a caught signal rather than exit 128+sig
-				if (WIFEXITED  (wstatus)) ::_exit(    WEXITSTATUS(wstatus)) ;                           // exit as transparently as possible
-				if (WIFSIGNALED(wstatus)) ::_exit(128+WTERMSIG   (wstatus)) ;                           // cannot kill self to be transparent as we are process 1, mimic bash
-				SWEAR( WIFSTOPPED(wstatus) || WIFCONTINUED(wstatus) , wstatus ) ;                       // ensure we have not forgotten a case
+	#if HAS_NAMESPACES
+		if (first_pid) {
+			SWEAR(first_pid>1,first_pid) ;
+			// mount is not signal-safe and we are only allowed signal-safe functions here, but this is a syscall, should be ok
+			if (::mount(nullptr,"/proc","proc",0,nullptr)!=0) {
+				::perror("cannot mount /proc ") ;
+				_exit(Rc::System,"cannot mount /proc") ;
+			}
+			{	char                     first_pid_buf[30] ;                                                // /!\ cannot use ::string as we are only allowed signal-safe functions
+				int                      first_pid_sz      = sprintf(first_pid_buf,"%d",first_pid-1  )    ; // /!\ .
+				AcFd                     fd                { "/proc/sys/kernel/ns_last_pid" , Fd::Write } ;
+				[[maybe_unused]] ssize_t _                 = ::write(fd,first_pid_buf,first_pid_sz)       ; // dont care about errors, this is best effort
 			}
+			pid_t pid = ::clone( _s_do_child , _child_stack_ptr , SIGCHLD , this ) ;
+			//
+			if (pid==-1) _exit(Rc::System,"cannot spawn sub-process") ;
+			for(;;) {
+				int   wstatus   ;
+				pid_t child_pid = ::wait(&wstatus) ;
+				if (child_pid==pid) {                                                                       // XXXM : find a way to simulate a caught signal rather than exit 128+sig
+					if (WIFEXITED  (wstatus)) ::_exit(    WEXITSTATUS(wstatus)) ;                           // exit as transparently as possible
+					if (WIFSIGNALED(wstatus)) ::_exit(128+WTERMSIG   (wstatus)) ;                           // cannot kill self to be transparent as we are process 1, mimic bash
+					SWEAR( WIFSTOPPED(wstatus) || WIFCONTINUED(wstatus) , wstatus ) ;                       // ensure we have not forgotten a case
+				}
+			}
+		} else {
+			_do_child() ;
 		}
-	} else {
+	#else
 		_do_child() ;
-	}
+	#endif
 }
 
 void Child::spawn() {
 	SWEAR( +cmd_line                                                            ) ;
-	SWEAR( !stdin_fd  || stdin_fd ==Fd::Stdin  || stdin_fd >Fd::Std , stdin_fd  ) ;                                          // ensure reasonably simple situations
-	SWEAR( !stdout_fd || stdout_fd>=Fd::Stdout                      , stdout_fd ) ;                                          // .
-	SWEAR( !stderr_fd || stderr_fd>=Fd::Stdout                      , stderr_fd ) ;                                          // .
-	SWEAR( !( stderr_fd==Fd::Stdout && stdout_fd==Fd::Stderr )                  ) ;                                          // .
+	SWEAR( !stdin_fd  || stdin_fd ==Fd::Stdin  || stdin_fd >Fd::Std , stdin_fd  ) ;                                              // ensure reasonably simple situations
+	SWEAR( !stdout_fd || stdout_fd>=Fd::Stdout                      , stdout_fd ) ;                                              // .
+	SWEAR( !stderr_fd || stderr_fd>=Fd::Stdout                      , stderr_fd ) ;                                              // .
+	SWEAR( !( stderr_fd==Fd::Stdout && stdout_fd==Fd::Stderr )                  ) ;                                              // .
 	if (stdin_fd ==PipeFd) _p2c .open() ; else if (+stdin_fd ) _p2c .read  = stdin_fd  ;
 	if (stdout_fd==PipeFd) _c2po.open() ; else if (+stdout_fd) _c2po.write = stdout_fd ;
 	if (stderr_fd==PipeFd) _c2pe.open() ; else if (+stderr_fd) _c2pe.write = stderr_fd ;
 	//
 	// /!\ memory for environment must be allocated before calling clone
-	::vector_s env_vector ;                                                                                                  // ensure actual env strings (of the form name=val) lifetime
+	::vector_s env_vector ;                                                                                                      // ensure actual env strings (of the form name=val) lifetime
 	if (env) {
 		size_t n_env = env->size() + (add_env?add_env->size():0) ;
 		env_vector.reserve(n_env) ;
@@ -113,16 +123,21 @@ void Child::spawn() {
 		if (add_env) for( auto const& [k,v] : *add_env ) { env_vector.push_back(k+'='+v) ; _child_env[i++] = env_vector.back().c_str() ; }
 		/**/                                                                               _child_env[i  ] = nullptr                   ;
 	} else {
+		#if IS_DARWIN
+			char** env = *_NSGetEnviron() ;
+		#else
+			char** env = environ ;
+		#endif
 		if (add_env) {
-			size_t n_env = add_env->size() ; for( char** e=environ ; *e ; e++ ) n_env++ ;
+			size_t n_env = add_env->size() ; for( char** e=env ; *e ; e++ ) n_env++ ;
 			env_vector.reserve(add_env->size()) ;
 			_child_env = new const char*[n_env+1] ;
 			size_t i = 0 ;
-			for( char** e=environ ; *e ; e++  )                                   _child_env[i++] = *e                        ;
+			for( char** e=env ; *e ; e++  )                                       _child_env[i++] = *e                        ;
 			for( auto const& [k,v] : *add_env ) { env_vector.push_back(k+'='+v) ; _child_env[i++] = env_vector.back().c_str() ; }
 			/**/                                                                  _child_env[i  ] = nullptr                   ;
 		} else {
-			_child_env = const_cast<const char**>(environ) ;
+			_child_env = const_cast<const char**>(env) ;
 		}
 	}
 	//
@@ -137,16 +152,21 @@ void Child::spawn() {
 	::vector<uint64_t> child_stack ( StackSz/sizeof(uint64_t) ) ;
 	_child_stack_ptr = child_stack.data()+(NpStackGrowsDownward?child_stack.size():0) ;
 	//
-	if (first_pid) {
-		::vector<uint64_t> trampoline_stack     ( StackSz/sizeof(uint64_t) )                                               ; // we need a trampoline stack if we launch a grand-child
-		void*              trampoline_stack_ptr = trampoline_stack.data()+(NpStackGrowsDownward?trampoline_stack.size():0) ; // .
-		pid = ::clone( _s_do_child_trampoline , trampoline_stack_ptr , SIGCHLD|CLONE_NEWPID|CLONE_NEWNS , this ) ;           // CLONE_NEWNS is passed to mount a new /proc without disturing caller
-	} else {
-		pid = ::clone( _s_do_child_trampoline , _child_stack_ptr     , SIGCHLD                          , this ) ;
-	}
+	#if HAS_NAMESPACES
+		if (first_pid) {
+			::vector<uint64_t> trampoline_stack     ( StackSz/sizeof(uint64_t) )                                               ; // we need a trampoline stack if we launch a grand-child
+			void*              trampoline_stack_ptr = trampoline_stack.data()+(NpStackGrowsDownward?trampoline_stack.size():0) ; // .
+			pid = ::clone( _s_do_child_trampoline , trampoline_stack_ptr , SIGCHLD|CLONE_NEWPID|CLONE_NEWNS , this ) ;           // CLONE_NEWNS is passed to mount a new /proc without disturing caller
+		} else {
+			pid = ::clone( _s_do_child_trampoline , _child_stack_ptr     , SIGCHLD                          , this ) ;
+		}
+	#else
+		SWEAR(!first_pid) ;
+		if (!(pid=::fork())) _do_child_trampoline()/*no_return*/ ;
+	#endif
 	//
 	if (pid==-1) {
-		waited() ;                                                                                                           // ensure we can be destructed
+		waited() ;                                                                                                               // ensure we can be destructed
 		throw cat("cannot spawn process ",cmd_line," : ",::strerror(errno)) ;
 	}
 	//
diff --git a/src/rpc_job.cc b/src/rpc_job.cc
index ea1c80f..5a82c91 100644
--- a/src/rpc_job.cc
+++ b/src/rpc_job.cc
@@ -3,13 +3,15 @@
 // This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
 // This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-#include <sched.h>     // unshare
-#include <sys/mount.h> // mount
-
 #include "disk.hh"
 #include "hash.hh"
 #include "trace.hh"
 
+#if HAS_NAMESPACES
+	#include <sched.h>     // unshare
+	#include <sys/mount.h> // mount
+#endif
+
 #include "rpc_job.hh"
 
 using namespace Disk ;
@@ -136,6 +138,8 @@ using namespace Hash ;
 	return                os <<')'                                   ;
 }
 
+#if HAS_NAMESPACES
+
 	static void _chroot(::string const& dir_s) { Trace trace("_chroot",dir_s) ; if (::chroot(no_slash(dir_s).c_str())!=0) throw "cannot chroot to "+no_slash(dir_s)+" : "+::strerror(errno) ; }
 	static void _chdir (::string const& dir_s) { Trace trace("_chdir" ,dir_s) ; if (::chdir (no_slash(dir_s).c_str())!=0) throw "cannot chdir to " +no_slash(dir_s)+" : "+::strerror(errno) ; }
 
@@ -145,33 +149,35 @@ using namespace Hash ;
 			throw "cannot bind mount "+src+" onto "+dst+" : "+::strerror(errno) ;
 	}
 
-static void _mount_overlay( ::string const& dst_s , ::vector_s const& srcs_s , ::string const& work_s ) {
-	SWEAR(+srcs_s) ;
-	SWEAR(srcs_s.size()>1,dst_s,srcs_s,work_s) ; // use bind mount in that case
-	//
-	Trace trace("_mount_overlay",dst_s,srcs_s,work_s) ;
-	for( size_t i : iota(1,srcs_s.size()) )
-		if (srcs_s[i].find(':')!=Npos)
-			throw cat("cannot overlay mount ",dst_s," to ",srcs_s,"with embedded columns (:)") ;
-	mk_dir_s(work_s) ;
-	//
-	::string                                data  = "userxattr"                      ;
-	/**/                                    data += ",upperdir="+no_slash(srcs_s[0]) ;
-	/**/                                    data += ",lowerdir="+no_slash(srcs_s[1]) ;
-	for( size_t i : iota(2,srcs_s.size()) ) data += ':'         +no_slash(srcs_s[i]) ;
-	/**/                                    data += ",workdir=" +no_slash(work_s   ) ;
-	if (::mount( nullptr ,  no_slash(dst_s).c_str() , "overlay" , 0 , data.c_str() )!=0)
-		throw "cannot overlay mount "+dst_s+" to "+data+" : "+::strerror(errno) ;
-}
+	static void _mount_overlay( ::string const& dst_s , ::vector_s const& srcs_s , ::string const& work_s ) {
+		SWEAR(+srcs_s) ;
+		SWEAR(srcs_s.size()>1,dst_s,srcs_s,work_s) ; // use bind mount in that case
+		//
+		Trace trace("_mount_overlay",dst_s,srcs_s,work_s) ;
+		for( size_t i : iota(1,srcs_s.size()) )
+			if (srcs_s[i].find(':')!=Npos)
+				throw cat("cannot overlay mount ",dst_s," to ",srcs_s,"with embedded columns (:)") ;
+		mk_dir_s(work_s) ;
+		//
+		::string                                data  = "userxattr"                      ;
+		/**/                                    data += ",upperdir="+no_slash(srcs_s[0]) ;
+		/**/                                    data += ",lowerdir="+no_slash(srcs_s[1]) ;
+		for( size_t i : iota(2,srcs_s.size()) ) data += ':'         +no_slash(srcs_s[i]) ;
+		/**/                                    data += ",workdir=" +no_slash(work_s   ) ;
+		if (::mount( nullptr ,  no_slash(dst_s).c_str() , "overlay" , 0 , data.c_str() )!=0)
+			throw "cannot overlay mount "+dst_s+" to "+data+" : "+::strerror(errno) ;
+	}
 
-static void _atomic_write( ::string const& file , ::string const& data ) {
-	Trace trace("_atomic_write",file,data) ;
-	AcFd fd { file , Fd::Write } ;
-	throw_unless( +fd , "cannot open ",file," for writing" ) ;
-	ssize_t cnt = ::write( fd , data.c_str() , data.size() ) ;
-	if (cnt<0                  ) throw "cannot write atomically "s+data.size()+" bytes to "+file+" : "+::strerror(errno)         ;
-	if (size_t(cnt)<data.size()) throw "cannot write atomically "s+data.size()+" bytes to "+file+" : only "+cnt+" bytes written" ;
-}
+	static void _atomic_write( ::string const& file , ::string const& data ) {
+		Trace trace("_atomic_write",file,data) ;
+		AcFd fd { file , Fd::Write } ;
+		throw_unless( +fd , "cannot open ",file," for writing" ) ;
+		ssize_t cnt = ::write( fd , data.c_str() , data.size() ) ;
+		if (cnt<0                  ) throw "cannot write atomically "s+data.size()+" bytes to "+file+" : "+::strerror(errno)         ;
+		if (size_t(cnt)<data.size()) throw "cannot write atomically "s+data.size()+" bytes to "+file+" : only "+cnt+" bytes written" ;
+	}
+
+#endif
 
 bool JobSpace::_is_lcl_tmp(::string const& f) const {
 	if (is_lcl(f)  ) return true                      ;
@@ -210,125 +216,130 @@ bool/*entered*/ JobSpace::enter(
 	//
 	if (!self) return false/*entered*/ ;
 	//
-	int uid = ::getuid() ;                                                          // must be done before unshare that invents a new user
-	int gid = ::getgid() ;                                                          // .
-	//
-	if (::unshare(CLONE_NEWUSER|CLONE_NEWNS)!=0) throw "cannot create namespace : "s+::strerror(errno) ;
-	//
-	size_t   uphill_lvl = 0 ;
-	::string highest_s  ;
-	for( ::string const& d_s : src_dirs_s ) if (!is_abs_s(d_s))
-		if ( size_t ul=uphill_lvl_s(d_s) ; ul>uphill_lvl ) {
-			uphill_lvl = ul  ;
-			highest_s  = d_s ;
-		}
-	//
-	::string phy_super_repo_root_s ;                                                // dir englobing all relative source dirs
-	::string super_repo_view_s     ;                                                // .
-	::string top_repo_view_s       ;
-	if (+repo_view_s) {
-		if (!( repo_view_s.ends_with(cwd_s) && repo_view_s.size()>cwd_s.size()+1 )) // ensure repo_view_s has at least one more level than cwd_s
-			throw
-				"cannot map local repository dir to "+no_slash(repo_view_s)+" appearing as "+no_slash(cwd_s)+" in top-level repository, "
-				"consider setting <rule>.repo_view="+mk_py_str("/repo/"+no_slash(cwd_s))
-			;
-		phy_super_repo_root_s = phy_repo_root_s ; for( [[maybe_unused]] size_t _ : iota(uphill_lvl) ) phy_super_repo_root_s = dir_name_s(phy_super_repo_root_s) ;
-		super_repo_view_s     = repo_view_s     ; for( [[maybe_unused]] size_t _ : iota(uphill_lvl) ) super_repo_view_s     = dir_name_s(super_repo_view_s    ) ;
-		SWEAR(phy_super_repo_root_s!="/",phy_repo_root_s,uphill_lvl) ;              // this should have been checked earlier
-		if (!super_repo_view_s)
-			throw
-				"cannot map repository dir to "+no_slash(repo_view_s)+" with relative source dir "+no_slash(highest_s)
-			+	", "
-			+	"consider setting <rule>.repo_view="+mk_py_str("/repo/"+no_slash(phy_repo_root_s.substr(phy_super_repo_root_s.size())+cwd_s))
-			;
-		if (repo_view_s.substr(super_repo_view_s.size())!=phy_repo_root_s.substr(phy_super_repo_root_s.size()))
-			throw
-				"last "s+uphill_lvl+" components do not match between physical root dir and root view"
-			+	", "
-			+	"consider setting <rule>.repo_view="+mk_py_str("/repo/"+no_slash(phy_repo_root_s.substr(phy_super_repo_root_s.size())+cwd_s))
-			;
-		top_repo_view_s = repo_view_s.substr(0,repo_view_s.size()-cwd_s.size()) ;
-	}
-	if ( +super_repo_view_s && super_repo_view_s.rfind('/',super_repo_view_s.size()-2)!=0 ) throw "non top-level repo_view not yet implemented"s ; // XXXM : handle cases where dir is not top level
-	if ( +tmp_view_s        && tmp_view_s       .rfind('/',tmp_view_s       .size()-2)!=0 ) throw "non top-level tmp_view not yet implemented"s  ; // .
-	//
-	::string chroot_dir       = chroot_dir_s                                                          ; if (+chroot_dir) chroot_dir.pop_back() ; // cannot use no_slash to properly manage the '/' case
-	bool     must_create_root = +super_repo_view_s && !is_dir(chroot_dir+no_slash(super_repo_view_s)) ;
-	bool     must_create_tmp  = +tmp_view_s        && !is_dir(chroot_dir+no_slash(tmp_view_s       )) ;
-	trace("create",STR(must_create_root),STR(must_create_tmp)) ;
-	if ( must_create_root || must_create_tmp || +views )
-		try { unlnk_inside_s(work_dir_s) ; } catch (::string const& e) {} // if we need a work dir, we must clean it first as it is not cleaned upon exit (ignore errors as dir may not exist)
-	if ( must_create_root || must_create_tmp ) {                          // we cannot mount directly in chroot_dir
-		if (!work_dir_s)
-			throw
-				"need a work dir to"s
-			+	(	must_create_root ? " create root view"
-				:	must_create_tmp  ? " create tmp view"
-				:	                   " ???"
-				)
-			;
-		::vector_s top_lvls    = lst_dir_s(+chroot_dir_s?chroot_dir_s:"/") ;
-		::string   work_root   = work_dir_s+"root"                         ;
-		::string   work_root_s = work_root+'/'                             ;
-		mk_dir_s      (work_root_s) ;
-		unlnk_inside_s(work_root_s) ;
-		trace("top_lvls",work_root_s,top_lvls) ;
-		for( ::string const& f : top_lvls ) {
-			::string src_f     = (+chroot_dir_s?chroot_dir_s:"/"s) + f ;
-			::string private_f = work_root_s                       + f ;
-			switch (FileInfo(src_f).tag()) {                                                                                   // exclude weird files
-				case FileTag::Reg   :
-				case FileTag::Empty :
-				case FileTag::Exe   : AcFd    (        private_f    ,Fd::Write      ) ; _mount_bind(private_f,src_f) ; break ; // create file
-				case FileTag::Dir   : mk_dir_s(with_slash(private_f)                ) ; _mount_bind(private_f,src_f) ; break ; // create dir
-				case FileTag::Lnk   : lnk     (           private_f ,read_lnk(src_f)) ;                                break ; // copy symlink
-			DN}
+	#if !HAS_NAMESPACES
+		(void)report ;
+		throw "namespaces are not supported on this system"s ;
+	#else
+		int uid = ::getuid() ;                                                          // must be done before unshare that invents a new user
+		int gid = ::getgid() ;                                                          // .
+		//
+		if (::unshare(CLONE_NEWUSER|CLONE_NEWNS)!=0) throw "cannot create namespace : "s+::strerror(errno) ;
+		//
+		size_t   uphill_lvl = 0 ;
+		::string highest_s  ;
+		for( ::string const& d_s : src_dirs_s ) if (!is_abs_s(d_s))
+			if ( size_t ul=uphill_lvl_s(d_s) ; ul>uphill_lvl ) {
+				uphill_lvl = ul  ;
+				highest_s  = d_s ;
+			}
+		//
+		::string phy_super_repo_root_s ;                                                // dir englobing all relative source dirs
+		::string super_repo_view_s     ;                                                // .
+		::string top_repo_view_s       ;
+		if (+repo_view_s) {
+			if (!( repo_view_s.ends_with(cwd_s) && repo_view_s.size()>cwd_s.size()+1 )) // ensure repo_view_s has at least one more level than cwd_s
+				throw
+					"cannot map local repository dir to "+no_slash(repo_view_s)+" appearing as "+no_slash(cwd_s)+" in top-level repository, "
+					"consider setting <rule>.repo_view="+mk_py_str("/repo/"+no_slash(cwd_s))
+				;
+			phy_super_repo_root_s = phy_repo_root_s ; for( [[maybe_unused]] size_t _ : iota(uphill_lvl) ) phy_super_repo_root_s = dir_name_s(phy_super_repo_root_s) ;
+			super_repo_view_s     = repo_view_s     ; for( [[maybe_unused]] size_t _ : iota(uphill_lvl) ) super_repo_view_s     = dir_name_s(super_repo_view_s    ) ;
+			SWEAR(phy_super_repo_root_s!="/",phy_repo_root_s,uphill_lvl) ;              // this should have been checked earlier
+			if (!super_repo_view_s)
+				throw
+					"cannot map repository dir to "+no_slash(repo_view_s)+" with relative source dir "+no_slash(highest_s)
+				+	", "
+				+	"consider setting <rule>.repo_view="+mk_py_str("/repo/"+no_slash(phy_repo_root_s.substr(phy_super_repo_root_s.size())+cwd_s))
+				;
+			if (repo_view_s.substr(super_repo_view_s.size())!=phy_repo_root_s.substr(phy_super_repo_root_s.size()))
+				throw
+					"last "s+uphill_lvl+" components do not match between physical root dir and root view"
+				+	", "
+				+	"consider setting <rule>.repo_view="+mk_py_str("/repo/"+no_slash(phy_repo_root_s.substr(phy_super_repo_root_s.size())+cwd_s))
+				;
+			top_repo_view_s = repo_view_s.substr(0,repo_view_s.size()-cwd_s.size()) ;
 		}
-		if (must_create_root) mk_dir_s(work_root+super_repo_view_s) ;
-		if (must_create_tmp ) mk_dir_s(work_root+tmp_view_s       ) ;
-		chroot_dir = ::move(work_root) ;
-	}
-	// mapping uid/gid is necessary to manage overlayfs
-	_atomic_write( "/proc/self/setgroups" , "deny"                 ) ;                                                         // necessary to be allowed to write the gid_map (if desirable)
-	_atomic_write( "/proc/self/uid_map"   , ""s+uid+' '+uid+" 1\n" ) ;
-	_atomic_write( "/proc/self/gid_map"   , ""s+gid+' '+gid+" 1\n" ) ;
-	//
-	::string repo_root_s = +repo_view_s ? top_repo_view_s : phy_repo_root_s ;
-	if (+repo_view_s) _mount_bind( chroot_dir+super_repo_view_s , phy_super_repo_root_s ) ;
-	if (+tmp_view_s ) _mount_bind( chroot_dir+tmp_view_s        , phy_tmp_dir_s         ) ;
-	//
-	if      (+chroot_dir ) _chroot(chroot_dir)     ;
-	if      (+repo_view_s) _chdir(repo_view_s    ) ;
-	else if (+chroot_dir ) _chdir(phy_repo_root_s) ;
-	//
-	size_t work_idx = 0 ;
-	for( auto const& [view,descr] : views ) if (+descr) {                                                                      // empty descr does not represent a view
-		::string   abs_view = mk_abs(view,repo_root_s) ;
-		::vector_s abs_phys ;                            abs_phys.reserve(descr.phys.size()) ; for( ::string const& phy : descr.phys ) abs_phys.push_back(mk_abs(phy,repo_root_s)) ;
-		/**/                                    _create(report,view) ;
-		for( ::string const& phy : descr.phys ) _create(report,phy ) ;
-		if (is_dirname(view)) {
-			for( ::string const& cu : descr.copy_up ) {
-				::string dst = descr.phys[0]+cu ;
-				if (is_dirname(cu))
-					_create(report,dst) ;
-				else
-					for( size_t i : iota(1,descr.phys.size()) )
-						if (_create(report,dst,descr.phys[i]+cu)) break ;
+		if ( +super_repo_view_s && super_repo_view_s.rfind('/',super_repo_view_s.size()-2)!=0 ) throw "non top-level repo_view not yet implemented"s ; // XXXM : handle cases where dir is not top level
+		if ( +tmp_view_s        && tmp_view_s       .rfind('/',tmp_view_s       .size()-2)!=0 ) throw "non top-level tmp_view not yet implemented"s  ; // .
+		//
+		::string chroot_dir       = chroot_dir_s                                                          ; if (+chroot_dir) chroot_dir.pop_back() ;   // cannot use no_slash to properly manage ...
+		bool     must_create_root = +super_repo_view_s && !is_dir(chroot_dir+no_slash(super_repo_view_s)) ;                                            // ... the '/' case
+		bool     must_create_tmp  = +tmp_view_s        && !is_dir(chroot_dir+no_slash(tmp_view_s       )) ;
+		trace("create",STR(must_create_root),STR(must_create_tmp)) ;
+		if ( must_create_root || must_create_tmp || +views )
+			try { unlnk_inside_s(work_dir_s) ; } catch (::string const& e) {} // if we need a work dir, we must clean it first as it is not cleaned upon exit (ignore errors as dir may not exist)
+		if ( must_create_root || must_create_tmp ) {                          // we cannot mount directly in chroot_dir
+			if (!work_dir_s)
+				throw
+					"need a work dir to"s
+				+	(	must_create_root ? " create root view"
+					:	must_create_tmp  ? " create tmp view"
+					:	                   " ???"
+					)
+				;
+			::vector_s top_lvls    = lst_dir_s(+chroot_dir_s?chroot_dir_s:"/") ;
+			::string   work_root   = work_dir_s+"root"                         ;
+			::string   work_root_s = work_root+'/'                             ;
+			mk_dir_s      (work_root_s) ;
+			unlnk_inside_s(work_root_s) ;
+			trace("top_lvls",work_root_s,top_lvls) ;
+			for( ::string const& f : top_lvls ) {
+				::string src_f     = (+chroot_dir_s?chroot_dir_s:"/"s) + f ;
+				::string private_f = work_root_s                       + f ;
+				switch (FileInfo(src_f).tag()) {                                                                                   // exclude weird files
+					case FileTag::Reg   :
+					case FileTag::Empty :
+					case FileTag::Exe   : AcFd    (        private_f    ,Fd::Write      ) ; _mount_bind(private_f,src_f) ; break ; // create file
+					case FileTag::Dir   : mk_dir_s(with_slash(private_f)                ) ; _mount_bind(private_f,src_f) ; break ; // create dir
+					case FileTag::Lnk   : lnk     (           private_f ,read_lnk(src_f)) ;                                break ; // copy symlink
+				DN}
 			}
+			if (must_create_root) mk_dir_s(work_root+super_repo_view_s) ;
+			if (must_create_tmp ) mk_dir_s(work_root+tmp_view_s       ) ;
+			chroot_dir = ::move(work_root) ;
 		}
-		size_t          sz    = descr.phys.size() ;
-		::string const& upper = descr.phys[0]     ;
-		if (sz==1) {
-			_mount_bind( abs_view , abs_phys[0] ) ;
-		} else {
-			::string work_s = is_lcl(upper) ? work_dir_s+"work_"+(work_idx++)+'/' : upper.substr(0,upper.size()-1)+".work/" ;  // if not in the repo, it must be in tmp
-			mk_dir_s(work_s) ;
-			_mount_overlay( abs_view , abs_phys , mk_abs(work_s,repo_root_s) ) ;
+		// mapping uid/gid is necessary to manage overlayfs
+		_atomic_write( "/proc/self/setgroups" , "deny"                 ) ;                                                         // necessary to be allowed to write the gid_map (if desirable)
+		_atomic_write( "/proc/self/uid_map"   , ""s+uid+' '+uid+" 1\n" ) ;
+		_atomic_write( "/proc/self/gid_map"   , ""s+gid+' '+gid+" 1\n" ) ;
+		//
+		::string repo_root_s = +repo_view_s ? top_repo_view_s : phy_repo_root_s ;
+		if (+repo_view_s) _mount_bind( chroot_dir+super_repo_view_s , phy_super_repo_root_s ) ;
+		if (+tmp_view_s ) _mount_bind( chroot_dir+tmp_view_s        , phy_tmp_dir_s         ) ;
+		//
+		if      (+chroot_dir ) _chroot(chroot_dir)     ;
+		if      (+repo_view_s) _chdir(repo_view_s    ) ;
+		else if (+chroot_dir ) _chdir(phy_repo_root_s) ;
+		//
+		size_t work_idx = 0 ;
+		for( auto const& [view,descr] : views ) if (+descr) {                                                                      // empty descr does not represent a view
+			::string   abs_view = mk_abs(view,repo_root_s) ;
+			::vector_s abs_phys ;                            abs_phys.reserve(descr.phys.size()) ; for( ::string const& phy : descr.phys ) abs_phys.push_back(mk_abs(phy,repo_root_s)) ;
+			/**/                                    _create(report,view) ;
+			for( ::string const& phy : descr.phys ) _create(report,phy ) ;
+			if (is_dirname(view)) {
+				for( ::string const& cu : descr.copy_up ) {
+					::string dst = descr.phys[0]+cu ;
+					if (is_dirname(cu))
+						_create(report,dst) ;
+					else
+						for( size_t i : iota(1,descr.phys.size()) )
+							if (_create(report,dst,descr.phys[i]+cu)) break ;
+				}
+			}
+			size_t          sz    = descr.phys.size() ;
+			::string const& upper = descr.phys[0]     ;
+			if (sz==1) {
+				_mount_bind( abs_view , abs_phys[0] ) ;
+			} else {
+				::string work_s = is_lcl(upper) ? work_dir_s+"work_"+(work_idx++)+'/' : upper.substr(0,upper.size()-1)+".work/" ;  // if not in the repo, it must be in tmp
+				mk_dir_s(work_s) ;
+				_mount_overlay( abs_view , abs_phys , mk_abs(work_s,repo_root_s) ) ;
+			}
 		}
-	}
-	trace("done") ;
-	return true/*entered*/ ;
+		trace("done") ;
+		return true/*entered*/ ;
+	#endif
 }
 
 // XXXM : implement recursive views
@@ -534,6 +545,7 @@ bool/*entered*/ JobStartRpcReply::enter(
 	::string phy_work_dir_s = PrivateAdminDirS+"work/"s+small_id+'/'                                                                         ;
 	bool     entered        = job_space.enter( actions , phy_repo_root_s , phy_tmp_dir_s , cwd_s , phy_work_dir_s , autodep_env.src_dirs_s ) ;
 	if (entered) {
+		SWEAR(HAS_NAMESPACES) ;
 		// find a good starting pid
 		// the goal is to minimize risks of pid conflicts between jobs in case pid is used to generate unique file names as temporary file instead of using TMPDIR, which is quite common
 		// to do that we spread pid's among the availale range by setting the first pid used by jos as apart from each other as possible
@@ -553,7 +565,7 @@ bool/*entered*/ JobStartRpcReply::enter(
 void JobStartRpcReply::exit() {
 	// work dir cannot be cleaned up as we may have chroot'ed inside
 	Trace trace("JobStartRpcReply::exit",STR(keep_tmp),_tmp_dir_s) ;
-	SWEAR(+_tmp_dir_s) ;                                             // ensure we do not erase the whole repo
+	SWEAR(+_tmp_dir_s) ;                                        // ensure we do not erase the whole repo
 	if (!keep_tmp) unlnk_inside_s(_tmp_dir_s,true/*abs_ok*/ ) ;
 	job_space.exit() ;
 }
diff --git a/src/rpc_job.hh b/src/rpc_job.hh
index 289b636..83b5f06 100644
--- a/src/rpc_job.hh
+++ b/src/rpc_job.hh
@@ -18,10 +18,34 @@
 // PER_AUTODEP_METHOD : add entry here
 // >=Ld means a lib is pre-loaded (through LD_AUDIT or LD_PRELOAD)
 // by default, use a compromize between speed an reliability
-#if HAS_LD_AUDIT
-	ENUM_2( AutodepMethod , Ld=LdAudit   , Dflt=LdAudit   , None , Ptrace , LdAudit , LdPreload , LdPreloadJemalloc )
+#if IS_LINUX
+	#if HAS_LD_AUDIT
+		#if HAS_PTRACE
+			ENUM_2( AutodepMethod , Ld=LdAudit   , Dflt=LdAudit   , None , Ptrace , LdAudit , LdPreload , LdPreloadJemalloc )
+		#else
+			ENUM_2( AutodepMethod , Ld=LdAudit   , Dflt=LdAudit   , None ,          LdAudit , LdPreload , LdPreloadJemalloc )
+		#endif
+	#else
+		#if HAS_PTRACE
+			ENUM_2( AutodepMethod , Ld=LdPreload , Dflt=LdPreload , None , Ptrace ,           LdPreload , LdPreloadJemalloc )
+		#else
+			ENUM_2( AutodepMethod , Ld=LdPreload , Dflt=LdPreload , None ,                    LdPreload , LdPreloadJemalloc )
+		#endif
+	#endif
 #else
-	ENUM_2( AutodepMethod , Ld=LdPreload , Dflt=LdPreload , None , Ptrace ,           LdPreload , LdPreloadJemalloc )
+	#if HAS_LD_AUDIT
+		#if HAS_PTRACE
+			ENUM_2( AutodepMethod , Ld=LdAudit   , Dflt=LdAudit   , None , Ptrace , LdAudit , LdPreload                     )
+		#else
+			ENUM_2( AutodepMethod , Ld=LdAudit   , Dflt=LdAudit   , None ,          LdAudit , LdPreload                     )
+		#endif
+	#else
+		#if HAS_PTRACE
+			ENUM_2( AutodepMethod , Ld=LdPreload , Dflt=LdPreload , None , Ptrace ,           LdPreload                     )
+		#else
+			ENUM_2( AutodepMethod , Ld=LdPreload , Dflt=LdPreload , None ,                    LdPreload                     )
+		#endif
+	#endif
 #endif
 // END_OF_VERSIONING
 
diff --git a/src/time.hh b/src/time.hh
index 179abeb..f4d8e1d 100644
--- a/src/time.hh
+++ b/src/time.hh
@@ -258,8 +258,8 @@ namespace Time {
 		// cxtors & casts
 	public :
 		using Date::Date ;
-		constexpr Ddate(                           FileTag tag=FileTag::None )                    {                    _val  = +tag ; }
-		constexpr Ddate( struct ::stat const& st , FileTag tag               ) : Date{st.st_mtim} { _val &= ~_TagMsk ; _val |= +tag ; }
+		constexpr Ddate(                           FileTag tag=FileTag::None )                         {                    _val  = +tag ; }
+		constexpr Ddate( struct ::stat const& st , FileTag tag               ) : Date{st.ST_MTIMESPEC} { _val &= ~_TagMsk ; _val |= +tag ; }
 		// accesses
 		constexpr bool    operator+() const { return _date()               ; }
 		constexpr FileTag tag      () const { return FileTag(_val&_TagMsk) ; }
diff --git a/src/trace.cc b/src/trace.cc
index 6b0941f..c9e6293 100644
--- a/src/trace.cc
+++ b/src/trace.cc
@@ -98,7 +98,12 @@ using namespace Time ;
 				_s_cur_sz = (_s_cur_sz+4095)&size_t(-4095) ; // round up to 4K
 				_s_cur_sz = ::min(_s_cur_sz,size_t(s_sz))  ;
 				if (::ftruncate(_s_fd,_s_cur_sz)!=0) FAIL(_s_fd,old_sz,_s_cur_sz) ;
-				_s_data = static_cast<uint8_t*>(::mremap( _s_data , old_sz , _s_cur_sz , MREMAP_MAYMOVE )) ;
+				#if HAS_MREMAP
+					_s_data = static_cast<uint8_t*>(::mremap( _s_data , old_sz , _s_cur_sz , MREMAP_MAYMOVE )) ;
+				#else
+					::munmap(_s_data,old_sz) ;
+					_s_data = static_cast<uint8_t*>(::mmap( nullptr , _s_cur_sz , PROT_READ|PROT_WRITE , MAP_SHARED , _s_fd , 0 )) ;
+				#endif
 			}
 			if (new_pos>s_sz) {
 				if (_s_pos<s_sz) ::memset(_s_data+_s_pos,0,s_sz-_s_pos) ;
diff --git a/src/utils.cc b/src/utils.cc
index dc10764..aca20ae 100644
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -5,6 +5,14 @@
 
 #include "utils.hh"
 
+#if IS_DARWIN
+	#include <mach-o/dyld.h> // _NSGetExecutablePath
+#endif
+#if !HAS_ELF
+	#undef HAS_ADDR2LINE
+	#define HAS_ADDR2LINE 0 // cant use addr2line w/o elf support
+#endif
+
 #if HAS_CLOSE_RANGE
     #include <linux/close_range.h>
 #endif
@@ -280,7 +288,21 @@ thread_local char t_thread_key = '?'   ;
 bool              _crash_busy  = false ;
 
 ::string get_exe() {
-	return read_lnk("/proc/self/exe") ;
+	#if IS_DARWIN
+		::string res ( PATH_MAX , '\0' )                    ;
+		uint32_t sz  = res.size()                           ;
+		int      rc  = _NSGetExecutablePath(res.data(),&sz) ; SWEAR(rc==0,rc) ;
+		res.resize(sz) ;
+		AcFd fd { res } ;
+		res.resize(PATH_MAX) ;
+		::fcntl( fd , F_GETPATH , res.data() ) ;
+		res.resize(::strlen(res.data())) ;
+	#elif IS_LINUX
+		::string res = Disk::read_lnk("/proc/self/exe") ;
+	#else
+		#error cannot get executable
+	#endif
+	return res ;
 }
 
 #if HAS_STACKTRACE
diff --git a/src/utils.hh b/src/utils.hh
index 7f3ed4b..8e9780f 100644
--- a/src/utils.hh
+++ b/src/utils.hh
@@ -42,6 +42,11 @@ using std::getline  ; // special case getline which also has a C version that hi
 
 #define self (*this)
 
+#if !HAS_UINT
+	using uint  = unsigned int  ;
+	using ulong = unsigned long ;
+#endif
+
 template<class T> requires requires(T const& x) { !+x ; } constexpr bool operator!(T const& x) { return !+x ; }
 
 static constexpr size_t Npos = ::string::npos ;
diff --git a/unit_tests/cargo.py b/unit_tests/cargo.py
index 5cab731..fdbec0a 100644
--- a/unit_tests/cargo.py
+++ b/unit_tests/cargo.py
@@ -53,6 +53,10 @@ if __name__!='__main__' :
 
 else :
 
+	if os.uname().sysname!='Linux' :
+		print('neither jemalloc nor ptrace available',file=open('skipped','w'))
+		exit()
+
 	import os.path as osp
 	import shutil
 	import subprocess as sp
diff --git a/unit_tests/jemalloc.py b/unit_tests/jemalloc.py
index 20e3e32..1446657 100644
--- a/unit_tests/jemalloc.py
+++ b/unit_tests/jemalloc.py
@@ -38,6 +38,10 @@ else :
 	import subprocess as sp
 	import sys
 
+	if os.uname().sysname!='Linux' :
+		print('jemalloc not implemented',file=open('skipped','w'))
+		exit()
+
 	sav = os.environ.get('LD_PRELOAD')
 	os.environ['LD_PRELOAD'] = 'libjemalloc.so'
 	has_jemalloc             = not sp.run(('/usr/bin/echo',),check=True,stderr=sp.PIPE).stderr
diff --git a/unit_tests/mandelbrot.py b/unit_tests/mandelbrot.py
index de2d0d8..19cc067 100644
--- a/unit_tests/mandelbrot.py
+++ b/unit_tests/mandelbrot.py
@@ -48,6 +48,10 @@ if __name__!='__main__' :
 
 else :
 
+	if os.uname().sysname!='Linux' :
+		print('neither jemalloc nor ptrace available',file=open('skipped','w'))
+		exit()
+
 	import shutil
 
 	cargo = shutil.which('cargo')
diff --git a/unit_tests/namespaces.py b/unit_tests/namespaces.py
index 753e6e5..242d1f8 100644
--- a/unit_tests/namespaces.py
+++ b/unit_tests/namespaces.py
@@ -55,6 +55,10 @@ if __name__!='__main__' :
 
 else :
 
+	if not lmake.has_namespaces :
+		print('namespaces not available',file=open('skipped','w'))
+		exit()
+
 	import ut
 
 	print('lower\nupper',file=open('tmp_map_ref','w'))
diff --git a/unit_tests/overlay.py b/unit_tests/overlay.py
index 692905d..5037615 100644
--- a/unit_tests/overlay.py
+++ b/unit_tests/overlay.py
@@ -39,7 +39,7 @@ if __name__!='__main__' :
 		tmp_view = '/tmp'
 		views    = { '/tmp/merged/' : {'upper':'/tmp/upper/','lower':lmake.repo_root+'/'} }
 		target   = 'dut3'
-		def cmd() :
+		def cmd():
 			print(open('/tmp/merged/read/src').read(),end='')
 
 	class Test(Rule) :
@@ -52,6 +52,10 @@ if __name__!='__main__' :
 
 else :
 
+	if not lmake.has_namespaces :
+		print('namespaces not available',file=open('skipped','w'))
+		exit()
+
 	import os
 
 	import ut
diff --git a/unit_tests/tmp.py b/unit_tests/tmp.py
index e92dda4..00d2653 100644
--- a/unit_tests/tmp.py
+++ b/unit_tests/tmp.py
@@ -84,6 +84,10 @@ if __name__!='__main__' :
 
 else :
 
+	if not lmake.has_namespaces :
+		print('namespaces not available',file=open('skipped','w'))
+		exit()
+
 	import ut
 
 	ut.lmake( 'ok1','ok2' , done=6 ) # check target is out of date
diff --git a/unit_tests/tmp2.py b/unit_tests/tmp2.py
index cea544a..b6bbaff 100644
--- a/unit_tests/tmp2.py
+++ b/unit_tests/tmp2.py
@@ -106,6 +106,10 @@ if __name__!='__main__' :
 
 else :
 
+	if not lmake.has_namespaces :
+		print('namespaces not available',file=open('skipped','w'))
+		exit()
+
 	import ut
 
 	with open('lnk_dut.ref','w') as f :
diff --git a/unit_tests/trace_exec.py b/unit_tests/trace_exec.py
index ce795ca..32e2069 100644
--- a/unit_tests/trace_exec.py
+++ b/unit_tests/trace_exec.py
@@ -34,6 +34,10 @@ if __name__!='__main__' :
 
 else :
 
+	if not lmake.has_namespaces :
+		print('namespaces not available',file=open('skipped','w'))
+		exit()
+
 	import os
 	import subprocess as sp
 
diff --git a/unit_tests/views.py b/unit_tests/views.py
index a7d6221..66a149b 100644
--- a/unit_tests/views.py
+++ b/unit_tests/views.py
@@ -35,6 +35,10 @@ if __name__!='__main__' :
 
 else :
 
+	if not lmake.has_namespaces :
+		print('namespaces not available',file=open('skipped','w'))
+		exit()
+
 	import os
 
 	import ut
