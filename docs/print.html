<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>open-lmake documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">open-lmake documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>The open-lmake build system automatically determines which pieces of a large workflow need to be remade and issues the commands to remake them.</p>
<p>Our examples show how to build and test C/C++ programs, as they are very common, but you can use
open-lmake with any programming language to run any phase of your CI/CD as long as these can be scripted.</p>
<p>Indeed, open-lmake is not limited to building programs.
You can use it to describe any task where some files must be (re)computed automatically from others whenever recomputing would lead to a different content.
Such situations include dep modifications, but also command modifications, dep list modifications,
apparition of an include file that was in the search path before an include file was actually accessed, symbolic link modifications, etc.</p>
<p>Symbolic links and hard links are also supported.</p>
<p>As far as open-lmake is concerned, repositories can be moved, archived and restored.
Tools are provided to help user achieve the same level of flexibility.</p>
<p>Open-lmake is designed to be scalable, robust and efficient.</p>
<p>By scalable, we mean that open-lmake can manage millions of files and tens of thousands of CPU hours with no difficulties,
so there is never any reason to have any kind of recursive invocation, open-lmake can handle the whole project flat.</p>
<p>By robust, we mean that open-lmake guarantees that if a job is not rerun, then rerunning it would lead to the same content (or a content that is equally legal).
This includes automatic capture of so called hidden deps (i.e. deps that are not explicitly stated in the rules, e.g. include files).</p>
<p>We also mean that open-lmake, as any software, it may have bugs.
Such bugs can lead to crashes and to pessimistic behavior (a job is rerun while it was not necessary).
But special attention has been devoted in its design to ensure that it is never optimistic (a job not being rerun while it should have been).
In case of any adverse event (lmake crashes or spurious system reboot),
open-lmake automatically recovers potentially corrupted states in a safe way to avoid having to remake the whole project because a few files are corrupted.
In extreme cases, there is a <code>lrepair</code> tool that can recover all safe parts of a damaged repository.</p>
<p>Note that open-lmake does not only recorver from its own flees, but also a lot of experience is embedded into it to work around system bugs.
This includes for example NFS peculiar notion of close-to-open consistency (which does not apply to the directory containing the file) or jobs spuriously disappearing.</p>
<p>By efficient, we mean that jobs are run in parallel, optionally using a batcher such as SGE or slurm, managing limited resources as declared in <code>Lmakefile.py</code>.
We also mean that open-lmake makes a lot of effort to determine if it is necessary to run a job (while always staying pessismistic).
Such effort includes checksum based modification detection rather than date based, so that if a job is rerun and produces an identical content, subsequent jobs are not rerun.
Also, open-lmake embed a build cache whereby jobs can record their results in a cache so that if the same run needs to be carried out by another user,
it may barely fetch the result from the cache rather than run the - potentially lengthy - job.</p>
<h2 id="preparing-and-running-lmake"><a class="header" href="#preparing-and-running-lmake">Preparing and running lmake.</a></h2>
<p>To prepare to use open-lmake, you must write a file called <code>Lmakefile.py</code> that describes the relationships between files in your workflow and provides commands for generating them.
This is analogous to the <code>Makefile</code> when using <code>make</code>.</p>
<p>When developping a program, typically, the executable file is built from object files, which in turn are built by compiling source files.
Then unit tests are run from the executable and input files, and the output is compared to some references.
Finally a test suite is a collection of such tests.</p>
<p>Once a suitable <code>Lmakefile.py</code> exists, each time you change anything in the workflow (source files, recipes, ...), this simple shell command:</p>
<pre><code class="language-bash">lmake &lt;my_target&gt;
</code></pre>
<p>suffices to perform all necessary steps so that <code>&lt;my_target&gt;</code> is reproduced as if all steps leading to it were carried out although only necessary steps were actually carried out.
The <code>lmake</code> program maintains an internal state in the <code>LMAKE</code> directory to decide which files need to be regenerated.
For each one of those, it issues the recipes recorded in <code>Lmakefile.py</code>.
During job execution, <code>lmake</code> instruments them in order to gather which files are read and written in order to determine hidden deps and whether such actions are legal.
These information are recorded in the <code>LMAKE</code> directory.</p>
<p>You can provide command line arguments to <code>lmake</code> to somewhat control this process.</p>
<h2 id="problems-and-bugs"><a class="header" href="#problems-and-bugs">Problems and Bugs</a></h2>
<p>If you have problems with open-lmake or think you've found a bug,
please report it to the developers; we cannot promise to do anything but
we may well be willing to fix it.</p>
<p>Before reporting a bug, make sure you've actually found a real bug.
Carefully reread the documentation and see if it really says you can do
what you're trying to do.
If it's not clear whether you should be able to do something or not, report that too; it's a bug in the documentation!</p>
<p>Before reporting a bug or trying to fix it yourself, try to isolate it
to the smallest possible <code>Lmakefile.py</code> that reproduces the problem.
Then send us the <code>Lmakefile.py</code> and the exact results open-lmake gave you, including any error messages.
Please don't paraphrase these messages: it's best to cut and paste them into your report.
When generating this small <code>Lmakefile.py</code>, be sure to not use any non-free
or unusual tools in your recipes: you can almost always emulate what
such a tool would do with simple shell commands.
Finally, be sure to explain what you expected to occur; this will help us decide whether the problem is in the code or the documentation.</p>
<p>if your problem is non-deterministic, i.e. it shows up once in a while, include the entire content of the <code>LMAKE</code> directory.
This directory contains extensive execution traces meant to help developers to track down problems.
Make sure, though, to trim it from any sensitive data (with regard to your IP).</p>
<p>Once you have a precise problem, you can report it on <a href="https://github.com/cesar-douady/open-lmake">github</a></p>
<p>In addition to the information above, please be careful to include the version number of the open-lmake you are using.
You can get this information from the file <code>LMAKE/version</code>.
Be sure also to include the type of machine and operating system you are using.
One way to obtain this information is by running the command <code>uname -a</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>To introduce the basic concepts of open-lmake, we will consider a case including:</p>
<ul>
<li>C/C++ compilation</li>
<li>link edition of executables</li>
<li>tests using test scenari</li>
<li>test suites containing list of test scenari</li>
</ul>
<p>We will implement such a simple flow with a full decoupling of the flow (as described in <code>Lmakefile.py</code>) and project data (as described by the other source files).
In this flow, we will assume that:</p>
<ul>
<li>for an executable <code>foo.exe</code>, its <code>main</code> is located in <code>foo.c</code> or <code>foo.cc</code></li>
<li>for a feature <code>foo.o</code>, its interface is in <code>foo.h</code> or <code>foo.hh</code> and it implementation (if any) is in <code>foo.c</code> or <code>foo.cc</code></li>
</ul>
<p>With these assumptions, which correspond to usual code organization, the list of objects necessary to link an executable can be derived automatically by analyzing the source files.</p>
<h2 id="the-lmakefilepy-file"><a class="header" href="#the-lmakefilepy-file">The <code>Lmakefile.py</code> file</a></h2>
<p><code>Lmakefile.py</code> is the file that describes the flow. It is analogous to <code>Makefile</code> when using <code>make</code> and is plain python (hence its name).
It is composed of 3 parts:</p>
<ul>
<li>config</li>
<li>sources</li>
<li>rules</li>
</ul>
<p>In this introduction, we will use the default config and nothing needs to be put in <code>Lmakefile.py</code>.</p>
<p>Open-lmake needs to have an explicit list of the source files.
If your code based is managed by <code>git</code>, it will be automatically used to list source files.
We will assume we are in this common case for this introduction.</p>
<p>We are left with rules that really describe the flow.
Rules are python classes inheriting from <code>lmake.rules.Rule</code>.</p>
<p>So we must import these:</p>
<pre><code class="language-python">from lmake.rules import Rule
</code></pre>
<p>Now, let us start with the compilation rules.</p>
<p>These will look like:</p>
<pre><code class="language-python">class CompileC(Rule) :
	targets = { 'OBJ' : '{File:.*}.o' }
	deps    = { 'SRC' : '{File}.c'    }
	cmd     = 'gcc -c -o {OBJ} {SRC}'

class CompileCpp(Rule) :
	targets = { 'OBJ' : '{File:.*}.o' }
	deps    = { 'SRC' : '{File}.cc'   }
	cmd     = 'gcc -c -o {OBJ} {SRC}'
</code></pre>
<p>Notes:</p>
<ul>
<li><code>targets</code> define the stems (here <code>File</code>) with a regular expression (here <code>.*</code>).</li>
<li><code>deps</code> define the static deps, i.e. the deps that are needed for all jobs of the rule, but upon execution, other deps (such as .h files) may be discovered (and most of the time will).</li>
<li><code>cmd</code> is an f-string. There is no f-prefix because it is not expanded while reading <code>Lmakefile.py</code> but when a job is executed.</li>
<li>The same is true for <code>deps</code> values, these are f-string (without the f-prefix).</li>
<li>To be selected to build a file, a rule must match the file with one if its targets <strong>and</strong> its static deps must be buildable.
For example, if <code>foo.c</code> exists and <code>foo.cc</code> does not, rule CompileC can be selected to build <code>foo.o</code> and CompileCC cannot.</li>
<li>Hidden deps, on the contrary, may or may not be buildable, this is not a problem for open-lmake.
It may or may not be a problem for the command, depending on how it is written.</li>
<li>Note the use of 'buildable' in the previous points and instead of 'exist'.
If a file does not exist and is buildable, it will be built as soon as open-lmake learns its need.
If a file exists and is not buildable, it will be <code>rm</code>'ed if it was produced by an old job, else it will be declared 'dangling' and this is an error condition.
In this latter case, most of the time, it corresponds to a file that must be added to git.</li>
</ul>
<p>For the link edition, here it is:</p>
<pre><code class="language-python">for ext in ('c','cc') :
	class ListObjects(Rule) :
		name    = f'list objects from {ext}'
		targets = { 'LST' : '{File:.*}.lst'   }
		deps    = { 'SRC' : f'{{File}}.{ext}' }
		def cmd() :
			# this is a rather complex code that computes the transitive closure of included files
			# including included files of the .c (or .cc) file for each included .h (or .hh) file
			# such details are outside the scope of this document
			...

class Link(Rule) :
	targets = { 'EXE' : '{File:.*}.exe' }
	deps    = { 'LST' : '{File}.lst'    }
	cmd     = 'gcc -o {EXE} $(cat {LST})'
</code></pre>
<p>Notes:</p>
<ul>
<li>You have the full power of python, including loops, conditionals etc.</li>
<li>It is not a problem to have several classes defined with the same name (as <code>ListObjects</code> here).
However, to avoid confusion when reporting execution to the user open-lmake refuses to have several rules with the same name.
The name of a rule is its <code>name</code> attribute and defaults to the class name.</li>
<li>cmd can be either a string, in which case it is interpreted as an f-string and its expanded is run with bash to execute the job,
or a function, in which case it is called to execute the job</li>
<li>rule that generate .lst files does not prevent the existence of such files as sources.
In such a case, the rule will not be executed.</li>
</ul>
<p>Finally, we need tests :</p>
<pre><code class="language-python">class Test(Rule) :
	target = '{File:.*}.test_out'
	deps   = { 'SCN' : '{File}.scn' }
	cmd    = '{SCN}'

class TestSuiteExpansion(Rule) :
	targets = { 'SCN'       : '{File:.*}.test_dir/{Test*:.*}.scn' }
	deps    = { 'TEST_SUIT' : '{File}.test_suite'                 }
	def cmd() :
		for line in open(TEST_SUIT) :
			name,scn = line.split(None,1)
			open(SCN(name),'w').write(scn)
			os.chmod(SCN(name),0o755)

class TestSuiteReport(Rule) :
	target = '{File:.*}.test_suit_report'
	deps   = { 'TEST_SUIT' : '{File}.test_suite' }
	def cmd() :
		for line in open(TEST_SUIT) :
			name = line.split(1)[0]
			stdout.write(open(f'{File}.test_dir/{name}.test_out'))
</code></pre>
<p>Notes:</p>
<ul>
<li>One can define <code>target</code> rather than <code>targets</code>.
It is a single target and is special in that is is fed by the stdout of <code>cmd</code>.
Although more rarely used, <code>dep</code> can be used and feeds <code>cmd</code> as its stdin.</li>
<li>In <code>TestSuiteExpansion</code> targets, there is a <code>*</code> after <code>Test</code>.
This a so-called 'star-stem'.
It means that a single execution of the job generates files with diferent values for this star-stem.</li>
<li>for python <code>cmd</code> (when it is a function), targets, deps and stems are accessible as global variables.
Star-stems are not defined (they would be meaningless) and the corresponding targets are functions instead of variables: you must pass the star-stems as arguments.</li>
</ul>
<p>Special notes on content based up-to-date definition:</p>
<ul>
<li>Open-lmake detects a file has changed if its content has changed, not its date.</li>
<li>This means that a checksum is computed for all targets generated by all jobs.</li>
<li>This has a marginal impact on performance: it uses xxh as a checksum lib, it is both of excellent quality (though not crypto-robust) and bracingly fast.</li>
<li>This is not only an optimization but has consequences on the flow itself.</li>
<li>Here, we define a test suite as a list of named test scneari.
When the test suite is modfiied, all scenari are rebuilt, but only those that have actually changed are rerun.</li>
<li>And this is common case: you often modify the test suite to change a few tests or add a few ones.
It would be unacceptable to rerun all tests in such case and would require the flow to be organized in another way.
Yet, defining test suites this way is very comfortable.</li>
</ul>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<p>The first time you execute the flow, you need to execute all steps :</p>
<ul>
<li>compile all source files to object files</li>
<li>link object files to the executable</li>
<li>run all tests</li>
</ul>
<p>Once this has been done, what needs to be executed depends on what has been modified:</p>
<div class="table-wrapper"><table><thead><tr><th>What has been modified</th><th>What needs to be re-executed</th><th>Notes</th></tr></thead><tbody>
<tr><td>nothing</td><td>nothing</td><td></td></tr>
<tr><td>a .c (or .cc) source file</td><td>compile said source file, link, run all tests</td><td>if .o does not change, nothing is run any further</td></tr>
<tr><td>a .h (or.hh) include file</td><td>compile source files including said .h (or .hh), link, run all tests</td><td>if no .o change, nothing is run any further</td></tr>
<tr><td>a test suite file</td><td>run modified/new tests</td><td></td></tr>
<tr><td>a <code>cmd</code> in <code>Lmakefile.py</code></td><td>run all jobs using corresponding rule and all depending jobs</td><td>depending jobs are only executed if file actually changes</td></tr>
</tbody></table>
</div>
<h2 id="further-notes"><a class="header" href="#further-notes">Further notes</a></h2>
<h3 id="use-of-the-critical-attribute"><a class="header" href="#use-of-the-critical-attribute">Use of the <code>critical</code> attribute</a></h3>
<p>Some deps can be declared <code>critical</code>.
This has no semantic impact but may be important performance wise.
Open-lmake computes the actual deps of a job while it executes it while ideally, you would need to know them beforehand.
So it considers the known deps (i.e. collected during the last run) as a good approximation of the ones that will be collected during the current run.</p>
<p>The general principle is:</p>
<ul>
<li>Rebuild known deps.</li>
<li>Execute job.</li>
<li>If new deps appear, rebuild them.</li>
<li>If one of such new deps changes during this rebuild, rerun job.</li>
<li>Iterate until no new deps appear.</li>
</ul>
<p>Suppose now that you have a dep that contains a list of some files that will become deps (such as the <code>LST</code> dep in the <code>Link</code> rule).
If this list changes, it may very well suppress such a file (an object file in the <code>Link</code> case).
This means that a file may be uselessly recompiled.</p>
<p>If a <code>critical</code> dep exists, the firt step of the general principle becomes:</p>
<ul>
<li>rebuild known deps, except those located after a modified <code>critical</code> dep.</li>
</ul>
<p>The <code>Link</code> rule would be better if written as:</p>
<pre><code class="language-python">class Link(Rule) :
	targets = { 'EXE' : '{File:.*}.exe'               }
	deps    = { 'LST' : ( '{File}.lst' , 'critical' ) }
	cmd = '''
		ldepend --read $(cat {LST})
		lcheck_deps
		gcc -o {EXE} $(cat {LST})
	'''
</code></pre>
<p>The drawback of using the <code>critical</code> attribute is that the job will more often be executed twice.
While often such jobs are fast (as the <code>TestSuiteReport</code>), the link phase may be heavier and we would like to avoid executing it twice.
The idea here is:</p>
<ul>
<li><code>ldepend</code> creates deps.</li>
<li><code>lcheck_deps</code> checks that deps accumulated up to the calling point are up-to-date.</li>
<li>This guarantees that gcc will discover no new deps.</li>
</ul>
<h3 id="use-of-a-base-class"><a class="header" href="#use-of-a-base-class">Use of a base class</a></h3>
<p>Quite often, you want to define a vocabulary of stems.
In our example, we have <code>File</code> and <code>Test</code>.</p>
<p>We may define a base class to contain these definitions:</p>
<pre><code class="language-python">class Base(Rule) :
	stems = {
		'File' : '.*'
	.	'Test' : '.*'
	}
</code></pre>
<p>Then all rules can inherit from <code>Base</code> instead of <code>Rule</code> and this vocabulary is defined.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<!-- Why open-lmake-->
<h1 id="binary-packages"><a class="header" href="#binary-packages">Binary packages</a></h1>
<p>Open-lmake binary packages are available on launchpad.net for the following systems :</p>
<ul>
<li>ubuntu22.04 (jammy)</li>
<li>ubuntu24.04 (noble)</li>
</ul>
<p>To install these, execute:</p>
<ul>
<li><code>sudo add-apt-repository ppa:cdouady/open-lmake</code></li>
<li><code>sudo apt update</code></li>
<li><code>sudo apt install open-lmake</code></li>
</ul>
<h1 id="compilation"><a class="header" href="#compilation">Compilation</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>To compile open-lmake, you will need:</p>
<ul>
<li>c++20</li>
<li>python3.6 or later with developer support (i.e. access to the <code>libpython*.so</code> file)</li>
<li>if using python2, it must be python2.7</li>
</ul>
<p>The following compilers are known to compile open-lmake:</p>
<ul>
<li>gcc version 11 and above</li>
<li>clang version 14 and above</li>
</ul>
<p>The following compilers are known <strong>not</strong> to compile open-lmake:</p>
<ul>
<li>gcc version 10 and below</li>
</ul>
<p>It has been tested with the dockers listed in the docker directory.</p>
<h2 id="procedure"><a class="header" href="#procedure">Procedure</a></h2>
<ul>
<li>type <code>make</code>
<ul>
<li>this builds all necessary files and some unit tests</li>
<li>you must invoke <code>git clean -fdx</code> if you modified the Makefile or otherwise if you want a reliable build (<code>make</code> is not open-lmake)</li>
<li>you may have to invoke <code>git clean -fdx lmake_env*</code> or even <code>git clean -fdx</code> after a <code>git pull</code>
<ul>
<li><code>lmake_env</code> is a directory which builds lmake under lmake, for test purpose, no guarantee that the resulting package is funtional for now</li>
<li><code>lmake_env-cache</code> is a directory containing cached results from jobs in <code>lmake_env</code></li>
<li>they are not cleaned on purpose before running as this creates variability for testing lmake, but may fail</li>
<li>and generally speaking, make is not robust to past history, so a full 'git clean -fdx' may be necessary to get a reliable build</li>
</ul>
</li>
<li>you can type <code>make LMAKE</code> to just build all necessary files</li>
<li>you can type <code>make lmake.tar.gz.SUMMARY</code> (built by default) to make a tar ball of the compiled files that you can easily deploy</li>
</ul>
</li>
<li>install
<ul>
<li>untar <code>lmake.tar.gz</code> wherever you want and have your <code>$PATH</code> point to the <code>bin</code> directory.
<ul>
<li>the <code>bin</code> sub-directory contains the executables meant to be executed by the user</li>
<li>the <code>_bin</code> sub-directory contains the executables necessary for open-lmake to run, but not meant to be directly invoked by the user
<ul>
<li>it also contains some executables to help debugging open-lmake itself.</li>
</ul>
</li>
<li>the <code>lib</code> sub-directory contains binary and python files for use by the user</li>
<li>the <code>_lib</code> sub-directory contains the binary and python files necessary for open-lmake to run, but not meant for direct use by the user</li>
<li>the relative positions of these 4 directories must remain the same, i.e. they must stay in the same directory with the same names.</li>
</ul>
</li>
</ul>
</li>
<li>specialization
<ul>
<li>you can specialize the build process to better suit your needs:</li>
<li>this can be done by setting variables
<ul>
<li>for example, you can run: <code>CXX=/my/g++ make</code></li>
<li><code>$PYTHON2</code> can be set to your preferred python2 (defaults to <code>python2</code> as found in your <code>$PATH</code>). You will be told if it is not supported.</li>
<li><code>$PYTHON</code> can be set to your preferred python3  (defaults to <code>python3</code> as found in your <code>$PATH</code>). You will be told if it is not supported.</li>
<li><code>$CXX</code> can be set to your preferred C++ compiler (defaults to <code>g++</code>     as found in your <code>$PATH</code>). You will be told if it is not supported.</li>
<li><code>$SLURM_ROOT</code> can be set to the root directory of the slurm installation (by default, <code>slurm/slurm.h</code> will be searched in the standard include path).
For example, <code>slurm.h</code> will be found as <code>$SLURM_ROOT/include/slurm/slurm.h</code></li>
<li><code>$LMAKE_FLAGS</code> can be defined as O[0123]g?d?t?S[AB]P?
<ul>
<li>O[0123] controls the <code>-O option</code>                                      (default: 1 if profiling else 3            )</li>
<li>g       controls the absence of <code>-g option</code>                           (default: debug                            )</li>
<li>d       controls     <code>-DNDEBUG</code>                                       (default: asserts are enabled              )</li>
<li>t       controls     <code>-DNO_TRACE</code>                                     (default: traces are enabled               )</li>
<li>SA      controls the <code>-fsantize=address -fsanitize=undefined</code> options (exclusive with ST                         )</li>
<li>ST      controls the <code>-fsantize=thread</code>                       option  (exclusive with SA                         )</li>
<li>P       controls the <code>-pg</code>                                    option  (profiling info is in gmon.out.<tool>.<pid>)</li>
</ul>
</li>
<li>the <code>-j</code> flag of make is automatically set to the number of processors, you may want to override this, though</li>
</ul>
</li>
<li>this is true the first time you run make. After that, these values are remembered in the file <code>sys_config.env</code>.</li>
<li>you can freely modify this file <code>sys_config.env</code>, though. It will be taken into account.</li>
<li>it is up to you to provide a suitable <code>$LD_LIBRARY_PATH</code> value.
it will be transferred as a default value for rules, to the extent it is necessary to provide the lmake semantic</li>
</ul>
</li>
</ul>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Open-lmake does not require to be installed.
You can run it directly from the build directory.
This is the simplest way unless you seek a system-wide installation.</p>
<p>If running under Ubuntu and you have the necessary packages installed (that you can find by inspecting Makefile, the entry <code>DEBIAN_DEPS</code>),
you can make a Debian package:</p>
<ul>
<li>type <code>make DEBIAN</code></li>
<li>the package is <code>open-lmake_v25.02.7-1_&lt;arch&gt;.deb</code></li>
<li>you can install it with <code>sudo apt install ./open-lmake_v25.02.7-1_&lt;arch&gt;.deb</code></li>
</ul>
<p>Alternatively, you can untar <code>lmake.tar.gz</code> at any place.</p>
<p>Installing system-wide with Debian package will take care of placing both binaries and man pages in the standard directories. Alternatively, you can:</p>
<ul>
<li>put <code>/path/to/open-lmake/bin</code> in your <code>$PATH</code></li>
</ul>
<p>This will simplify the user experience but is not required.</p>
<h1 id="apparmor"><a class="header" href="#apparmor">AppArmor</a></h1>
<blockquote>
<p>AppArmor is known to need tuning on Ubuntu24.04 only.</p>
</blockquote>
<p>In order to implement namespace related features (the <code>lmake_view</code>, <code>repo_view</code>, <code>tmp_view</code>, <code>views</code> and <code>chroot</code> rule attributes), and if your system is configured with AppArmor,
adequate rights must be provided.</p>
<p>In that case, do the following :</p>
<ul>
<li>create a file <code>/etc/apparmor.d/open-lmake</code> with the following content :
<pre><code>	abi &lt;abit/4.0&gt;
	include &lt;tunables/global&gt;
	profile open-lmake /**/{_bin/job_exec,bin/lautodep} flags=(unconfined) {
		userns,
	}
</code></pre>
</li>
<li>activate it with <code>sudo aa-apparamor_parser -r /etc/apparamor.d/open-lmake</code></li>
</ul>
<h1 id="rationale"><a class="header" href="#rationale">Rationale</a></h1>
<p>Because of its unique features (auto-dep, views, ...), open-lmake is necessarily tighly coupled to the underlying OS.
In particular, it was not possible to write it solely on top of Posix.</p>
<p>There are no known road blocks to port it to other OSes (such as Darwin or Windows) although this would require an in depth knowledge of these systems.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="the-lmake-module"><a class="header" href="#the-lmake-module">The <code>lmake</code> module</a></h1>
<h2 id="for-use-in-lmakefilepy"><a class="header" href="#for-use-in-lmakefilepy">For use in <code>Lmakefile.py</code></a></h2>
<h3 id="backends"><a class="header" href="#backends"><code>backends</code></a></h3>
<p>The <code>tuple</code> of implemented backends.
<code>'local'</code> is always present.</p>
<h3 id="autodeps"><a class="header" href="#autodeps"><code>autodeps</code></a></h3>
<p>The <code>tuple</code> of implemented autodep methods.
<code>'ld_preload'</code> is always present.</p>
<h3 id="repo_root"><a class="header" href="#repo_root"><code>repo_root</code></a></h3>
<p>The root dir of the (sub)-repo.</p>
<h3 id="top_repo_root"><a class="header" href="#top_repo_root"><code>top_repo_root</code></a></h3>
<p>The root dir of the top-level repo.</p>
<h3 id="version"><a class="header" href="#version"><code>version</code></a></h3>
<p>This variable holds the native version of open-lmake.
It is a tuple formed with a <code>str</code> (the major version) and a <code>int</code> (the minor version).</p>
<p>Upon new releases of open-lmake, the major version is a tag of the form YY.MM providing the year and month of publication if it is not backward compatible.
Else the minor version is increased if the interface is modified (i.e. new features are supported).
Hence, the check is that major versions must match equal and the actual minor version must be at least the expected minor version.</p>
<h3 id="user_environ"><a class="header" href="#user_environ"><code>user_environ</code></a></h3>
<p>When reading <code>Lmakefile.py</code>, the environment is reset to a standard environment and this variable holds a copy of <code>os.environ</code> before it was reset.</p>
<p>This ensures that the environment cannot be used unless explicitly asked.</p>
<p>Variable values actually used in <code>Lmakefile.py</code> are considered as deps for this process and it is rerun if the actual environment is modified in subsequent <code>lmake</code> commands.</p>
<h3 id="class-pdict"><a class="header" href="#class-pdict"><code>class pdict</code></a></h3>
<p>This class is a dict in which attribute accesses are mapped to item accesses.
It is very practical to handle configurations.</p>
<h3 id="multi_striptxt"><a class="header" href="#multi_striptxt"><code>multi_strip(txt)</code></a></h3>
<p>This function deindents <code>txt</code> as much as possible so as to ease printing code.</p>
<h3 id="check_version-major--minor0-"><a class="header" href="#check_version-major--minor0-"><code>check_version( major , minor=0 )</code></a></h3>
<p>This function is used to check that the expected version is compatible with the actual version.</p>
<p>This function must be called right after having imported the <code>lmake</code> module as in the future, it may adapt itself to the required version when this function is called.
For example, some default values may be modified and if they are used before this function is called, a wrong (native) value may be provided instead of the correct (adjusted to required version) one.</p>
<h2 id="for-use-in-cmd"><a class="header" href="#for-use-in-cmd">For use in <code>cmd()</code></a></h2>
<h3 id="run_cc-cmd_line--marker--stdinnone-"><a class="header" href="#run_cc-cmd_line--marker--stdinnone-"><code>run_cc( *cmd_line , marker='...' , stdin=None )</code></a></h3>
<p>This functions ensures that all dirs listed in arguments such as <code>-I</code> or <code>-L</code> exist reliably.</p>
<p><code>marker</code> is the name of a marker file which is created in include dirs to guarantee there existence.</p>
<p><code>stdin</code> is the text ot send as the stdin of <code>cmd_line</code>.</p>
<h3 id="depend-deps--follow_symlinksfalse--verbosefalse--readfalse--criticalfalse--essentialfalse--ignorefalse--ignore_errorfalse--readdir_okfalse--requiredtrue--regexprfalse-"><a class="header" href="#depend-deps--follow_symlinksfalse--verbosefalse--readfalse--criticalfalse--essentialfalse--ignorefalse--ignore_errorfalse--readdir_okfalse--requiredtrue--regexprfalse-"><code>depend( *deps , follow_symlinks=False , verbose=False , read=False , critical=False , essential=False , ignore=False , ignore_error=False , readdir_ok=False , required=True , regexpr=False )</code></a></h3>
<p>Declare <code>deps</code> as parallel deps (i.e. no order exist between them).</p>
<p>If <code>follow_symlinks</code>, <code>deps</code> that are symbolic links are followed (and a dep is set on links themselves, independently of the passed flags that apply for the target the links).</p>
<p>Each dep is associated with an access pattern.
Accesses are of 3 kinds, regular, link and stat:</p>
<ul>
<li>Regular means that the file was accessed using C(open,2) or similar, i.e. the job is sensitive to the file content if it is a regular file, but not to the target in case it is a symbolic link.</li>
<li>Link means that the file was accessed using C(readlink,2) or similar, i.e. the job is sensitive to the target if it is a symbolic link, but not to the content in case it is a regular file.</li>
<li>Stat means that the file meta-data were accessed, i.e. the job is sensitive to file existence and type, but not to the content or its target.</li>
</ul>
<p>If a file have none of these accesses, changing it will not trigger a rebuild, but it is still a dep as in case it is in error, this will prevent the job from being run.
Making such dinstinctions is most useful for the automatic processing of symbolic links.
For example, if file <code>a/b</code> is opened for reading, and it turns out to be a symbolic link to <code>c</code>, open-lmake will set a dep to <code>a/b</code> as a link, and to <code>a/c</code>
as a link (in case it is itself a link) and regular (as it is opened).</p>
<p>By default, passed deps are associated with no access, but are required to be buildable and produced without error unless <code>readdir_ok</code> is true.
To simulate a plain access, you need to pass <code>read=True</code> to associate accesses and <code>required=False</code> to allow it not to exist.</p>
<p>If <code>verbose</code>, return a <code>dict</code> with one entry par dep where:</p>
<ul>
<li>The key is the dep name.</li>
<li>The value is a <code>dict</code> composed of:
<ul>
<li><code>ok</code>:       <code>True</code> if the dep is built with no error, <code>False</code> if the dep is built in error, <code>None</code> if the was not built.</li>
<li><code>checksum</code>: The checksum computed after the dep (unless <code>ok</code> is <code>None</code>) (cf. <code>xxhsum</code> (1)).</li>
<li><code>rule</code>:     The rule name of the job that has generated the dep one exists.</li>
<li><code>special</code>:  The special nature (e.g. <code>src</code>).</li>
<li><code>stems</code>:    A <code>dict</code> mapping stem names to stem values if the rule is a plain rule.</li>
</ul>
</li>
</ul>
<p>If <code>read</code>, report an actual read of <code>deps</code>. Default is just to alter associated flags.</p>
<p>If <code>regexpr</code>, pass flags to all deps matching <code>deps</code> interpreted as regexprs, much like the <code>side_deps</code> rule attribute.
However, the <code>ignore</code> flag only applies to deps following this call.</p>
<p>For <code>critical</code>, <code>essential</code>, <code>ignore</code>, <code>ignore_error</code>, <code>readdir_ok</code> and <code>required</code>, set the corresponding <a href="rules.html#deps">flag</a> on all <code>deps</code>:</p>
<ul>
<li>If <code>critical</code>,     create critical deps (cf. note (5)).</li>
<li>If <code>essential</code>,    passed deps will appear in the flow shown with a graphical tool.</li>
<li>If <code>ignore_error</code>, ignore the error status of the passed deps.</li>
<li>If <code>readdir_ok</code>,   <code>readdir</code> (3) can be called on passed deps without error even if not <code>ignore</code>'ed nor <code>incremental</code>.</li>
<li>If <code>not required</code>, accept that deps be not buildable, as for a normal read access (in such a case, the read may fail, but open-lmake is ok).</li>
<li>If <code>ignore</code>,       deps are ignored altogether, even if further accessed (but previous accesses are kept).</li>
</ul>
<p>Flags accumulate and are never reset.</p>
<p>Notes:</p>
<ul>
<li>(1):
The same functionality is provided with the <code>ldepend</code> executable.</li>
<li>(2):
Flags can be associated to deps on a regexpr (matching on dep name) basis by using the <code>side_deps</code> rule attribute.</li>
<li>(3):
If <code>cat a b</code> is executed, open-lmake sees 2 <code>open</code> system calls, to <code>a</code> then to <code>b</code>, exactly the same sequence that if one did <code>cat $(cat a)</code> and <code>a</code> contained <code>b</code>.<br />
Suppose now that <code>b</code> is an error. This is a reason for your job to be in error.
But if <code>a</code> is modifed, in the former case, this cannot solve the error while in the latter case, it may if the new content of <code>a</code> points to a file that may successfully be built.
Because open-lmake cannot distinguish between the 2 cases, upon a modification of <code>a</code>, the job will be rerun in the hope that <code>b</code> is not accessed any more.
Parallel deps prevents this trial.</li>
<li>(4):
If a series of files are read in a loop and the loop is written in such a way as to stop on the first error
and if the series of file does not depend on the actual content of said files,
then it is preferable to pre-access (using B(ldepend)) all files before starting the loop.
The reason is that without this precaution, deps will be discovered one by one and may be built serially instead of all of them in parallel.</li>
<li>(5):
If a series of dep is directly derived from the content of a file, it may be wise to declare it as <code>critical</code>.
When a critical dep is modified, open-lmake forgets about deps reported after it.<br />
Usually, when a file is modified, this has no influence on the list of files that are accessed after it,
and open-lmake anticipates this by building these deps speculatively.
But in some situations, it is almost certain that there will be an influence and it is preferable not to anticipate.
this is what critical deps are made for: in case of modifications, following deps are not built speculatively.</li>
</ul>
<h3 id="target-targets--writefalse--regexprfalse--allowtrue--essentialfalse--ignorefalse--incrementalfalse--no_warningfalse--source_okfalse--criticalfalse--ignore_errorfalse--readdir_okfalse--requiredfalse-"><a class="header" href="#target-targets--writefalse--regexprfalse--allowtrue--essentialfalse--ignorefalse--incrementalfalse--no_warningfalse--source_okfalse--criticalfalse--ignore_errorfalse--readdir_okfalse--requiredfalse-"><code>target( *targets , write=False , regexpr=False , allow=True , essential=False , ignore=False , incremental=False , no_warning=False , source_ok=False , critical=False , ignore_error=False , readdir_ok=False , required=False )</code></a></h3>
<p>Declare <code>targets</code> as targets and alter associated flags.
Note that the <code>allow</code> argument default value is <code>True</code>.</p>
<p>Also, calling this function does not make <code>targets</code> official targets of the job, i.e. <code>targets</code> are side targets.
The official job of a target is the one selected if needing its content, it must be known before any job is run.</p>
<p>If <code>write</code>, report that <code>targets</code> were written to.</p>
<p>If <code>regexpr</code>, pass flags to all targets matching <code>targets</code> interpreted as regexprs, much like the <code>side_targets</code> rule attribute.
However, the <code>ignore</code> flag only applies to targets following this call.</p>
<p>For <code>allow</code>, <code>essential</code>, <code>ignore</code>, <code>incremental</code>, <code>no_warning</code> and <code>source_ok</code>, set the corresponding <a href="rules.html#targets">flag</a> on all <code>targets</code>:</p>
<ul>
<li>If <code>essential</code>,   show when generating user oriented graphs.</li>
<li>If <code>incremental</code>, <code>targets</code> are not unlinked before job execution and read accesses to them are ignored.</li>
<li>If <code>no_warning</code>,  no warning is emitted if <code>targets</code> are either uniquified or unlinked while generated by another job.</li>
<li>If <code>ignore</code>,      from now on, ignore all reads and writes to <code>targets</code>.</li>
<li>If <code>not allow</code>,   do not make <code>targets</code> valid targets.</li>
<li>If <code>source_ok</code>,   accept that <code>targets</code> be sources. Else, writing to a source is an error.</li>
</ul>
<p>In case passed targets turn out to be deps, the deps flags are also available: <code>critical</code>, <code>ignore_error</code>, <code>readdir_ok</code> and <code>required</code>:</p>
<ul>
<li>If <code>critical</code>,     create critical deps (cf. note (5) of <code>depend</code>).</li>
<li>If <code>ignore_error</code>, ignore the error status of the passed deps.</li>
<li>If <code>readdir_ok</code>,   <code>readdir</code> (3) can be called on passed deps without error even if not <code>ignore</code>'ed nor <code>incremental</code>.</li>
<li>If <code>not required</code>, accept that deps be not buildable, as for a normal read access (in such a case, the read may fail, but open-lmake is ok).</li>
</ul>
<p>Flags accumulate and are never reset.</p>
<h3 id="check_depssyncfalse"><a class="header" href="#check_depssyncfalse"><code>check_deps(sync=False)</code></a></h3>
<p>Ensure that all previously seen deps are up-to-date.
Job will be killed in case some deps are not up-to-date.</p>
<p>If <code>sync</code>, wait for server reply. Return value is False if at least a dep is in error.
This is necessary, even without checking return value, to ensure that after this call,
the dirs of previous deps actually exist if such deps are not read (such as with lmake.depend).</p>
<p><strong>CAVEAT</strong></p>
<p>If used in conjonction with the <code>kill_sigs</code> attribute with a handler to manage the listed signal(s) (typically by calling <code>signal.signal(...)</code> and without <code>sync=True</code>,
and if a process is launched shortly after (typically by calling <code>subprocess.run</code> or <code>os.system</code>),
it may be that said process does not see the signal.
This is due to a race condition in I(python) when said process is just starting.</p>
<p>This may be annoying if said process was supposed to do some clean up or if it is very long.
The solution in this case is to pass <code>sync=True</code>.
This has a small cost in the general case where deps are actually up-to-date, but provides a reliable way to kill the job as <code>check_deps</code> will still be running when the signal fires up.</p>
<h3 id="get_autodep"><a class="header" href="#get_autodep"><code>get_autodep()</code></a></h3>
<p>Returns whether autodep is currently active or not.</p>
<p>By default, autodep is active.</p>
<h3 id="set_autodepactive"><a class="header" href="#set_autodepactive"><code>set_autodep(active)</code></a></h3>
<p>Set the state of autodep.</p>
<h3 id="class-autodep"><a class="header" href="#class-autodep"><code>class Autodep</code></a></h3>
<p>A context manager that encapsulates <code>set_autodep</code>.</p>
<pre><code class="language-python">with Autodep(active) :
	&lt;some code&gt;
</code></pre>
<p>executes <code>&lt;some code&gt;</code> with autodep active set as instructed.</p>
<h3 id="encode-file--ctx--val--min_length1-"><a class="header" href="#encode-file--ctx--val--min_length1-"><code>encode( file , ctx , val , min_length=1 )</code></a></h3>
<p>If a code is associated to <code>val</code> within file <code>file</code> and context <code>ctx</code>, return it.
Else a code is created, of length at least <code>min_length</code>, is associated to <code>val</code> and is return.
Cf. <a href="experimental_codec.html">encode/decode</a>.</p>
<p><code>file</code> must be a source file.</p>
<h3 id="decode-file--ctx--code-"><a class="header" href="#decode-file--ctx--code-"><code>decode( file , ctx , code )</code></a></h3>
<p>If a val is associated to <code>code</code> within file <code>file</code> and context <code>ctx</code>, return it.
Else an exception is raised.
Cf. <a href="experimental_codec.html">encode/decode</a>.</p>
<p><code>file</code> must be a source file.</p>
<p>Associations are usually created using <code>encode</code> but not necessarily (they can be created by hand).</p>
<h3 id="xxhsum_filefile"><a class="header" href="#xxhsum_filefile"><code>xxhsum_file(file)</code></a></h3>
<p>Return a checksum of provided file.</p>
<p>The checksum is :</p>
<ul>
<li>none                                         if file does not exist, is a dir or a special file</li>
<li>empty-R                                      if file is empty</li>
<li>xxxxxxxxxxxxxxxx-R (where x is a hexa digit) if file is regular and non-empty</li>
<li>xxxxxxxxxxxxxxxx-L                           if file is a symbolic link</li>
</ul>
<p>Note : this checksum is <strong>not</strong> crypto-robust.</p>
<p>Cf <code>man xxhsum</code> for a description of the algorithm.</p>
<h3 id="xxhsumtextis_linkfalse"><a class="header" href="#xxhsumtextis_linkfalse"><code>xxhsum(text,is_link=False)</code></a></h3>
<p>Return a checksum of provided text.</p>
<p>It is a 16-digit hex value with no suffix.</p>
<p>Note : the empty string lead to 0000000000000000 so as to be easily recognizable.</p>
<p>Note : this checksum is not the same as the checksum of a file with same content.</p>
<p>Note : this checksum is <strong>not</strong> crypto-robust.</p>
<p>Cf <code>man xxhsum</code> for a description of the algorithm.</p>
<h3 id="report_importmodule_namenonepathnonemodule_suffixesnone"><a class="header" href="#report_importmodule_namenonepathnonemodule_suffixesnone"><code>report_import(module_name=None,path=None,module_suffixes=None)</code></a></h3>
<p>Does necessary reporting when a module has been imported.</p>
<p><code>module_name</code> is the name of the imported module.
This function only handles the last level import, so it must be called at each level in case the module lies in a package.</p>
<p>If not provided or empty, only does the reporting due to the path, but assumes no module is accessed.</p>
<p>The way such reporting is done is by reporting a dep for each local dir in the path, for each module suffix, until the module is found, locally or externally.</p>
<p><code>path</code> is the path which the imported module is searched in.</p>
<p>If not provided or empty, it defaults to the current value of <code>sys.path</code>.</p>
<p>Unless used with python2, this function allows <code>readdir</code> accesses to local dirs in the path as python does such a <code>readdir</code>.</p>
<p><code>module_suffixes</code> is the list of suffixes to try that may provide a module, e.g. <code>('.py','/__init__.py')</code>.</p>
<p>If not provided, the default is:</p>
<ul>
<li>for python2: <code>('.so','.py','/__init__.so','/__init__.py')</code></li>
<li>for python3: <code>( i+s for s in importlib.machinery.all_suffixes() for i in ('','/__init__'))</code></li>
</ul>
<p>Note:</p>
<ul>
<li>It may be wise to specify only the suffixes actually used locally to reduce the number of deps.</li>
<li>External modules are searched with the standard suffixes, even if <code>module_suffixes</code> is provided as there is no reason for the external modules to adhere to local conventions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="the-lmakesources-module"><a class="header" href="#the-lmakesources-module">The <code>lmake.sources</code> module</a></h1>
<h3 id="manifest_sourcesmanifestmanifest"><a class="header" href="#manifest_sourcesmanifestmanifest"><code>manifest_sources(manifest='Manifest')</code></a></h3>
<p>This function returns the list of sources found in the <code>manifest</code> file, one per line.
Comments are supported as everything following a <code>#</code> itself at start of line or preceded by a space.
Leading and trailing white spaces are stripped after comment removal.</p>
<h3 id="git_sources-recursetrue--ignore_missing_submodulesfalse-"><a class="header" href="#git_sources-recursetrue--ignore_missing_submodulesfalse-"><code>git_sources( recurse=True , ignore_missing_submodules=False )</code></a></h3>
<p>This function lists files under <code>git</code> control, recursing to sub-modules if <code>recurse</code> is true and ignore missing such sub-modules if <code>ignore_missing_submodules</code> is true.</p>
<p>The <code>git</code> repo can be an enclosing dir of the open-lmake repo.
In that case, sources are adequately set to track <code>git</code> updates.</p>
<h3 id="auto_sourceskwds"><a class="header" href="#auto_sourceskwds"><code>auto_sources(**kwds)</code></a></h3>
<p>This function tries to find sources by calling <code>manifest_sources</code> and <code>git_sources</code> in turn, untill one succeeds.
Arguments are passed as pertinent.</p>
<p>In absence of source declaration, this function is called with no argument to determine the sources.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="the-lmakerules-module"><a class="header" href="#the-lmakerules-module">The <code>lmake.rules</code> module</a></h1>
<h2 id="base-rules"><a class="header" href="#base-rules">Base rules</a></h2>
<h3 id="class-rule"><a class="header" href="#class-rule"><code>class Rule</code></a></h3>
<p>Base class for plain rules.</p>
<p>A class becomes a rule when:</p>
<ul>
<li>it inherits, directly or indirectly, from <code>Rule</code></li>
<li>it has a <code>target</code> or <code>targets</code> attribute</li>
<li>it has a <code>cmd</code> attribute</li>
</ul>
<h3 id="class-antirule"><a class="header" href="#class-antirule"><code>class AntiRule</code></a></h3>
<p>Base class for anti-rules.</p>
<p>A class becomes an anti-rule when:</p>
<ul>
<li>it inherits, directly or indirectly, from <code>AntiRule</code></li>
<li>it has a <code>target</code> or <code>targets</code> attribute</li>
</ul>
<p>An anti-rule has no cmd nor deps.</p>
<p>It applies to a file as soon as it matches one of the targets.
In that case, the file is deemed unbuildable.</p>
<h3 id="class-sourcerule"><a class="header" href="#class-sourcerule"><code>class SourceRule</code></a></h3>
<p>Base class for source-rules.</p>
<p>A class becomes a source-rule when:</p>
<ul>
<li>it inherits, directly or indirectly, from <code>SourceRule</code></li>
<li>it has a <code>target</code> or <code>targets</code> attribute</li>
</ul>
<p>A source-rule has no cmd nor deps.</p>
<p>It applies to a file as soon as it matches one of the targets.
In that case, the file is deemed to be a source.</p>
<p>If such a file is required and does not exist, it is an error condition.</p>
<h2 id="helper-rules"><a class="header" href="#helper-rules">Helper rules</a></h2>
<h3 id="class-py2rulerule-class-py3rulerule-and-class-pyrulerule"><a class="header" href="#class-py2rulerule-class-py3rulerule-and-class-pyrulerule"><code>class Py2Rule(Rule)</code>, <code>class Py3Rule(Rule)</code> and <code>class PyRule(Rule)</code></a></h3>
<p>These classes may be used as base class for rules that execute python code doing imports.</p>
<p>It manages <code>.pyc</code> files.
Also, it provides deps to module source files although python may optimize such accesses and miss deps on dynamically generated modules.</p>
<p>If <code>cmd</code> is not a function, and python is called, this last feature is provided if <code>lmake.import_machinery.fix_import</code> is called.</p>
<p>Py2Rule is used for python2, Py3Rule is used for python3. PyRule is an alias for Py3Rule.</p>
<h3 id="class-rustrulerule"><a class="header" href="#class-rustrulerule"><code>class RustRule(Rule)</code></a></h3>
<p>This class may be used as a base class to execute executable written in rust.</p>
<p>Rust uses a special link mechanism which defeats the default <code>ld_audit</code> autodep mechanism.
This base class merely sets the autodep method to <code>ld_preload</code> which works around this problem.</p>
<h3 id="class-homelessrulerule"><a class="header" href="#class-homelessrulerule"><code>class HomelessRule(Rule)</code></a></h3>
<p>This class sets <code>$HOME</code> to <code>$TMPDIR</code>.
This is a way to ensure that various tools behave the same way as if they were run for the first time.
By default <code>$HOME</code> points to the root of the repo, which permits to put various init code there.</p>
<h3 id="class-tracerulerule"><a class="header" href="#class-tracerulerule"><code>class TraceRule(Rule)</code></a></h3>
<p>This class sets the <code>-x</code> flag for shell rules and manage so that traces are sent to stdout rather than stderr.</p>
<p>This allow to suppress the common idiom:</p>
<pre><code class="language-bash">echo complicated_command
complicated_command
</code></pre>
<h3 id="class-dirtyrulerule"><a class="header" href="#class-dirtyrulerule"><code>class DirtyRule(Rule)</code></a></h3>
<p>This class may be used to ignore all writes that are not an official target.</p>
<p>By itself, it is a dangerous class and must be used with care.
It is meant to be a practical way to do trials without having to work out all the details, but in a finalized workflow, it is better to avoid the usage of this class.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="the-lmakeimport_machinery-module"><a class="header" href="#the-lmakeimport_machinery-module">The <code>lmake.import_machinery</code> module</a></h1>
<h3 id="fix_import"><a class="header" href="#fix_import"><code>fix_import()</code></a></h3>
<p>This should be called before importing any module that may be dynamically generated.</p>
<p>It updates the import mechanism to ensure that a dep is set to the source file when importing a module, even if such source file does not exist (yet).
Without fix, when a statement <code>import foo</code> is executed, although <code>foo.py</code> is read if it exists, python does not attempt to access it if it does not exist.
This is embarassing if <code>foo.py</code> is dynamically produced as initially, it does not exist and if no attempt is made to access it, there will be no dep on it and it will not be built.</p>
<h3 id="module_suffixes"><a class="header" href="#module_suffixes"><code>module_suffixes</code></a></h3>
<p>This variable holds the list of suffixes used to generate deps when importing a module and <code>lmake.import_machinery.fix_import()</code> has been called.</p>
<p>It is better to reduce this list to what is really needed in you flow, i.e. the list of suffixes used for generated python modules
(modules that are sources are not concerned by this list and deps to them will be accurate in all cases).
Reducing this list avoids useless deps.</p>
<p>The default value is the full standard list,
e.g. <code>('/__init__.cpython-312-x86_64-linux-gnu.so','/__init__.abi3.so','/__init__.so','/__init__.py','.cpython-312-x86_64-linux-gnu.so','.abi3.so','.so','.py')</code>
for python3.12 running on Linux with a x86_64 processor architecture.</p>
<p>This standard list is constructed as follows:</p>
<ul>
<li>Call <code>importlib.machinery.all_suffixes()</code>.</li>
<li>Reorder to put suffixes ending with <code>.so</code> before those ending in <code>.py</code> to match actual python try order.</li>
<li>Then use 2 copies of this list, the first one being prefixed with <code>/__init__</code> for each entry (again, python gives priority to packages over leaf modules).</li>
</ul>
<p>Reasonable values could be:</p>
<ul>
<li><code>('/__init__.so','/__init__.py','.so','.py')</code> if compiled packages and modules are used locally.</li>
<li><code>('/__init__.py','.py')</code>                      if no modules nor packages are compiled.</li>
<li><code>('.py',)</code>                                    if no packages is used locally nor modules compiled.</li>
</ul>
<p>Note that the management of <code>.pyc</code> files is independent.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="writing-lmakefilepy"><a class="header" href="#writing-lmakefilepy">Writing <code>Lmakefile.py</code></a></h1>
<p><code>Lmakefile.py</code> contains 3 sections:</p>
<ul>
<li>config, (some global information)</li>
<li>sources, (the list of sources)</li>
<li>rules, (the list of rules)</li>
</ul>
<p>When reading <code>Lmakefile.py</code>, open-lmake:</p>
<ul>
<li>imports <code>Lmakefile</code></li>
<li>for each section (config, sources, rules):
<ul>
<li>if there is a callable with this name, call it</li>
<li>if there is a sub-module with this name, import it</li>
</ul>
</li>
</ul>
<p>The advantage of declaring a function or a sub-module for each section is that in case something is modified, only the impacted section is re-read.</p>
<h2 id="the-config"><a class="header" href="#the-config">The config</a></h2>
<p>The config is determined by setting the variable <code>lmake.config</code>.
Because it is predefined with all default values, it is simpler to only define fields.
A typical <code>Lmakefile.py</code> will then contain lines such as:</p>
<pre><code class="language-python">lmake.config.path_max = 500 # default is 400
</code></pre>
<p><a href="../../lib/lmake/config.py">lib/lmake/config.py</a> can be used as a handy helper as it contains all the fields with a short comment.</p>
<h2 id="the-sources"><a class="header" href="#the-sources">The sources</a></h2>
<p>The sources are determined by setting the variable <code>lmake.manifest</code>.</p>
<p>Sources are files that are deemed as intrinsic.
They cannot be derived using rules as explained in the following section.</p>
<p>Also, if a file cannot be derived and is not a source, it is deemed unbuildable, even if it actually exists.
In this latter case, it will be considered dangling and this is an error condition.
The purpose of this restriction is to ensure repeatability : all buildable files can be (possibly indirectly) derived from sources using rules.</p>
<p><code>lmake.manifest</code> can contain :</p>
<ul>
<li>Files located in the repo</li>
<li>Dirs (ending with <code>/</code>), in which case:
<ul>
<li>The whole subtree underneath the dir are considered sources.</li>
<li>They may be inside the repo or outside, but cannot contain or lie within system dirs such as <code>/usr</code>, <code>/proc</code>, <code>/etc</code>, etc.</li>
<li>If outside, they can be relative or absolute.</li>
</ul>
</li>
</ul>
<p>In both cases, names must be canonical, i.e. contain no empty component nor <code>.</code>, nor <code>..</code> except initially for relative names outside repo.</p>
<p>The helper functions defined in <a href="../../lib/lmake/sources.py">lib/lmake/sources.py</a> can be used and if nothing is said, <code>auto_sources()</code> is called.</p>
<h2 id="the-rules"><a class="header" href="#the-rules">The rules</a></h2>
<p>Rules are described as python <code>class</code>'es inheriting from <code>lmake.Rule</code>, <code>lmake.AntiRule</code> or <code>lmake.SourceRule</code>.</p>
<p>Such classes are either defined directly in <code>Lmakefile.py</code> or you can define a callable or a sub-module called <code>rules</code> that does the same thing when called/imported.
For example you can define :</p>
<pre><code class="language-python">def rules() :
	class MyRule(lmake.Rule) :
		target = 'my_target'
		cmd    = ''
</code></pre>
<p>Or the sub-module <code>Lmakefile.rules</code> containing such class definitions.</p>
<p>Inheriting from <code>lmake.Rule</code> is used to define production rules that allows deriving targets from deps.</p>
<p>Inheriting from <code>lmake.AntiRule</code> is (rarely) used to define rules that specify that matching targets <strong>cannot</strong> be built.
Anti-rules only require the <code>targets</code> attribute (or those that translate into it, <code>target</code>) and may usefully have a <code>prio</code> attribute.
Other ones are useless and ignored.</p>
<p>Inheriting from <code>lmake.SourceRule</code> may be used to define sources by patterns rather than as a list of files controlled by some sort of source-control (typically <code>git</code>).</p>
<h3 id="special-rules"><a class="header" href="#special-rules">Special rules</a></h3>
<p>In addition to user rules defined as described hereinafter, there are a few special rules:</p>
<ul>
<li>Uphill:
Any file depends on its dir in a special way : if its dir is buildable, then the file is not.
This is logical : if file <code>foo</code> is buildable (i.e. produced as a regular file or a symbolic link), there is not way file <code>foo/bar</code> can be built.
If <code>foo</code> is produced as a regular file, this is the end of the story.
If it is produced as a symbolic link (say with <code>foo_real</code> as target), the dependent job will be rerun and it will then depend on <code>foo</code> and <code>foo_real/bar</code> when it opens <code>foo/bar</code>.
Note that if the dir applies as the star-target of a rule, then the corresponding job must be run to determine if said dir is, indeed, produced.</li>
<li>Infinite:
If walking the deps leads to infinite recursion, when the depth reaches <code>lmake.config.max_dep_depth</code>, this special rule is triggered which generates an error.
Also, if a file whose name is longer that <code>lmake.config.path_max</code> considered, it is deemed to be generated by this rule and it is in error.
This typically happens if you have a rule that, for example builds <code>{File}</code> from <code>{File}.x</code>.
If you try to build <code>foo</code>, open-lmake will try to build <code>foo.x</code>, which needs <code>foo.x.x</code>, which needs <code>foo.x.x.x</code> etc.</li>
</ul>
<h3 id="dynamic-values"><a class="header" href="#dynamic-values">Dynamic values</a></h3>
<p>Most attributes can either be data of the described type or a function taking no argument returning the desired value.
This allows the value to be dynamically selected depending on the job.</p>
<p>Such functions are evaluated in an environment in which the stems (as well as the <code>stems</code> variable which is a <code>dict</code> containing the stems
and the targets (as well as the <code>targets</code> variable) are defined and usable to derive the return value.
Also, depending on the attribute, the deps (as well as the <code>deps</code> variable) and the resources (as well as the <code>resources</code> variable) may also be defined.
Whether or not these are available depend on when a given attribute is needed.
For example, when defining the <code>deps</code>, the deps are obviously not available.</p>
<p>For composite values (dictionaries or sequences), the entire value may be a function or each value can individually be a function (but not the keys).
For dictionaries, if the value function returns <code>None</code>, there will be no corresponding entry in the resulting dictionary.</p>
<p>Note that regarding resources available in the function environment, the values are the ones instantiated by the backend.</p>
<h3 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h3>
<p>python's native inheritance mechanism is not ideal to describe a rule as one would like to prepare a base <code>class</code> such as:</p>
<ul>
<li>provide environment variables</li>
<li>provide some default actions for some files with given pattern</li>
<li>provide some automatic deps</li>
<li>...</li>
</ul>
<p>As these are described with <code>dict</code>, you would like to inherit <code>dict</code> entries from the base <code>class</code> and not only the <code>dict</code> as a whole.
A possibility would have been to use the <code>__prepare__</code> method of a meta-class to pre-define inherited values of such attributes,
but that would defeat the practical possibility to use multiple inheritance by suppressing the diamond rule.</p>
<p>The chosen method has been designed to walk through the MRO at class creation time and:</p>
<ul>
<li>Define a set of attributes to be handled through combination. This set is defined by the attribute <code>combine</code>, itself being handled by combination.</li>
<li>Combined attribute are handled by updating/appending rather than replacing when walking through MRO in reverse order.</li>
<li>Entries with a value None are suppressed as update never suppress a given entry.
Similarly, values inserted in a set prefixed with a <code>'-'</code> remove the corresponding value from the <code>set</code>.</li>
</ul>
<p>Because this mechanism walks through the MRO, the diamond rule is enforced.</p>
<p><code>dict</code>'s and <code>list</code>'s are ordered so that the most specific information appear first, as if classes are searched in MRO.</p>
<p>Combined attributes may only be <code>dict</code>, <code>set</code> and <code>list</code>:</p>
<ul>
<li><code>dict</code>'s and <code>set</code>'s are <code>update</code>d, <code>list</code>'s are <code>append</code>ed.</li>
<li><code>dict</code>'s and <code>list</code>'s are ordered in MRO, base classes being after derived classes.</li>
</ul>
<h4 id="paths"><a class="header" href="#paths">paths</a></h4>
<p>Some environment variables contain paths, such as <code>$PATH</code>.</p>
<p>When such an entry appears in a rule, its value is searched for occurrences of the special marker <code>...</code> surrounded by separators (the start and end of the strings are deemed to be separators)
And each such occurrence is replaced by the inherited value.</p>
<p>This makes it particularly useful to manage paths as it allows any intermediate base <code>class</code> to add its own entries, before or after the original ones.</p>
<p>For example, to add the dir <code>/mypath</code> after the inherited path, one would define the attribute <code>environ</code> as <code>{'PATH':'...:/mypath'}</code>.
To add it before, one would use <code>{'PATH':'/mypath:...'}</code>.</p>
<p>Entries going through this step are provided by the attribute <code>paths</code>, which is a dict with <attribute>.<key> as keys and <separator> as values.
The default value is <code>{ 'environ.PATH':':' , 'environ.LD_LIBRARY_PATH':':' , 'environ.MANPATH':':' , 'environ.PYTHONPATH':':' }</code></p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="config-fields"><a class="header" href="#config-fields">Config fields</a></h1>
<p>Depending on when each field can be modified, they are said:</p>
<ul>
<li>Clean : requires a fresh repo to change this value</li>
<li>Static : requires that no <code>lmake</code> is running to change this value</li>
<li>Dynamic : field can be changed any time.</li>
</ul>
<p>The default value is mentioned in ().</p>
<h3 id="disk_date_precision--static-0010"><a class="header" href="#disk_date_precision--static-0010"><code>disk_date_precision</code> : Static (<code>0.010</code>)</a></h3>
<p>This attribute instruct open-lmake to take some margin (expressed in seconds) when it must rely on file dates to decide about event orders.
It must account for file date granularity (generally a few ms) and date discrepancy between executing hosts and disk servers (generally a few ms when using NTP).</p>
<ul>
<li>If too low, there are risks that open-lmake consider that data read by a job are up to date while they have been modified shortly after.</li>
<li>If too high, there is a small impact on performance as open-lmake will consider out of date data that are actually up to date.</li>
</ul>
<p>The default value should be safe in usual cases and user should hardly need to modify it.</p>
<h3 id="heartbeat--static-10"><a class="header" href="#heartbeat--static-10"><code>heartbeat</code> : Static (<code>10</code>)</a></h3>
<p>Open-lmake has a heartbeat mechanism to ensure a job does not suddenly disappear (for example if killed by the user, or if a remote host reboots).
If such an event occurs, the job will be restarted automatically.</p>
<p>This attribute specifies the minimum time between 2 successive checks for a given job.
If <code>None</code> (discouraged), the heartbeat mechanism is disabled.</p>
<p>The default value should suit the needs of most users.</p>
<ul>
<li>If too low, build performance will decrease as heartbeat will take significative resources</li>
<li>If too high, reactivity in case of job loss will decrease</li>
</ul>
<h3 id="heartbeat_tick--static-01"><a class="header" href="#heartbeat_tick--static-01"><code>heartbeat_tick</code> : Static (<code>0.1</code>)</a></h3>
<p>Open-lmake has a heartbeat mechanism to ensure a job does not suddenly disappear (for example if killed by the user, or if a remote host reboots).
If such an event occurs, the job will be restarted automatically.</p>
<p>This attribute specifies the minnimum time between 2 successive checks globally for all jobs.
If <code>None</code> (discouraged), it is equivalent to 0.</p>
<p>The default value should suit the needs of most users.</p>
<ul>
<li>If too low, build performance will decrease as heartbeat will take significative resources</li>
<li>If too high, reactivity in case of job loss will decrease</li>
</ul>
<h3 id="local_admin_dir--clean--"><a class="header" href="#local_admin_dir--clean--"><code>local_admin_dir</code> : Clean (-)</a></h3>
<p>This variable contains a dir to be used for open-lmake administration in addition to the <code>LMAKE</code> dir.</p>
<p>It is guaranteed that all such accesses are performed by the host, hence a dir in a locally mounted disk is fine.</p>
<ul>
<li>If unset, administration by user is simplified (no need to manage an external dir), but there may be a performance impact as network file systems are generally slower than local ones.</li>
<li>If set to a local dir, user has to ensure that <code>lmake</code> and other commands are always launched from the host that has this locaol file system.</li>
<li>If set to network dir, there is no performance gain and only added complexity.</li>
</ul>
<h3 id="link_support--clean-full"><a class="header" href="#link_support--clean-full"><code>link_support</code> : Clean (<code>'full'</code>)</a></h3>
<p>Open-lmake fully handle symbolic links (cf <a href="data_model.html">data model</a>).</p>
<p>However, there is an associated cost which may be useless in some situations.</p>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Support level</th></tr></thead><tbody>
<tr><td><code>'full'</code></td><td>symbolic links are fully supported</td></tr>
<tr><td><code>'file'</code></td><td>symbolic links are only supported if pointing to files</td></tr>
<tr><td><code>'none'</code></td><td>symbolic links are not supported</td></tr>
</tbody></table>
</div>
<h3 id="max_dep_depth-static-100"><a class="header" href="#max_dep_depth-static-100"><code>max_dep_depth</code>: Static (<code>100</code>)</a></h3>
<p>The <a href="rule_selection.hml">rule selection</a> process is a recursive one.
It is subject to infinite recursion and several means are provided to avoid it.</p>
<p>The search stops if the depth of the search reaches the value of this attribute, leading to the selection of a special internal rule called <code>infinite</code>.</p>
<ul>
<li>If too low, some legal targets may be considered infinite.</li>
<li>If too high, the error message in case of infinite recursion will be more verbose.</li>
</ul>
<h3 id="max_error_lines--dynamic-100"><a class="header" href="#max_error_lines--dynamic-100"><code>max_error_lines</code> : Dynamic (<code>100</code>)</a></h3>
<p>When a lot of error lines are generated by open-lmake, other than copying the <code>stderr</code> of a job, only the first <code>max_error_lines</code> ones are actually output,
followed by a line containing <code>...</code> if some lines have been suppressed.
The purpose is to ease reading.</p>
<h3 id="network_delay--static-1"><a class="header" href="#network_delay--static-1"><code>network_delay</code> : Static (<code>1</code>)</a></h3>
<p>This attribute provides an approximate upper bound of the time it takes for an event to travel from a host to another.</p>
<ul>
<li>If too low, there may be spurious lost jobs.</li>
<li>If too high, there may be a loss of reactivity.</li>
</ul>
<p>The default value should fit most cases.</p>
<h3 id="path_max--static-200"><a class="header" href="#path_max--static-200"><code>path_max</code> : Static (<code>200</code>)</a></h3>
<p>The <a href="rule_selection.html">rule selection</a> process is a recursive one.
It is subject to infinite recursion and several means are provided to avoid it.</p>
<p>The search stops if any file with a name longer than the value of this attribute, leading to the selection of a special internal rule called <code>infinite</code>.</p>
<h3 id="file_sync--static-dir-if-non-local-backends-are-used-else-none"><a class="header" href="#file_sync--static-dir-if-non-local-backends-are-used-else-none"><code>file_sync</code> : Static (<code>'dir'</code> if non-local backends are used, else <code>None</code>)</a></h3>
<p>This attribute specifies how to ensure file synchronization when a file is produced by a host and read by another one.</p>
<p>Possible values are:</p>
<ul>
<li><code>'none'</code> or <code>None</code>: the filesystem is deemed reliable an no further protection is needed.</li>
<li><code>'dir'</code>: the enclosing dir (and recursively up-hill) of a file is closed after any write (or creation or removal) and open before any read.</li>
<li><code>'sync'</code>: <code>fsync</code> is called on file after any write.</li>
</ul>
<p>Recommanded values for known file systems:</p>
<div class="table-wrapper"><table><thead><tr><th>File system</th><th><code>file_sync</code></th></tr></thead><tbody>
<tr><td>NFS</td><td><code>'dir'</code></td></tr>
<tr><td>CEPH</td><td><code>None</code></td></tr>
</tbody></table>
</div>
<p>The expected performance impact is increasing in this order : <code>None</code>, <code>'dir'</code>, <code>'sync'</code>.
The expected reliability order is the reverse one.</p>
<h3 id="sub_repos--static-"><a class="header" href="#sub_repos--static-"><code>sub_repos</code> : Static (<code>()</code>)</a></h3>
<p>This attribute provide the list of sub-repos.</p>
<p>Sub repos are sub-dirs of the repo that are themselves repos, i.e. they have a <code>Lmakefile.py</code>.
Inside such sub-repos, the applied flow is the one described in it (cf <a href="experimental_subrepos.html">Subrepos</a>).</p>
<h3 id="consoledate_precision--dynamic-none"><a class="header" href="#consoledate_precision--dynamic-none"><code>console.date_precision</code> : Dynamic (<code>None</code>)</a></h3>
<p>This attribute specifies the precision (as the number of digit after the second field, for example 3 means we see milli-seconds) with which timestamps are generated on the console output.
If <code>None</code>, no timestamp is generated.</p>
<h3 id="consolehas_exec_time--dynamic-true"><a class="header" href="#consolehas_exec_time--dynamic-true"><code>console.has_exec_time</code> : Dynamic (<code>True</code>)</a></h3>
<p>If this attribute is true, execution time is reported each time a job is completed.</p>
<h3 id="consolehistory_days--dynamic-7"><a class="header" href="#consolehistory_days--dynamic-7"><code>console.history_days</code> : Dynamic (<code>7</code>)</a></h3>
<p>This attribute specifies the number of days the output log history is kept in the <code>LMAKE/outputs</code> dir.</p>
<h3 id="consolehost_len--dynamic-none"><a class="header" href="#consolehost_len--dynamic-none"><code>console.host_len</code> : Dynamic (<code>None</code>)</a></h3>
<p>This attribute specifies the width of the field showing the host that executed or is about to execute the job.
If <code>None</code>, the host is not shown.
Note that no host is shown for local execution.</p>
<h3 id="consoleshow_eta--dynamic-false"><a class="header" href="#consoleshow_eta--dynamic-false"><code>console.show_eta</code> : Dynamic (<code>False</code>)</a></h3>
<p>If this attribute is true, the title shows the ETA of the command, in addition to statistics about number of jobs.</p>
<h3 id="consoleshow_ete--dynamic-true"><a class="header" href="#consoleshow_ete--dynamic-true"><code>console.show_ete</code> : Dynamic (<code>True</code>)</a></h3>
<p>If this attribute is true, the title shows the ETE of the command, in addition to statistics about number of jobs.</p>
<h3 id="tracesize--static-100_000_000"><a class="header" href="#tracesize--static-100_000_000"><code>trace.size</code> : Static (<code>100_000_000</code>)</a></h3>
<p>While open-lmake runs, it may generate an execution trace recording a lot of internal events meant for debugging purpose.</p>
<p>The trace is handled as a ring buffer, storing only the last events when the size overflows.
The larger the trace, the more probable the root cause of a potential problem is still recorded, but the more space it takes on disk.</p>
<p>This attributes contains the maximum size this trace can hold (open-lmake keeps the 5 last traces in case the root cause lies in a previous run).</p>
<h3 id="tracen_jobs--static-1000"><a class="header" href="#tracen_jobs--static-1000"><code>trace.n_jobs</code> : Static (<code>1000</code>)</a></h3>
<p>While open-lmake runs, it generates execution traces for all jobs.</p>
<p>This attributes contains the overall number of such traces that are kept.</p>
<h3 id="tracechannels--static-all"><a class="header" href="#tracechannels--static-all"><code>trace.channels</code> : Static (all)</a></h3>
<p>The execution trace @lmake generates is split into channels to better control what to trace.</p>
<p>This attributes contains a <code>list</code> or <code>tuple</code> of the channels to trace.</p>
<h3 id="colors--dynamic-reasonably-readable"><a class="header" href="#colors--dynamic-reasonably-readable"><code>colors</code> : Dynamic (reasonably readable)</a></h3>
<p>Open-lmake generate colorized output if it is connected to a terminal (and if it understands the color escape sequences) (cf <a href="video_mode.html">video-mode</a>).</p>
<p>This attribute is a <code>pdict</code> with one entry for each symbolic color.
Each entry is a 2-tuple of 3-tuple's.
The first 3-tuple provides the color in normal video mode (black/white) and the second one the color in reverse video (white/black).
Each color is a triplet RGB of values between 0 and 255.</p>
<h3 id="backends--dynamic"><a class="header" href="#backends--dynamic"><code>backends</code> : Dynamic</a></h3>
<p>This attribute is a <code>pdict</code> with one entry for each active backend (cf <a href="backends.html">backends</a>).</p>
<p>Each entry is a <code>pdict</code> providing resources. Such resources are backend specific.</p>
<h3 id="backendsinterface--dynamic-best-guess"><a class="header" href="#backendsinterface--dynamic-best-guess"><code>backends.*.interface</code> : Dynamic (best guess)</a></h3>
<p>When jobs are launched remotely, they must connect to open-lmake when they start and when they complete.
The same is true if the job is launche locally but it launches sub-commands remotely (in this case it is the command that needs to connect to the job trampoline).
This is done by connecting to a socket open-lmake has opened for listening, which requires that we must have a means to determine an IP address to connect to.
The host running open-lmake may have several network interfaces, one of them (typically only one) being usable by such remote hosts.
There is no generic way to determine this address, so in general, open-lmake cannot determine it automatically.</p>
<p>This value may be empty (using <code>hostname</code> for addresse look up), given in standard dot notation, as the name of an interface (as shown by <code>ifconfig</code>)
or the name of a host (looked up as for <code>ping</code>).
In case of ambiguity, local backend will use the loop-back address, remote backends will generate an error message showing the possible choices.</p>
<h3 id="backendsenviron--dynamic-"><a class="header" href="#backendsenviron--dynamic-"><code>backends.*.environ</code> : Dynamic (<code>{}</code>)</a></h3>
<p>Environment to pass when launching job in backend.
This environment is accessed when the value mentioned in the rule is <code>...</code>.</p>
<h3 id="backendslocalcpu--dynamic-number-of-phyical-cpus"><a class="header" href="#backendslocalcpu--dynamic-number-of-phyical-cpus"><code>backends.local.cpu</code> : Dynamic (number of phyical CPU's)</a></h3>
<p>This is a normal resource that rules can require (by default, rule require 1 cpu).</p>
<h3 id="backendslocalmem--dynamic-size-of-physical-memory-in-mb"><a class="header" href="#backendslocalmem--dynamic-size-of-physical-memory-in-mb"><code>backends.local.mem</code> : Dynamic (size of physical memory in MB)</a></h3>
<p>This is the pysical memory necessary for jobs.
It can be specified as a number or a string representing a number followed by a standard suffix such as <code>k</code>,  <code>M</code> or <code>G</code>.
Internally, the granularity is forced to MB.</p>
<h3 id="backendslocaltmp--dynamic-0"><a class="header" href="#backendslocaltmp--dynamic-0"><code>backends.local.tmp</code> : Dynamic (<code>0</code>)</a></h3>
<p>This is the disk size in the temporary dir necessary for jobs.
It can be specified as a number or a string representing a number followed by a standard suffix such as <code>k</code>,  <code>M</code> or <code>G</code>.
Internally, the granularity is forced to MB.</p>
<h3 id="caches--static"><a class="header" href="#caches--static"><code>caches</code> : Static</a></h3>
<p>This attribute is a <code>pdict</code> with one entry for each cache.</p>
<p>Caches are named with an arbitrary <code>str</code> and are referenced in rules using this name.</p>
<p>By default, no cache is configured, but an example can be found in <a href="../../lib/lmake/config.py">lib/lmake/config.py</a>, commented out.</p>
<h3 id="cachestag--static--"><a class="header" href="#cachestag--static--"><code>caches.*.tag</code> : Static (-)</a></h3>
<p>This attribute specifies the method used by open-lmake to cache values.
In the current version, only 2 tags may be used:</p>
<ul>
<li><code>none</code> is a fake cache that cache nothing.</li>
<li><code>dir</code> is a cache working without daemon, data are stored in a dir.</li>
</ul>
<h3 id="cachesdirdir--static"><a class="header" href="#cachesdirdir--static"><code>caches.&lt;dir&gt;.dir</code> : Static</a></h3>
<p>This attribute specifies the dir in which the cache puts its data.</p>
<p>The dir must pre-exist and contain a file <code>LMAKE/size</code> containing the size the cache may occupy on disk.
The size may be suffixed by a unit suffix (<code>k</code>, <code>M</code>, <code>G</code>, <code>T</code>, <code>P</code> or <code>E</code>). These refer to base 1024.</p>
<h3 id="cachesdirfile_sync--static-dir"><a class="header" href="#cachesdirfile_sync--static-dir"><code>caches.&lt;dir&gt;.file_sync</code> : Static (<code>'dir'</code>)</a></h3>
<p>Same meaning as <code>config.file_sync</code> for accesses in the cache.</p>
<h3 id="cachesdirgroup--static-default-group-of-user"><a class="header" href="#cachesdirgroup--static-default-group-of-user"><code>caches.&lt;dir&gt;.group</code> : Static (default group of user)</a></h3>
<p>This attribute specifies the group used when creating entries.</p>
<h3 id="cachesdirkey--static-repo-root-dirgit-sha1"><a class="header" href="#cachesdirkey--static-repo-root-dirgit-sha1"><code>caches.&lt;dir&gt;.key</code> : Static (repo root dir/git sha1)</a></h3>
<p>A key used to avoid cache pollution.
No more than a single entry can be stored for any job with a given key.</p>
<p>By default, it is made after the absolute root dir of the repo and the current git sha1 if repo is controlled by git.</p>
<h3 id="debug"><a class="header" href="#debug"><code>debug</code></a></h3>
<p>When <code>ldebug</code> is used, it consults this <code>dict</code>.</p>
<p>It maps debug keys to modules to import to implement the debug method (cf man ldebug).
Values contain the module name optionnaly followed by a human description (that will appear with <code>ldebug -h</code>) separated with spaces.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="rule-attributes"><a class="header" href="#rule-attributes">Rule attributes</a></h1>
<p>Each attribute is characterized by a few flags:</p>
<ul>
<li>How inheritance is handled:
<ul>
<li>None: (ignore values from base classes)</li>
<li>python: (normal python processing)</li>
<li>Combine: (Combine inherited values and currently defined one).</li>
</ul>
</li>
<li>The type.</li>
<li>The default value.</li>
<li>Whether it can be defined dynamically from job to job:
<ul>
<li>No</li>
<li>Simple: globals include module globals, user attributes, stems and targets, no file access allowed.</li>
<li>Full:   globals include module globals, user attributes, stems, targets, deps and resources, file accesses become deps.</li>
</ul>
</li>
</ul>
<p>When targets are allowed in dynamic values, the <code>targets</code> variable is also defined as the <code>dict</code> of the targets.
Also, if <code>target</code> was used to redirect stdout, the <code>target</code> variable contains said file name.</p>
<p>Similarly, when deps are allowed in dynamic values, the <code>deps</code> variable is also defined as the <code>dict</code> of the deps.
Also, if <code>dep</code> was used to redirect stdin, the <code>dep</code> variable contains said file name.</p>
<p>When a type is mentioned as <code>f-str</code>, it means that although written as plain <code>str</code>, they are dynamically interpreted as python f-strings, as for dynamic values.
This is actually a form of dynamic value.</p>
<h1 id="dynamic-attribute-execution"><a class="header" href="#dynamic-attribute-execution">Dynamic attribute execution</a></h1>
<p>If the value of an attribute (other than <code>cmd</code>) is dynamic, it is interpreted within open-lmake, not as a separate process as for the execution of cmd.
This means:</p>
<ul>
<li>Such executions are not parallelized, this has a performance impact.</li>
<li>They are executed within a single python interpreter, this implies restrictions.</li>
</ul>
<p>Overall, these functions must be kept as simple and fast as possible, in favor of <code>cmd</code> which is meant to carry out heavy computations.</p>
<p>The restrictions are the following:</p>
<ul>
<li>The following system (or libc) calls are forbidden (trying to execute any of these results in an error):
<ul>
<li>changing dir (<code>chdir</code> and the like)</li>
<li>spawning processes (fork and the like)</li>
<li>exec (execve and the like)</li>
<li>modifying the disk (open for writing and the like)</li>
</ul>
</li>
<li>The environment variables cannot be tailored as is the case with cmd execution (there is no <code>environ</code> attribute as there is for <code>cmd</code>).</li>
<li>Modifying the environment variables (via setenv and the like) is forbidden (trying to execute any of these results in an error).</li>
<li>Altering imported modules is forbidden (e.g. it is forbidden to write to <code>sys.path</code>).
<ul>
<li>Unfortunately, this is not checked.</li>
<li><code>sys.path</code> is made  <code>tuple</code> though, so that common calls such as <code>sys.path.append</code> will generate an error.</li>
</ul>
</li>
<li><code>sys.path</code> is sampled after having read <code>Lmakefile.py</code> (while reading rules) and local dirs are filtered out. There are no means to import local modules.</li>
<li>However, reading local files is ok, as long as <code>sys.modules</code> is not updated.</li>
<li>There is no containers, as for <code>cmd</code> execution (e.g. no <code>repo_view</code>).</li>
<li>execution is performed in the top-level root dir.
<ul>
<li>This means that to be used as a sub-repo, all local file accesses must be performed with the sub-repo prefix.</li>
<li>This prefix can be found in <code>lmake.sub_repo</code>, which contains <code>.</code> for the top-level repo.</li>
</ul>
</li>
</ul>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<h3 id="name"><a class="header" href="#name"><code>name</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>None</td><td><code>str</code></td><td><code>cls.__name__</code></td><td>No</td><td></td></tr>
</tbody></table>
</div>
<p>This attribute specify a name for the rule.
This name is used each time open-lmake needs to mention the rule in a message.</p>
<p>All rules must have a unique name.
Usually, the default value is fine, but you may need to set a name, for example:</p>
<pre><code class="language-python">for ext in ('c','cc'):
	class Compile(Rule):
		name    = f'compile {ext}'
		targets = { 'OBJ' : '{File:.*}.o' }
		deps    = { 'SRC' : f'{{File}}.{ext}' }
		cmd     = 'gcc -c -o {OBJ} {SRC}'
</code></pre>
<h3 id="virtual"><a class="header" href="#virtual"><code>virtual</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>None</td><td><code>bool</code></td><td><code>False</code></td><td>No</td><td><code>True</code></td></tr>
</tbody></table>
</div>
<p>When this attribute is true, this <code>class</code> is not a rule even if it has the required target &amp; cmd attributes.
In that case, it is only used as a base class to define other rules.</p>
<h3 id="prio"><a class="header" href="#prio"><code>prio</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>float</code></td><td><code>0</code> or <code>+inf</code></td><td>No</td><td><code>1</code></td></tr>
</tbody></table>
</div>
<p>Default value is 0 if inheriting from <code>lmake.Rule</code>, else <code>+inf</code>.</p>
<p>This attribute is used to order matching priority.
Rules with higher priorities are tried first and if none of them are applicable, rules with lower priorities are then tried (cf <a href="rule_selection.html">rule selection</a>).</p>
<h3 id="stems"><a class="header" href="#stems"><code>stems</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td><code>{}</code></td><td>No</td><td><code>{'File':r'.*'}</code></td></tr>
</tbody></table>
</div>
<p>Stems are regular expressions that represent the variable parts of targets which rules match.</p>
<p>Each entry <key>:<value> define a stem named <key> whose associated regular expression is <value>.</p>
<h3 id="job_name"><a class="header" href="#job_name"><code>job_name</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>str</code></td><td>...</td><td>No</td><td></td></tr>
</tbody></table>
</div>
<p>Default is the first target of the most derived <code>class</code> in the inheritance hierarchy (i.e. the MRO) having a matching target.</p>
<p>This attribute may exceptionally be used for cosmetic purpose.
Its syntax is the same as target name (i.e. a target with no option).</p>
<p>When open-lmake needs to include a job in a report, it will use this attribute.
If it contains star stems, they will be replaced by <code>*</code>'s in the report.</p>
<p>If defined, this attribute must have the same set of static stems (i.e. stems that do not contain *) as any matching target.</p>
<h3 id="targets"><a class="header" href="#targets"><code>targets</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td><code>{}</code></td><td>No</td><td><code>{ 'OBJ' : '{File}.o' }</code></td></tr>
</tbody></table>
</div>
<p>This attribute is used to define the regular expression which targets must match to select this rule (cf <a href="rule_selection.html">rule selection</a>).</p>
<p>Keys must be python identifiers.
Values are <code>list</code>'s or <code>tuple</code>'s whose first item defines the target regular expression and following items define flags.
They may also be a simple <code>str</code> in which case it is as if there were no associated flags.</p>
<p>The regular expression looks like python f-strings.
The fixed parts (outside <code>{}</code>) must match exactly.
The variable parts, called stems, are composed of:</p>
<ul>
<li>An optional name.
If it exists, it is used to ensure coherence with other targets and the <code>job_name</code> attribute, else coherence is ensured by position.
This name is used to find its definition in the stems <code>dict</code> and may also be used in the <code>cmd</code> attribute to refer to the actual content of the corresponding part in the target.</li>
<li>An optional <code>*</code>.
If it exists, this target is a star target, meaning that a single job will generate all or some of the targets matching this regular expression.
if not named, such stem must be defined.</li>
<li>An optional <code>:</code> followed by a definition (a regular expression).
This is an alternative to refering to an entry in the <code>stems</code> <code>dict</code>.
Overall, all stems must be defined somewhere (in the <code>stems</code> <code>dict</code>, in a target or in <code>job_name</code>) and if defined several times, definitions must be identical.
Also, when defined in a target, a definition must contain balanced <code>{}</code>'s, i.e. there must be as many <code>{</code> as <code>}</code>.
If a regular expression requires unbalanced <code>{}</code>, it must be put in a <code>stems</code> entry.</li>
</ul>
<p>Regular expressions are used with the <code>DOTALL</code> flag, i.e. a <code>.</code> matches any character, including <code>\n</code>.</p>
<p>The flags may be any combination of the following flags, optionally preceded by - to turn it off.
Flags may be arbitrarily nested into sub-<code>list</code>'s or sub-<code>tuple</code>'s.</p>
<div class="table-wrapper"><table><thead><tr><th>CamelCase</th><th>snake_case</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Essential</code></td><td><code>essential</code></td><td>Yes</td><td>This target will be shown in a future graphic tool to show the workflow, it has no algorithmic effect.</td></tr>
<tr><td><code>Incremental</code></td><td><code>incremental</code></td><td>No</td><td>Previous content may be used to produce these targets.  In that case, these are not unlinked before execution. However, if targets have non-targets hard links and are not read-only, they are uniquified, i.e. they are copied in place to ensure modification to such targets do not alter other links.</td></tr>
<tr><td><code>Optional</code></td><td><code>optional</code></td><td>No</td><td>If this target is not generated, it is not deemed to be produced by the job. Open-lmake will try to find an alternative rule. This is equivalent to being a star target, except that there is no star stem.</td></tr>
<tr><td><code>Phony</code></td><td><code>phony</code></td><td>No</td><td>Accept that this target is not generated, this target is deemed generated even not physically on disk. If a star target, do not search for an alternative rule to produce the file.</td></tr>
<tr><td><code>SourceOk</code></td><td><code>source_ok</code></td><td>No</td><td>Do not generate an error if target is actually a source</td></tr>
<tr><td><code>NoWarning</code></td><td><code>no_warning</code></td><td>No</td><td>Warning is not reported if a target is either uniquified or unlinked before job execution while generated by another job.</td></tr>
<tr><td><code>Top</code></td><td><code>top</code></td><td>No</td><td>target pattern is interpreted relative to the root dir of the repo, else it is relative to the <code>cwd</code> of the rule.</td></tr>
</tbody></table>
</div>
<p>All targets must have the same set of static stems (i.e. stems with no <code>*</code> in its name).</p>
<p>Matching is done by first trying to match static targets (i.e. which are not star) then star targets.
The first match will provide the associated stem definitions and flags.</p>
<p>Unless the <code>top</code> flag is set, the pattern is rooted to the sub-repo if the rule is defined in such a sub-repo.
If the <code>top</code> flag is set, the pattern is always rooted at the top-level repo.</p>
<h3 id="target"><a class="header" href="#target"><code>target</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>str</code> or <code>list</code> or <code>tuple</code></td><td>-</td><td>No</td><td></td></tr>
</tbody></table>
</div>
<p>This attribute defines an unnamed target.
Its syntax is the same as any target entry except that it may not be <code>incremental</code>. Also, such a target may not be a <code>star</code> target.</p>
<p>During execution, <code>cmd</code> stdout will be redirected to this (necessarily unique since it cannot be a <code>star</code>) target.</p>
<p>The <code>top</code> flag cannot be used and the pattern is always rooted to the sub-repo if the rule is defined in such a sub-repo.</p>
<h3 id="side_targets"><a class="header" href="#side_targets"><code>side_targets</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td><code>{}</code></td><td>No</td><td></td></tr>
</tbody></table>
</div>
<p>This attribute is identical to <code>targets</code> except that:</p>
<ul>
<li>targets listed here do not trigger job execution, i.e. they do not participate to the <a href="rule_selection.html">rule selection</a> process.</li>
<li>it not compulsery to use all static stems as this constraint is only necessary to fully define a job when selected by the rule selection process.</li>
</ul>
<h3 id="deps"><a class="header" href="#deps"><code>deps</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td><code>{}</code></td><td>Simple</td><td><code>{ 'SRC' : '{File}.c' }</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines the static deps.
It is a <code>dict</code> which associates python identifiers to files computed from the available environment.</p>
<p>They are f-strings, i.e. their value follow the python f-string syntax and semantic
but they are interpreted when open-lmake tries to match the rule (the rule only matches if static deps are buildable, cf <a href="rule_selection.html">rule selection</a>).
Hence they lack the initial <code>f</code> in front of the string.</p>
<p>Alternatively, values can also be <code>list</code> or <code>tuple</code> whose first item is as described above, followed by flags.</p>
<p>The flags may be any combination of the following flags, optionally preceded by - to turn it off.
Flags may be arbitrarily nested into sub-<code>list</code>'s or sub-<code>tuple</code>'s.</p>
<div class="table-wrapper"><table><thead><tr><th>CamelCase</th><th>snake_case</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Essential</code></td><td><code>essential</code></td><td>Yes</td><td>This dep will be shown in a future graphic tool to show the workflow, it has no algorithmic effect.</td></tr>
<tr><td><code>Critical</code></td><td><code>critical</code></td><td>No</td><td>This dep is <a href="critical_deps.html">critical</a>.</td></tr>
<tr><td><code>IgnoreError</code></td><td><code>ignore_error</code></td><td>No</td><td>This dep may be in error, job will be launched anyway.</td></tr>
<tr><td><code>ReaddirOk</code></td><td><code>readdir_ok</code></td><td>No</td><td>This dep may be read as a dir (using <code>readdir</code> (3)) without error.</td></tr>
<tr><td><code>Required</code></td><td><code>required</code></td><td>No</td><td>This dep is deemed to be read, even if not actually read by the job.</td></tr>
<tr><td><code>Top</code></td><td><code>top</code></td><td>No</td><td>dep pattern is interpreted relative to the top-level repo, else to the local repo (cf <a href="experimental_subrepos.html">subrepos</a>.</td></tr>
</tbody></table>
</div>
<p>Flag order and dep order are not significative.</p>
<h3 id="dep"><a class="header" href="#dep"><code>dep</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>str</code> or <code>list</code> or <code>tuple</code></td><td>-</td><td>Simple</td><td></td></tr>
</tbody></table>
</div>
<p>This attribute defines an unnamed static dep.</p>
<p>During execution, <code>cmd</code> stdin will be redirected to this dep, else it is <code>/dev/null</code>.</p>
<h3 id="side_deps"><a class="header" href="#side_deps"><code>side_deps</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td><code>{}</code></td><td>No</td><td></td></tr>
</tbody></table>
</div>
<p>This attribute is used to define flags to deps when they are acquired during job execution.
It does not declare any dep by itself.
Syntactically, it follows the <code>side_targets</code> attribute except that:</p>
<ul>
<li>Specified flags are dep flags only where <code>side_targets</code> accept both target flags an dep flags.</li>
<li>The flag <code>Ignore</code> or <code>ignore</code> only applies to reads to prevent such accessed files from becoming a dep where for <code>side_targets</code>, this flag prevents files from being deps or targets.</li>
<li><code>.</code> may be specified as pattern (or pattern may include it as a possible match) which may be necessary when passing the <code>readdir_ok</code> flag.</li>
</ul>
<h3 id="chroot_dir"><a class="header" href="#chroot_dir"><code>chroot_dir</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>f-str</code></td><td><code>None</code></td><td>Full</td><td><code>'/ubuntu22.04'</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines a dir in which jobs will <code>chroot</code> into before execution begins.
It must be an absoluted path.</p>
<p>Note that unless the <code>repo_view</code> is set, the repo must be visible under its original name in this chroot environment.</p>
<p>If <code>None</code>, <code>''</code> or <code>'/'</code>, no <code>chroot</code> is performed unless required to manage the <code>tmp_view</code> and <code>repo_view</code> attributes (in which case it is transparent).
However, if <code>'/'</code>, <a href="namespaces.html">namespaces</a> are used nonetheless.</p>
<h3 id="repo_view"><a class="header" href="#repo_view"><code>repo_view</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>f-str</code></td><td><code>None</code></td><td>Full</td><td><code>'/repo'</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines a dir in which jobs will see the top-level dir of the repo (the root dir).
This is done by using <code>mount -rbind</code> (cf <a href="namespaces.html">namespaces</a>).</p>
<p>It must be an absolute path not lying in the temporary dir.</p>
<p>If <code>None</code> or <code>''</code>, no bind mount is performed.</p>
<p>As of now, this attribute must be a top level dir, i.e. <code>'/a'</code> is ok, but <code>'/a/b'</code> is not.</p>
<h3 id="tmp_view"><a class="header" href="#tmp_view"><code>tmp_view</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>f-str</code></td><td><code>None</code></td><td>Full</td><td><code>'/tmp'</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines the name which the temporary dir available for job execution is mounted on (cf <a href="namespaces.html">namespaces</a>).</p>
<p>If <code>None</code>, <code>''</code> or not specified, this dir is not mounted.
Else, it must be an absolute path.</p>
<p>As of now, this attribute must be a top level dir, i.e. <code>'/a'</code> is ok, but <code>'/a/b'</code> is not.</p>
<h3 id="views"><a class="header" href="#views"><code>views</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td><code>{}</code></td><td>Full</td><td></td></tr>
</tbody></table>
</div>
<p>This attribute defines a mapping from logical views to physical dirs.</p>
<p>Accesses to logical views are mapped to their corresponding physical location. Views and physical locations may be dirs or files depending on whether they end with a <code>/</code> or not.
Files must be mapped to files and dirs to dirs.</p>
<p>Both logical views and physical locations may be inside or outside the repo, but it is not possible to map an external view to a local location (cf <a href="namespaces.html">namespaces</a>).</p>
<p>Physical description may be :</p>
<ul>
<li>a <code>f-str</code> in which case a bind mount is performed.</li>
<li>a <code>dict</code> with keys <code>upper</code> (a <code>str</code>) and <code>lower</code> (a single <code>str</code> or a list of <code>str</code>) in which case an overlay mount is performed.
Key <code>copy_up</code> (a single <code>str</code> or a list of <code>str</code>) may also be used to provide a list of dirs to create in upper or files to copy from lower to upper.
Dirs are recognized when they end with <code>/</code>.
Such <code>copy_up</code> items are provided relative to the root of the view.</li>
</ul>
<h3 id="environ"><a class="header" href="#environ"><code>environ</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td>...</td><td>Full</td><td><code>{ 'MY_TOOL_ROOT' : '/install/my_tool' }</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines environment variables set during job execution.</p>
<p>The content of this attribute is managed as part of the job command, meaning that jobs are rerun upon modification.
This is the normal behavior, other means to define environment are there to manage special situations.</p>
<p>The environment in which the open-lmake command is run is ignored so as to favor reproducibility, unless explicitly transported by using value from <code>lmake.user_environ</code>.
Hence, it is quite simple to copy some variables from the user environment although this practice is discouraged and should be used with much care.</p>
<p>Except the exception below, the value must be a <code>f-str</code>.</p>
<p>If resulting value is <code>...</code> (the python ellipsis), the value from the backend environment is used.
This is typically used to access some environment variables set by <code>slurm</code>.</p>
<p>If a value contains one of the following strings, they are replaced by their corresponding definitions:</p>
<div class="table-wrapper"><table><thead><tr><th>Key</th><th>Replacement</th><th>Comment</th></tr></thead><tbody>
<tr><td><code>$LMAKE_ROOT</code></td><td>The root dir of the open-lmake package</td><td>Dont store in targets as this may require cleaning repo if open-lmake installation changes</td></tr>
<tr><td><code>$PHYSICAL_REPO_ROOT</code></td><td>The physical dir of the subrepo</td><td>Dont store in targets as this may interact with cached results</td></tr>
<tr><td><code>$PHYSICAL_TMPDIR</code></td><td>The physical dir of the tmp dir</td><td>Dont store in targets as this may interact with cached results</td></tr>
<tr><td><code>$PHYSICAL_TOP_REPO_ROOT</code></td><td>The physical dir of the top-level repo</td><td>Dont store in targets as this may interact with cached results</td></tr>
<tr><td><code>$REPO_ROOT</code></td><td>The absolute dir of the subrepo as seen by job</td><td></td></tr>
<tr><td><code>$SEQUENCE_ID</code></td><td>A unique value for each job execution (at least 1)</td><td>This value must be semantically considered as a random value</td></tr>
<tr><td><code>$SMALL_ID</code></td><td>A unique value among simultaneously running jobs (at least 1)</td><td>This value must be semantically considered as a random value</td></tr>
<tr><td><code>$TMPDIR</code></td><td>The absolute dir of the tmp dir, as seen by the job</td><td></td></tr>
<tr><td><code>$TOP_REPO_ROOT</code></td><td>The absolute dir of the top-level repo, as seen by the job</td><td></td></tr>
</tbody></table>
</div>
<p>By default the following environment variables are defined :</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Defined in</th><th>Value</th><th>comment</th></tr></thead><tbody>
<tr><td><code>$HOME</code></td><td>Rule</td><td><code>$TOP_REPO_ROOT</code></td><td>See above, isolates tools startup from user specific data</td></tr>
<tr><td><code>$HOME</code></td><td>HomelessRule</td><td><code>$TMPDIR</code></td><td>See above, pretend tools are used for the first time</td></tr>
<tr><td><code>$PATH</code></td><td>Rule</td><td>The standard path with <code>$LMAKE_ROOT/bin:</code> in front</td><td></td></tr>
<tr><td><code>$PYTHONPATH</code></td><td>PyRule</td><td><code>$LMAKE_ROOT/lib</code></td><td></td></tr>
</tbody></table>
</div>
<h3 id="environ_resources"><a class="header" href="#environ_resources"><code>environ_resources</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td><code>{}</code></td><td>Full</td><td><code>{ 'MY_TOOL_LICENCE' : '12345' }</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines environment variables set during job execution.</p>
<p>The content of this attribute is managed as resources, meaning that jobs in error are rerun upon modification, but not jobs that were successfully built.</p>
<p>The values undertake the same substitutions as for the <code>environ</code> attribute described above.</p>
<p>The environment in which the open-lmake command is run is ignored so as to favor reproducibility, unless explicitly transported by using value from <code>lmake.user_environ</code>.
Hence, it is quite simple to copy some variables from the user environment although this practice is discouraged and should be used with much care.</p>
<p>Except the exception below, the value must be a <code>f-str</code>.</p>
<p>If resulting value is <code>...</code> (the python ellipsis), the value from the backend environment is used.
This is typically used to access some environment variables set by <code>slurm</code>.</p>
<h3 id="environ_ancillary"><a class="header" href="#environ_ancillary"><code>environ_ancillary</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td><code>{}</code></td><td>Full</td><td><code>{ 'DISPLAY' : ':10' }</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines environment variables set during job execution.</p>
<p>The content of this attribute is not managed, meaning that jobs are not rerun upon modification.</p>
<p>The values undertake the same substitutions as for the <code>environ</code> attribute described above.</p>
<p>The environment in which the open-lmake command is run is ignored so as to favor reproducibility, unless explicitly transported by using value from <code>lmake.user_environ</code>.
Hence, it is quite simple to copy some variables from the user environment although this practice is discouraged and should be used with much care.</p>
<p>Except the exception below, the value must be a <code>f-str</code>.</p>
<p>If resulting value is <code>...</code> (the python ellipsis), the value from the backend environment is used.
This is typically used to access some environment variables set by <code>slurm</code>.</p>
<p>By default the following environment variables are defined :</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Defined in</th><th>Value</th><th>comment</th></tr></thead><tbody>
<tr><td><code>$UID</code></td><td>Rule</td><td>the user id</td><td></td></tr>
<tr><td><code>$USER</code></td><td>Rule</td><td>the user login name</td><td></td></tr>
</tbody></table>
</div>
<h3 id="python"><a class="header" href="#python"><code>python</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>list</code> or <code>tuple</code></td><td>system python</td><td>Full</td><td><code>venv/bin/python3</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines the interpreter used to run the <code>cmd</code> if it is a function.</p>
<p>Items must be <code>f-str</code>.</p>
<p>At the end of the supplied executable and arguments, <code>'-c'</code> and the actual script is appended, unless the <code>use_script</code> attribut is set.
In the latter case, a file that contains the script is created and its name is passed as the last argument without a preceding <code>-c</code>.</p>
<p>Open-lmake uses python3.6+ to read <code>Lmakefile.py</code>, but that being done, any interpreter can be used to execute <code>cmd</code>.
In particular, python2.7 and all revisions of python3 are fully supported.</p>
<p>If simple enough (i.e. if it can be recognized as a static dep), it is made a static dep if it is within the repo.</p>
<h3 id="shell"><a class="header" href="#shell"><code>shell</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>list</code> or <code>tuple</code></td><td><code>/bin/bash</code></td><td>Full</td><td><code>('/bin/bash','-e')</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines the interpreter used to run the <code>cmd</code> if it is a <code>str</code>.</p>
<p>Items must be <code>f-str</code>.</p>
<p>At the end of the supplied executable and arguments, <code>'-c'</code> and the actual script is appended, unless the <code>use_script</code> attribut is set.
In the latter case, a file that contains the script is created and its name is passed as the last argument without a preceding <code>-c</code>.</p>
<p>If simple enough (i.e. if it can be recognized as a static dep), it is made a static dep if it is within the repo.</p>
<h3 id="cmd"><a class="header" href="#cmd"><code>cmd</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>f-str</code></td><td>-</td><td>Full</td><td><code>'gcc -c -o {OBJ} {SRC}'</code></td></tr>
<tr><td>Combined</td><td>function</td><td>-</td><td>Full</td><td><code>def cmd() : subprocess.run(('gcc','-c','-o',OBJ,SRC,check=True))</code></td></tr>
</tbody></table>
</div>
<h4 id="if-it-is-a-function"><a class="header" href="#if-it-is-a-function">if it is a function</a></h4>
<p>In that case, this attribute is called to run the job (cf <a href="job_execution.html">job execution</a>).
Combined inheritance is a special case for <code>cmd</code>.</p>
<p>If several definitions exist along the MRO, They must all be functions and they are called successively in reverse MRO.
The first (i.e. the most basic) one must have no non-defaulted arguments and will be called with no argument.
The other ones may have arguments, all but the first having default values.
In that case, such <code>function</code>'s are called with the result of the previous one as unique argument.
Else, if a <code>function</code> has no argument, the result of the previous function is dropped.</p>
<p>Because jobs are executed remotely using the interpreter mentioned in the <code>python</code> attribute
and to avoid depending on the whole <code>Lmakefile.py</code> (which would force to rerun all jobs as soon as any rule is modified),
these functions and their context are serialized to be transported by value.
The serialization process may improve over time but as of today, the following applies:</p>
<ul>
<li>Basic objects are transported as is : <code>None</code>, <code>...</code>, <code>bool</code>, <code>int</code>, <code>float</code>, <code>complex</code>, <code>str</code>, <code>bytes</code>.</li>
<li><code>list</code>, <code>tuple</code>, <code>set</code> and <code>dict</code> are transported by transporting their content. Note that reconvergences (and a fortiori loops) are not handled.</li>
<li>functions are transported as their source accompanied with their context : global accessed variables and default values for arguments.</li>
<li>Imported objects (functions and <code>class</code>'es and generally all objects with a <code>__qualname__</code> attribute) are transported as an <code>import</code> statement.</li>
<li>Builtin objects are transported spontaneously, without requiring any generated code.</li>
</ul>
<p>Also, care has been taken to hide this transport by value in backtrace and during debug sessions, so that functions appear to be executed where they were originally defined.</p>
<p>Values are captured according to the normal python semantic, i.e. once the <code>Lmakefile</code> module is fully imported.
Care must be taken for variables whose values change during the <code>import</code> process.
This typically concerns loop indices.
To capture these at definition time and not at the end, such values must be saved somewhere.
There are mostly 2 practical possibilities:</p>
<ul>
<li>Declare an argument with a default value. Such default value is saved when the function is defined.</li>
<li>Define a class attribute. Class attributes are saved when its definition ends, which is before a loop index.</li>
</ul>
<h4 id="if-it-is-a-f-str"><a class="header" href="#if-it-is-a-f-str">if it is a <code>f-str</code></a></h4>
<p>In that case, this attribute is executed as a shell command to run the job (cf <a href="job_execution.html">job execution</a>).
Combined inheritance is a special case for <code>cmd</code>.</p>
<p>While walking the MRO, if for a base class <code>cmd</code> is defined as a function and it has a <code>shell</code> attribute, the value of this attribute is used instead.
The purpose is that it is impossible to combine <code>str</code>'s and functions because they use different paradigms.
As a consequence, a base class may want to have 2 implementations, one for subclasses that use python <code>cmd</code> and another for subclasses that use shell <code>cmd</code>.
For such a base class, the solution is to define <code>cmd</code> as a function and set its <code>shell</code> attribute to the <code>str</code> version.</p>
<p>If several definitions exist along the MRO, They must all be <code>str</code>'s and they are run successively in reverse MRO in the same process.
So, it is possible for a first definition to define an environment variable that is used in a subsequent one.</p>
<p>As for other attributes that may be dynamic, <code>cmd</code> is interpreted as an f-string.</p>
<h3 id="auto_mkdir"><a class="header" href="#auto_mkdir"><code>auto_mkdir</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>bool</code></td><td><code>False</code></td><td>Full</td><td><code>True</code></td></tr>
</tbody></table>
</div>
<p>When this attribute has a true value, executing a <code>chdir</code> syscall (e.g. executing <code>cd</code> in bash) will create the target dir if it does not exist.</p>
<p>This is useful for scripts in situations such as:</p>
<ul>
<li>The script does <code>chdir a</code>.</li>
<li>Then try to read file <code>b</code> from there.</li>
<li>What is expected is to have a dep on <code>a/b</code> which may not exist initially but will be created by some other job.</li>
<li>However, if dir <code>a</code> does not exist, the <code>chdir</code> call fails and the file which is open for reading is <code>b</code> instead of <code>a/b</code>.</li>
<li>As a consequence, no dep is set for <code>a/b</code> and the problem will not be resolved by a further re-execution.</li>
<li>Setting this attribute to true creates dir <code>a</code> on the fly when <code>chdir</code> is called so that it succeeds and the correct dep is set.</li>
</ul>
<h3 id="autodep"><a class="header" href="#autodep"><code>autodep</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>f-str</code></td><td><code>'ld_audit'</code> if supported else <code>'ld_preload'</code></td><td>Full</td><td><code>'ptrace'</code></td></tr>
</tbody></table>
</div>
<p>This attribute specifies the method used by <a href="autodep.html">autodep</a> to discover hidden deps.</p>
<h3 id="backend"><a class="header" href="#backend"><code>backend</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>f-str</code></td><td>-</td><td>Full</td><td><code>'slurm'</code></td></tr>
</tbody></table>
</div>
<p>This attribute specifies the <a href="backends.html">backend</a> to use to launch jobs.</p>
<h3 id="cache"><a class="header" href="#cache"><code>cache</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>f-str</code></td><td>-</td><td>Simple</td><td></td></tr>
</tbody></table>
</div>
<p>This attribute specifies the cache to use for jobs executed by this rule.</p>
<p>When a job is executed, its results are stored in the cache.
If space is needed (all caches are constrained in size), any other entry can be replaced.
The cache replacement policy (described in its own section, in the config chapter) tries to identify entries that are likely to be useless in the future.</p>
<h3 id="compression"><a class="header" href="#compression"><code>compression</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>int</code></td><td><code>0</code></td><td>Full</td><td><code>1</code></td></tr>
</tbody></table>
</div>
<p>This attribute specifies the compression level used when caching.
It is passed to the zlib library used to compress job targets.</p>
<ul>
<li><code>0</code> means no compression.</li>
<li><code>9</code> means maximum compression.</li>
</ul>
<h3 id="force"><a class="header" href="#force"><code>force</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>bool</code></td><td><code>False</code></td><td>Full</td><td><code>True</code></td></tr>
</tbody></table>
</div>
<p>When this attribute is set to a true value, jobs are always considered out-of-date and are systematically rerun if a target is needed.
It is rarely necessary.</p>
<h3 id="keep_tmp"><a class="header" href="#keep_tmp"><code>keep_tmp</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>bool</code></td><td><code>False</code></td><td>Full</td><td><code>True</code></td></tr>
</tbody></table>
</div>
<p>When this attribute is set to a true value, the temporary dir is kept after job execution.
It can be retreived with <code>lshow -i</code>.</p>
<p>Sucessive executions of the same job overwrite the temporary dir, though, so only the content corresponding to the last execution is available.
When this attribute has a false value, the temporary dir is cleaned up at the end of the job execution.</p>
<h3 id="kill_sigs"><a class="header" href="#kill_sigs"><code>kill_sigs</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>list</code> or <code>tuple</code></td><td><code>(signal.SIGKILL,)</code></td><td>Full</td><td></td></tr>
</tbody></table>
</div>
<p>This attribute provides a list of signals to send the job when @lmake decides to kill it.</p>
<p>A job is killed when:</p>
<ul>
<li><code>^C</code> is hit if it is not necessary for another running <code>lmake</code> command that has not received a <code>^C</code>.</li>
<li>When timeout is reached.</li>
<li>When <code>check_deps</code> is called and some deps are out-of-date.</li>
</ul>
<p>The signals listed in this list are sent in turn, once every second.
Longer interval can be obtained by inserting <code>0</code>'s. <code>0</code> signals are not sent and anyway, these would have no impact if they were.</p>
<p>If the list is exhausted and the job is still alive, a more agressive method is used.
The process group of the job, as well as the process group of any process connected to a stream we are waiting for, are sent <code>SIGKILL</code> signals instead of just the process group of the job.
The streams we are waiting for are <code>stderr</code>, and <code>stdout</code> unless the <code>target</code> attribute is used (as opposed to the <code>targets</code> attribute)
in which case <code>stdout</code> is redirected to the the target and is not waited for.</p>
<p>Note: some backends, such as slurm, may have other means to manage timeouts. Both mechanisms will be usable.</p>
<h3 id="max_retries_on_lost"><a class="header" href="#max_retries_on_lost"><code>max_retries_on_lost</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>int</code></td><td><code>1</code></td><td>No</td><td></td></tr>
</tbody></table>
</div>
<p>This attribute provides the number of allowed retries before giving up when a job is lost.
For example, a job may be lost because of a remote host being misconfigured, or because the job management process (called <code>job_exec</code>) was manually killed.</p>
<p>In that case, the job is retried, but a maximum number of retry attemps are allowed, after which the job is considered in error.</p>
<h3 id="max_stderr_len"><a class="header" href="#max_stderr_len"><code>max_stderr_len</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>int</code></td><td><code>100</code></td><td>Full</td><td><code>1</code></td></tr>
</tbody></table>
</div>
<p>This attribute defines the maximum number of lines of stderr that will be displayed in the output of <code>lmake</code>.
The whole content of stderr stays accessible with the <code>lshow -e</code> command.</p>
<h3 id="max_submits"><a class="header" href="#max_submits"><code>max_submits</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>int</code></td><td><code>10</code></td><td>No</td><td></td></tr>
</tbody></table>
</div>
<p>The goal is to protect agains potential infinite loop cases.
The default value should be both comfortable (avoid hitting it in normal situations) and practical (avoid too many submissions before stopping).</p>
<h3 id="readdir_ok"><a class="header" href="#readdir_ok"><code>readdir_ok</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>bool</code></td><td><code>False</code></td><td>Full</td><td><code>True</code></td></tr>
</tbody></table>
</div>
<p>When this attribute has a false value, reading a local dir that is not <code>ignore</code>d nor <code>incremental</code> is considered an error as the list of files in a dir cannot be made stable,
i.e. independent of the history (the repo is not constantly maintained without spurious files, nor with all buildable files existing).</p>
<p>If it is true, such reading is allowed and it is the user responsibility to ensure that spurious or missing files have no impact on output, once all deps are up-to-date.</p>
<h3 id="resources"><a class="header" href="#resources"><code>resources</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>Combined</td><td><code>dict</code></td><td><code>{}</code></td><td>Full</td><td><code>{ 'MY_RESOURCE' : '1' }</code></td></tr>
</tbody></table>
</div>
<p>This attribute specifies the resources required by a job to run successfully.
These may be cpu availability, memory, commercial tool licenses, access to dedicated hardware, ...</p>
<p>Values must <code>f-str</code>.</p>
<p>The syntax is the same as for <code>deps</code>.</p>
<p>After interpretation, the <code>dict</code> is passed to the <code>backend</code> to be used in its scheduling (cf @pxref{local-backend} for the local backend).</p>
<h3 id="start_delay"><a class="header" href="#start_delay"><code>start_delay</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>float</code></td><td><code>3</code></td><td>Full</td><td></td></tr>
</tbody></table>
</div>
<p>When this attribute is set to a non-zero value, start lines are only output for jobs that last longer than that many seconds.
The consequence is only cosmetic, it has no other impact.</p>
<h3 id="stderr_ok"><a class="header" href="#stderr_ok"><code>stderr_ok</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>bool</code></td><td><code>False</code></td><td>Full</td><td><code>True</code></td></tr>
</tbody></table>
</div>
<p>When this attribute has a false value, the simple fact that a job generates a non-empty stderr is an error.
If it is true, writing to stderr is allowed and does not produce an error. The <code>lmake</code> output will exhibit a warning, though.</p>
<h3 id="timeout"><a class="header" href="#timeout"><code>timeout</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>float</code></td><td>no timeout</td><td>Full</td><td></td></tr>
</tbody></table>
</div>
<p>When this attribute has a non-zero value, job is killed and a failure is reported if it is not done before that many seconds.</p>
<h3 id="use_script"><a class="header" href="#use_script"><code>use_script</code></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Inheritance</th><th>Type</th><th>Default</th><th>Dynamic</th><th>Example</th></tr></thead><tbody>
<tr><td>python</td><td><code>bool</code></td><td><code>False</code></td><td>Full</td><td><code>True</code></td></tr>
</tbody></table>
</div>
<p>This attribute commands an implementation detail.</p>
<p>If false, jobs are run by launching the interpreter followed by <code>-c</code> and the command text.</p>
<p>If true, jobs are run by creating a temporary file containing the command text, then by launching the interpreter followed by said file name.</p>
<p>If the size of the command text is too large to fit in the command line, this attribute is silently forced to true.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="execution-1"><a class="header" href="#execution-1">Execution</a></h1>
<h2 id="handling-an-access"><a class="header" href="#handling-an-access">Handling an access</a></h2>
<p>At first glance, recognizing a target from a dep when a job runs seems pretty easy when the accesses to the disk can be traced : reading a file is a dep, writing to it is a target.
And this is what is done informally, but there are a lot of corner cases.</p>
<p>The specification devised hereinafter has been carefully thought to allow open-lmake to run adequate jobs to reach a stable state from any starting point.
More specifically, think of the following sequence:</p>
<pre><code class="language-bash">git clean -ffdx
lmake foo
git pull
lmake foo
</code></pre>
<p>The second <code>lmake foo</code> command is supposed to do the minimum work to reach the same content of <code>foo</code> as would be obtained with the sequence:</p>
<pre><code class="language-bash">git pull
git clean -ffdx
lmake foo
</code></pre>
<p>This what stable state means : the content of <code>foo</code> is independent of the history and only depends on the rules and the content of sources, both being managed through <code>git</code> in this example.</p>
<p>In this specification, dirs are ignored (i.e. the presence or content of a dir has no impact) and symbolic links are similar to regular files whose content is the link itself.</p>
<h3 id="reading-and-writing-files"><a class="header" href="#reading-and-writing-files">Reading and writing files</a></h3>
<p>The first point is to precisely know what reading and writing mean.</p>
<p>Writing to file <code>foo</code> means:</p>
<ul>
<li>A system call that writes or initiate writing to <code>foo</code>, e.g. <code>open("foo",O_WRONLY|O_TRUNC)</code> or <code>symlink(...,"foo")</code>, assuming the <code>autodep</code> rule attribute is not set to <code>'none'</code>.</li>
<li>Unlinking <code>foo</code>, e.g. <code>unlink("foo")</code>, is also deemed to be writing to it.</li>
<li>A call to <code>lmake.target('foo',write=True)</code>.</li>
<li>The execution of <code>ltarget -W foo</code>.</li>
<li>Under the condition that these actions are not preceded by a call to <code>lmake.target('foo',ignore=True)</code> or the execution of <code>ltarget -I foo</code>.</li>
<li>Also under the condition that <code>foo</code> does not match a <code>targets</code> or <code>side_targets</code> entry with the <code>Ignore</code> flag set.</li>
<li>Also under the condition that <code>foo</code> lies in the repo (i.e. under the dir containing <code>Lmakefile.py</code> but not in its <code>LMAKE/lmake</code> sub-dir).</li>
</ul>
<p>Reading file <code>foo</code> means :</p>
<ul>
<li>A system call that reads or initiate reading <code>foo</code>, e.g. <code>open("foo",O_RDONLY)</code>, <code>readlink("foo",...)</code> or <code>stat("foo",...)</code>,
assuming the <code>autodep</code> rule attribute is not set to <code>'none'</code>.</li>
<li>Unless the <code>config.link_support</code> attribute is set to <code>'none'</code>,
any access (reading or writing) to <code>foo</code> which follows symlinks is an implicit <code>readlink</code>.</li>
<li>Unless the <code>config.link_support</code> attribute is set to <code>'file'</code> or <code>'none'</code>,
any access (reading or writing) to <code>foo</code>, whether it follows symlinks or not, is an implicit <code>readlink</code> of all dirs leading to it.</li>
<li>Note that some system calls can be both a read and a write, e.g. <code>open("foo", O_RDWR)</code> but also <code>rename("foo",...)</code>.
In that case, the read occurs before the write.</li>
<li>A call to <code>lmake.depend('foo',read=True)</code>.</li>
<li>The execution of <code>ldepend -R foo</code>.</li>
<li>Under the condition that these actions are not preceded by a call to <code>lmake.depend('foo',ignore=True)</code> or the execution of <code>ldepend -I foo</code>.</li>
<li>Also under the condition that <code>foo</code> is not listed in <code>deps</code> or matches a <code>side_deps</code> entry, with the <code>Ignore</code> flag set.</li>
<li>Also under the condition that <code>foo</code> lies in the repo (i.e. under the dir containing <code>Lmakefile.py</code> but not in its <code>LMAKE/lmake</code> sub-dir) or in a source dir.</li>
</ul>
<h3 id="reading-a-dir"><a class="header" href="#reading-a-dir">Reading a dir</a></h3>
<p>A dir <code>foo</code> is read when files it contains are listed, which occur when:</p>
<ul>
<li>A system call that reads dir <code>foo</code>, e.g. <code>getdents</code>.</li>
<li>A libc call that reads dir <code>foo</code>, e.g. <code>readdir</code> or <code>glob</code> (in which its pattern argument requires reading <code>foo</code>).</li>
<li>Under the condition that these actions are not preceded by a call to <code>lmake.target('foo',ignore=True)</code> or the execution of <code>ltarget -I foo</code>.</li>
<li>Also under the condition that neither <code>lmake.target('foo',incremental=True)</code> was called nor <code>ltarget -i foo</code> executed.</li>
<li>Also under the condition that <code>foo</code> does not match a <code>targets</code> or <code>side_targets</code> entry with the <code>Ignore</code> or <code>Incremental</code> flags set.</li>
<li>Also under the condition that <code>foo</code> lies in the repo (i.e. under the dir containing <code>Lmakefile.py</code> but not in its <code>LMAKE/lmake</code> sub-dir) or is the repo root dir.</li>
</ul>
<p>Although dirs do not exist for open-lmake, reading dir <code>foo</code> is an error unless the <code>ReaddirOk</code> attribute was set on the rule or the <code>ReaddirOk</code> flag is set, which can be done by:</p>
<ul>
<li>Passing the <code>ReaddirOk</code> flag in the <code>targets</code>, <code>side_targets</code> or <code>side_deps</code> entry.</li>
<li>Calling <code>lmake.depend('foo',readdir_ok=True)</code> or executing <code>ldepend -D foo</code>.</li>
<li>Calling <code>lmake.target('foo',readdir_ok=True)</code> or executing <code>ltarget -D foo</code>.</li>
</ul>
<p>Note that the <code>lmake.PyRule</code> base class sets the the <code>ReaddirOk</code> flag on dirs mentioned in <code>sys.path</code> when executing python3.
This is because python3 optimizes imports by pre-reading these dirs.</p>
<p>Such restrictions ensure the reliability of job execution as the content of a dir is mostly unpredictable as it depends on the past history:
files may or may not have been already built, or previously built files that are now non-buildable may still exist.</p>
<p>Ideally, listing a dir would lead to all buildable files (or sub-dirs), but this is not doable in the generic case as such list may be infinite.
So open-lmake reverts to letting the user deal with this question, using an opt-in approach so the user cannot miss it.</p>
<p>Note that if such a dir is marked as <code>incremental</code>, the user already has the responsibility of handling its past history and there is no need for an additional flag.</p>
<h3 id="being-a-target"><a class="header" href="#being-a-target">Being a target</a></h3>
<p>A file may be a target from the begining of the job execution, or it may become a target during job execution.
In the latter case, it is not a target until the point where it becomes one.
A file cannot stop being a target: once it has become a target, this is until the end of the job execution.</p>
<p>A file is a target from the begining of the job execution if it matches a <code>targets</code> or <code>side_targets</code> entry.</p>
<p>A file becomes a target when it is written to (with the meaning mentioned above) or when <code>lmake.target</code> or <code>ltarget</code> is called.</p>
<h3 id="being-a-dep"><a class="header" href="#being-a-dep">Being a dep</a></h3>
<p>A file may be a dep from the begining of the job execution, or it may become a dep during job execution.</p>
<p>A file cannot stop being a dep : once it has become a dep, this is until the end of the job execution.</p>
<p>A file is a dep from the begining of the job execution if it listed as a <code>deps</code> in the rule.</p>
<p>A file becomes a dep when it is read (with the meaning mentioned above) while not a target at that time.</p>
<h3 id="errors"><a class="header" href="#errors">Errors</a></h3>
<p>Some cases lead to errors, independently of the user script.</p>
<p>The first case is when there is clash between static declarations.
<code>targets</code>, <code>side_targets</code>, <code>side_deps</code> entries may or may not contain star stems.
In the latter case, and including the static deps listed in <code>deps</code>, they are static entries.
It is an error if the same file is listed several times as a static entry.</p>
<p>The second case is when a file is both a dep and a target.
You may have noticed that the definition above does not preclude this case, mostly because a file may start its life as a dep and become a target.
This is an error unless the file is finally unlinked (or was never created).</p>
<p>The third case is when a target was not declared as such.
<code>foo</code> can be declared as target by:</p>
<ul>
<li>matching a <code>targets</code> or <code>side_targets</code> entry.</li>
<li>calling <code>lmake.target('foo',allow=True)</code> (which is the default value for the <code>allow</code> arg).</li>
<li>executing <code>ltarget foo</code> in which the <code>-a</code> option is not passed.</li>
</ul>
<p>A target that is not declared is an error.</p>
<h3 id="processing-a-target"><a class="header" href="#processing-a-target">Processing a target</a></h3>
<p>Targets are normally erased before the start of the job execution, unless they are sources or flagged as <code>incremental</code>.
In case a target is also a dep, it is automatically flagged as <code>incremental</code>, whether it is an error or not.</p>
<p>If a job is run when a not <code>incremental</code> and not source target exists, it is deemed unreliable and is rerun.</p>
<h3 id="best-effort"><a class="header" href="#best-effort">Best effort</a></h3>
<p>Open-lmake tries to minimize the execution of jobs, but may sometimes miss a point and execute a job superfluously.
This may include erasing a file that has no associated production rule.
Unless a file is a dep of no job, open-lmake may rebuild it at any time, even when not strictly necessary.</p>
<p>In the case open-lmake determines that a file may have actually been written manually outside its control, it fears to overwrite a user-generated content.
In that case, open-lmake quarantines the file under the <code>LMAKE/quarantine</code> dir with its original name.
This quarantine mechanism, which is not necessary for open-lmake processing but is a facility for the user, is best effort.
There are cases where open-lmake cannot anticipate such an overwrite.</p>
<h2 id="tmp-dir"><a class="header" href="#tmp-dir">tmp dir</a></h2>
<p>The physical dir is:</p>
<ul>
<li>If <code>$TMPDIR</code> is set to empty, there is no tmp dir.</li>
<li>If open-lmake is supposed to keep this dir after job execution, it is a dir under <code>LMAKE/tmp</code>, determined by open-lmake (its precise value is reported by <code>lshow -i</code>).</li>
<li>Else if <code>$TMPDIR</code> is specified in the environment of the job, it is used. Note that it need not be unique as open-lmake will create a unique sub-dir within it.</li>
<li>Else, a dir determined by open-lmake lying in the <code>LMAKE</code> dir.</li>
</ul>
<p>Unless open-lmake is instructed to keep this dir, it is erased at the end of the job execution.</p>
<p>At execution time:</p>
<ul>
<li>If <code>$TMPDIR</code> is set to empty, it is suppressed from the environment and if the job uses the default tmp dir (usually <code>/tmp</code>), an error is generated.</li>
<li>Else <code>$TMPDIR</code> is set so that the job can use it to access the tmp dir.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="job-execution"><a class="header" href="#job-execution">Job execution</a></h1>
<p>Job are executed by calling the provided interpreter (generally python or bash).</p>
<p>When calling the interpreter, the following environment variable are automatically set, in addition to what is mentioned in the <code>environ</code> attribute (and the like).
They must remain untouched:</p>
<ul>
<li><code>$LD_AUDIT</code>          : A variable necessary for <a href="autodep.html">autodep</a> when it is set to <code>'ld_audit'</code></li>
<li><code>$LD_PRELOAD</code>        : A variable necessary for <a href="autodep.html">autodep</a> when it is set to <code>'ld_preload'</code> or <code>'ld_preload_jemalloc'</code></li>
<li><code>$LMAKE_AUTODEP_ENV</code> : A variable necessary for <a href="autodep.html">autodep</a> in all cases</li>
<li><code>$TMPDIR</code>            : The name of a dir which is empty at the start of the job.
If the temporary dir is not kept through the use of the <code>keep_tmp</code> attribute or the <code>-t</code> option, this dir is cleaned up at the end of the job execution.</li>
</ul>
<p>After job execution, a checksum is computed on all generated files, whether they are allowed or not, except ignored targets (those marked with the <code>ignore</code> attribute).</p>
<p>The job is reported ok if all of the following conditions are met:</p>
<ul>
<li>Job execution (as mentioned below) is successful.</li>
<li>All static targets are generated</li>
<li>All written files are allowed (either appear as target, side target or are dynamically allowed by a call to <code>ltarget</code> or <code>lmake.target</code>)</li>
<li>Nothing is written to stderr, or the <code>stderr_ok</code> attribute is set.</li>
</ul>
<h2 id="if-cmd-is-a-str"><a class="header" href="#if-cmd-is-a-str">if cmd is a <code>str</code></a></h2>
<p>Because this attribute undergo dynamic evaluation as described in the <code>cmd</code> rule attribute, there is not further specificities.</p>
<p>The job execution is successful (but see above) if the interpreter return code is 0.</p>
<h2 id="if-it-is-a-function-1"><a class="header" href="#if-it-is-a-function-1">if it is a function</a></h2>
<p>In that case, this attribute is called to run the job.</p>
<p>During evaluation, its global <code>dict</code> is populated to contain values referenced in these functions.
Values may come from (by order of preference):</p>
<ul>
<li>The stems, targets, deps, resources, side targets and side deps, as named in their respective <code>dict</code>.</li>
<li><code>stems</code>, <code>targets</code>, <code>deps</code>, <code>resources</code> that contain their respective whole <code>dict</code>.</li>
<li>if a single target was specified with the <code>target</code> attribute, that target is named <code>target</code>.</li>
<li>if a single dep was specified with the <code>dep</code> attribute, that dep is named <code>dep</code>.</li>
<li>Any attribute defined in the class, or a base class (as for normal python attribute access).</li>
<li>Any value in the module globals.</li>
<li>Any builtin value.</li>
<li>undefined variables are not defined, which is ok as long as they are not accessed (or they are accessed in a try/except block that handle the <code>NameError</code> exception).</li>
</ul>
<p>Static targets, deps, side targets and side deps are defined as <code>str</code>.
Star targets, side targets and side deps are defined as functions taking the star-stems as argument and returning the then fully specified file.
Also, in that latter case, the <code>reg_expr</code> attribute is defined as a <code>str</code> ready to be provided to the <code>re</code> module
and containing named (if corresponding star-stem is named) groups, one for each star-stem.</p>
<p>The job execution is successful (but see above) if no exception is raised.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="data-model"><a class="header" href="#data-model">Data model</a></h1>
<p>Open-lmake manages 2 kinds of objects: files and jobs.</p>
<p>The reason they are different objects is that jobs may have several targets, so there is no way to identify a file and the job that generates it.</p>
<h2 id="files"><a class="header" href="#files">Files</a></h2>
<h3 id="names"><a class="header" href="#names">names</a></h3>
<p>Files are identified by their canonical name, as seen from the root of the repo.
For example, all these code snippets will access the same file <code>a/b</code> (assume no symbolic links for now):</p>
<pre><code class="language-bash">cat a/b
cat a//b
cat ./a/b
cat a/./b
cat /repo/a/b # assume actual repo is /repo
cat c/../a/b  # assume c is a dir
cd a ; cat b
</code></pre>
<p>When spying the job (or when <code>ldepend</code>) is called, all these accesses will be converted to <code>a/b</code>.</p>
<p>Although targets are necessarily inside the repo, deps may be outside as some source dirs may declared outside the repo.
For such deps, their name is:</p>
<ul>
<li>the absolute path if the source dir is declared absolute</li>
<li>the relative path if the source dir is declared relative</li>
</ul>
<h3 id="symbolic-links"><a class="header" href="#symbolic-links">Symbolic links</a></h3>
<p>Open-lmake manages the physical view of the repo.
This means that symbolic links are genuine files, to the same extent as a regular file and their content is their target.
This means if <code>a</code> is a symbolic link to <code>b</code>, the content of <code>a</code> is <code>b</code>, not the content of <code>b</code>.</p>
<p>If <code>a</code> is a symbolic link to <code>b</code>, the code snippet <code>cat a</code> accesses 2 files:</p>
<ul>
<li><code>a</code></li>
<li><code>b</code></li>
</ul>
<p>This is what is expected : if either <code>a</code> or <code>b</code> is modified, the stdout of <code>cat a</code> may be modified.</p>
<h3 id="dirs"><a class="header" href="#dirs">Dirs</a></h3>
<p>Open-lmake manages a flat repo.
This means that <code>/</code> is an ordinary character.</p>
<p>As far as open-lmake is concerned, there is no difference between <code>a</code> being a dir and <code>a</code> not existing.</p>
<p>However, because dirs do exist on disk, it is impossible for <code>a</code> and <code>a/b</code> to exist simultaneously (i.e. exist as regular or symbolic link).
As a consequence, there is an implicit rule (Uphill) that prevents <code>a/b</code> from being buildable if <code>a</code> is buildable.</p>
<p>Also, because dirs cannot be made up-to-date, scripts reading dirs can hardly be made reliable and repeatable.
Such constructs are strongly discouraged:</p>
<ul>
<li>use of <code>glob.glob</code> in python</li>
<li>use of wildcard in bash</li>
</ul>
<h2 id="jobs"><a class="header" href="#jobs">Jobs</a></h2>
<p>Jobs are identified by their rule and stems (excluding star-stems).</p>
<p>They have a list of targets and a list of deps.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="rule-selection"><a class="header" href="#rule-selection">Rule selection</a></h1>
<p>When open-lmake needs to ensure that a file is up to date, the first action is to identify which rule, if any, must be used to generate it.
This rule selection process works in several steps described below.</p>
<p>A file is deemed buildable if the rule selection process leads to a job that generates the file.</p>
<h3 id="name-length"><a class="header" href="#name-length">Name length</a></h3>
<p>First, the length of the target name is checked agains <code>lmake.config.path_max</code>.
If the target name is longer, then the process stops here and the file is not buildable.</p>
<h3 id="sources"><a class="header" href="#sources">Sources</a></h3>
<p>The second step is to check target agains sources and source dirs.</p>
<p>If the target is listed as a source it is deemed buildable.
No execution is associated, though, the file modifications made by the user are tracked instead.</p>
<p>If the target is within a dir listed as a source dir (i.e. appears ending with a <code>/</code> in the manifest), it is deemed buildable if it exists.
If it does not exist, it is not buildable.
In both cases, the process stops here.</p>
<h3 id="up-hill-dir"><a class="header" href="#up-hill-dir">Up-hill dir</a></h3>
<p>The third step is to see if a up-hill dir (i.e. one of the dir along the dir path leading to the file) is (recursively) buildable.</p>
<p>If it is the case, the rule selection process stops here and the file is not buildable.</p>
<h3 id="antirule-and-sourcerule"><a class="header" href="#antirule-and-sourcerule"><code>AntiRule</code> and <code>SourceRule</code></a></h3>
<p>The following step is to match the target against <code>AntiRule</code>'s and <code>SourceRule</code>'s (ordered by their <code>prio</code> attribute, high values are considered first).
If one is found, the target is buildable if it matches a <code>SourceRule</code> and is not if it matches an <code>AntiRule</code>.</p>
<p>If it matches a <code>SourceRule</code> and it does not exist, it is still buildable, but has an error condition.</p>
<p>In all cases, as soon as such a match is found, the process stops here.</p>
<h3 id="plain-rules"><a class="header" href="#plain-rules">Plain rules</a></h3>
<p>The rules are split into groups. Each group contains all the rules that share a given <code>prio</code>.
Groups are ordered with higher <code>prio</code> first.</p>
<p>The following steps is executed for each group in order, until a rule is found. If none is found, the file declared not buildable.</p>
<h4 id="match-a-target"><a class="header" href="#match-a-target">Match a target</a></h4>
<p>For a given rule, the file is matched against each target in turn.
Static targets are tried first in user order, then star targets in user order, and matching stops at the first match.
Target order is made of <code>targets</code> and <code>target</code> entries in reversed MRO order (i.e. higher classes in the python class hierarchy are considered first),</p>
<p>If a target matches, the matching defines the value of the static stems (i.e. the stems that appear without a <code>*</code>).
Else, the rule does not apply.</p>
<h4 id="check-static-deps"><a class="header" href="#check-static-deps">Check static deps</a></h4>
<p>The definition of the static stems allow to compute :</p>
<ul>
<li>The other targets of the rule. Static targets become the associated file, star targets becomes regular expressions in which static stems are expanded.</li>
<li>Static deps by interpreting them as f-strings in which static stems and targets are defined.</li>
</ul>
<p>Static deps are then analyzed to see if the are (recursively) buildable, and if any is not buildable, the rule does not apply.</p>
<h4 id="group-recap"><a class="header" href="#group-recap">Group recap</a></h4>
<p>After these 2 previous steps have been done for the rules of a group, the applicable rules are analyzed the following way:</p>
<ul>
<li>If no rule apply, next group is analyzed.</li>
<li>If the file matches several rules as a sure target (i.e. a static target and all static deps are sure),
the file is deemed buildable, but if required to run, no job will be executed and the file will be in error.</li>
<li>If the file matches some rules as a non-sure target (i.e. a star target or a dep is not sure), the corresponding jobs are run.
If no such jobs generate the file, next group is analyzed.
If several of them generate the file, the file is buildable and in error.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="backends-1"><a class="header" href="#backends-1">Backends</a></h1>
<p>Backends are in charge of actually launching jobs when the open-lmake engine has identified that it had to be run.
It is also in charge of :</p>
<ul>
<li>Killing jobs when the open-lmake engine has identified it had to be so.</li>
<li>Scheduling jobs so as to optimize the runtime, based on some indications provided by the open-lmake engine.</li>
<li>Rescheduling jobs when new scheduling indications becomes available.</li>
</ul>
<p>A backend has to take decisions of 2 kinds:</p>
<ul>
<li>Is a job eligible for running ?
From a dep perspective, the open-lmake engine guarantees it is so.
But the job needs some resources to run and these resources may already be busy because of some other jobs already running.</li>
<li>If several jobs are eligible, which one(s) to actually launch.</li>
</ul>
<p>Each backend is autonomous in its decisions and has its own algorithm to take them.
However, generally speaking, they more or less work by following the following principles:</p>
<ul>
<li>For the first question, the backend maintain a pool of available resources and a job is eligible if its required resources can fit in the pool.
When launched, the required resources are subtracted from the pool and when terminated, they are returned to it.</li>
<li>For the second question, each job has an associated pressure provided by the open-lmake engine and the backend actually launches the eligible job with the highest pressure.</li>
</ul>
<p>The required resources are provided by the open-lmake engine to the backend as a <code>dict</code> which is the one of the job's rule after f-string interpretation.</p>
<p>The pressure is provided in the form of <code>float</code> computed as the accumulated ETE along the critical path to the final targets asked on the <code>lmake</code> command line.
To do that, future job ETE have to be estimated.
For jobs that have already run, last successful execution time is used.
When this information is not available, i.e. when the job has never run successfully, a moving average of the execution times of the jobs sharing the same rule is used as a best guess.</p>
<p>The backend also provides the current <a href="eta.html">ETA</a> of the final targets to allow the backends from different repo to take the best collective decision.</p>
<p>In addition to dedicated resources, all backends manage the following 3 resources:</p>
<ul>
<li><code>cpu</code> : The number of threads the job is expected to run in parallel. The backend is expected to reserve enough resources for such a number of threads to run smoothly.</li>
<li><code>mem</code> : The memory size the job is expected to need to run smoothly.
The backend is expected to ensure that such memory is available for the job.
Unit must be coherent with the one used in the configuration. It is MB by default.</li>
<li><code>tmp</code> : The size of necessary temporary disk space.
By default temporary disk space is not managed, i.e. <code>$TMPDIR</code> is set (to a freshly created empty empty dir which is cleaned up after execution)
with no size limit (other than the physical disk size) but no reservation is made in the backend.</li>
</ul>
<h2 id="resource-buckets"><a class="header" href="#resource-buckets">Resource buckets</a></h2>
<p>It may be wise to quantify resources with relatively large steps for resources <code>mem</code> and <code>tmp</code>, especially if these may be computed with a formula.</p>
<p>The reason is linked to the way the backends select jobs.
When a backend (actually the local, SGE and slurm backends essentially work the same way) search for the next job to launch, it walks through the available jobs to
find the eligible one with the highest priority.
When doing that, only jobs with different resources need to be compared as for a given set of resources, they can be pre-ordered by priority.
As a consequence, the running time is proportional to the number of different resources.
If the <code>mem</code> and <code>tmp</code> needed space is computed from some metrics, it may be very well possible that each job has a different number, leading to a selection process
whose time is proportional to the number of waiting jobs, which can be very high (maybe millions).</p>
<p>To help reduce this overhead, one may want to put jobs into buckets with defined values for these resources.
This is done by rounding these resources for grouping jobs into buckets.</p>
<p>When job is launche, however, the exact resources are reserved. Rounding is just applied to group jobs into bucket and improve the management of the queues.</p>
<h2 id="backend-conversion-to-local"><a class="header" href="#backend-conversion-to-local">backend conversion to local</a></h2>
<p>If a backend cannot be configured because the environment does not allow it (typically missing the SGE or slurm daemons), then:</p>
<ul>
<li>A Warning message is emmitted at configuration time.</li>
<li>Jobs supposed to start with such backends will be redirected to the local backend.</li>
<li>Resources are mapped on a best-effort basis, and if a resource does not exist or is insufficient in the local backend, job is started so as to be alone on the local host.</li>
</ul>
<h2 id="local-backend"><a class="header" href="#local-backend">Local backend</a></h2>
<p>The local backend launches jobs locally, on the host running the <code>lmake</code> command.
There is no cooperation between backends from different repos and the user has to ensure there is no global resource conflict.</p>
<p>This backend is configured by providing entries in the <code>lmake.config.backends.local</code> <code>dict</code>.
The key identifies the resource and the value is a <code>int</code> that identifies a quantity.</p>
<p>The local backend is used when either:</p>
<ul>
<li>The <code>backend</code> attribute is <code>'local'</code> (which is the default value).</li>
<li><code>lmake</code> is launched with the the <code>--local</code> option.</li>
<li>The required backend is not supported or not available.</li>
</ul>
<p>In the two latter cases, required resources are translated into local resources (best effort)
and if not possible (e.g. because a resource is not available locally or because special constraints cannot be translated), then only one such job can run at any given time.</p>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>The configuration provides the available resources :</p>
<ul>
<li>standard resoureces <code>cpu</code>, <code>mem</code> and <code>tmp</code></li>
<li>any user defined resource</li>
</ul>
<p>Each rule whose <code>backend</code> attribute is <code>'local'</code> provides a <code>resources</code> attribute such that:</p>
<ul>
<li>The key identifies a resource (which must match a resource in the configuration).</li>
<li>The value (possibly tailored by job through the use of the f-string syntax) is a <code>int</code> or a <code>str</code> that can be interpreted as <code>int</code>.</li>
</ul>
<p>The variable available to the job as global variables (python case) or environment variables (shell case) contains the actual quantity of resources allocated to this job.</p>
<p>The local backend ensures that the sum of all the resources of the running jobs never overshoots the configured available quantity.</p>
<p>By default, the configuration contains the 2 generic resources: <code>cpu</code> and <code>mem</code> configured respectively as the overall number of available cpus and the overall available memory (in MB).</p>
<ul>
<li><code>cpu</code> : The number of cpu as returned by <code>os.wched_getaffinity(0)</code>.</li>
<li><code>mem</code> : The physical memory size as returned by <code>s.sysconf('SC_PHYS_PAGES')*os.sysconf('SC_PAGE_SIZE')</code> in MB.</li>
</ul>
<p>Each rule has a default <code>resources</code> attribute requiring one CPU.</p>
<h2 id="sge-backend"><a class="header" href="#sge-backend">SGE backend</a></h2>
<p>The SGE backend connects to a SGE daemon to schedule jobs, which allows:</p>
<ul>
<li>a global scheduling policy (while the local backend only sees jobs in its own repo).</li>
<li>the capability to run jobs on remote hosts (while the local backend only run jobs on the local host).</li>
</ul>
<h3 id="command-line-option"><a class="header" href="#command-line-option">Command line option</a></h3>
<p>The command line option passed with <code>-b</code> or <code>--backend</code> is ignored.</p>
<h3 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h3>
<p>The configuration is composed of:</p>
<ul>
<li><code>bin</code>  : The dir in which to find SGE executables such as <code>qsub</code>. This entry must be specified.</li>
<li><code>cell</code> : The cell used by the SGE daemon. This is translated into <code>$SGE_CELL</code> when SGE commands are called.
By default, this is automatically determined by the SGE daemon.</li>
<li><code>cluster</code> : The cluster used by the SGE daemon. This is translated into <code>$SGE_CLUSTER</code> when SGE commands are called.
By default, this is automatically determined by the SGE daemon.</li>
<li><code>default_prio</code> : the priority used to submit jobs to the SGE daemon if none is specified on the <code>lmake</code> command line.</li>
<li><code>n_max_queued_jobs</code> : open-lmake scatters jobs according to the required resources and only submit a few jobs to SGE for each set of asked resources.
This is done to decrease the load of the SGE daemon as open-lmake might have millions of jobs to run and the typical case is that they tend to require only a small set of different resources
(helped in this by the limited precision on CPU, memory and temporary disk space requirements).
For each given set of resources, only the jobs with highest priorities are submitted to SGE, the other ones are retained by open-lmake so as to limit the number of waiting jobs in slurm queues
(the number of running job is not limited, though).
This attribute specifies the number of waiting jobs for each set of resources that open-lmake may submit to SGE.
If too low, the schedule rate may decrease because by the time taken, when a job finishes, for open-lmake to submit a new job, slurm might have exhausted its waiting queue.
If too high, the schedule rate may decrase because of the slurm daemon being overloaded.
A reasonable value probably lies in the 10-100 range.
Default is 10.</li>
<li><code>repo_key</code> : This is a string which is add in front of open-lmake job names to make SGE job names.
This key is meant to be a short identifier of the repo.
By default it is the base name of the repo followed by <code>:</code>.
Note that SGE precludes some characters and these are replaced by close looking characters (e.g. <code>;</code> instead of <code>:</code>).</li>
<li><code>root</code>         : The root dir of the SGE daemon. This is translated into <code>$SGE_ROOT</code> when SGE commands are called. This entry must be specified.</li>
<li><code>cpu_resource</code> : This is the name of a resource used to require cpu's.
For example if specified as <code>cpu_r</code> and the rule of a job contains <code>resources={'cpu':2}</code>, this is translated into <code>-l cpu_r=2</code> on the <code>qsub</code> command line.</li>
<li><code>mem_resource</code> : This is the name of a resource used to require memory in MB.
For example if specified as <code>mem_r</code> and the rule of a job contains <code>resources={'mem':'10M'}</code>, this is translated into <code>-l mem_r=10</code> on the <code>qsub</code> command line.</li>
<li><code>tmp_resource</code> : This is the name of a resource used to require memory temporary disk space in MB.
For example if specified as <code>tmp_r</code> and the rule of a job contains <code>resources={'tmp':'100M'}</code>, this is translated into <code>-l tmp_r=100</code> on the <code>qsub</code> command line.</li>
</ul>
<h3 id="resources-1"><a class="header" href="#resources-1">Resources</a></h3>
<p>The <code>resources</code> rule attributes is composed of :</p>
<ul>
<li>standard resources <code>cpu</code>, <code>mem</code> and <code>tmp</code>.</li>
<li><code>hard</code> : <code>qsub</code> options to be used after a <code>-hard</code> option.</li>
<li><code>soft</code> : <code>qsub</code> options to be used after a <code>-soft</code> option.</li>
<li>any other resource passed to the SGE daemon through the <code>-l</code> <code>qsub</code> option.</li>
</ul>
<h2 id="slurm-backend"><a class="header" href="#slurm-backend">Slurm backend</a></h2>
<p>The slurm backend connects to a slurm daemon to schedule jobs, which allows :</p>
<ul>
<li>a global scheduling policy (while the local backend only sees jobs in its own repo).</li>
<li>the capability to run jobs on remote hosts (while the local backend only run jobs on the local host).</li>
</ul>
<h3 id="command-line-option-1"><a class="header" href="#command-line-option-1">Command line option</a></h3>
<p>The only option that can be passed from command line (<code>-b</code> or <code>--backend</code>) is the priority through the <code>-p</code> options of <code>qsub</code>.</p>
<p>Hence, the command line option must directly contain the priority to pass to <code>qsub</code>.</p>
<h3 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h3>
<p>The configuration is composed of :</p>
<ul>
<li>
<p><code>config</code> : The slurm configuration file to use to contact the slurm controller. By default, <code>/etc/slurm/slurm.conf</code> is used.</p>
</li>
<li>
<p><code>lib_slurm</code> : The slurm dynamic library. If no <code>/</code> appears, <code>$LD_LIBRARY_PATH</code> (as compiled in) and system default lib dirs are searched. By default, <code>libslurm.so</code> is used.</p>
</li>
<li>
<p><code>n_max_queued_jobs</code> : open-lmake scatters jobs according to the required resources and only submit a few jobs to slurm for each set of asked resources.
This is done to decrease the load of the slurm daemon as open-lmake might have millions of jobs to run and the typical case is that they tend require only a small set of different resources
(helped in this by the limited precision on CPU, memory and temporary disk space requirements).
for each given set of resources, only the jobs with highest priorities are submitted to slurm, the other ones are retained by open-lmake so as to limit the number of waiting jobs in slurm queues
(the number of running job is not limited, though).
This attribute specifies the number of waiting jobs for each set of resources that open-lmake may submit to slurm.
If too low, the schedule rate may decrease because by the time taken, when a job finishes, for open-lmake to submit a new job, slurm might have exhausted its waiting queue.
If too high, the schedule rate may decrase because of the slurm daemon being overloaded.
A reasonable value probably lies in the 10-100 range.
Default is 10.</p>
</li>
<li>
<p><code>repo_key</code> : This is a string which is add in front of open-lmake job names to make slurm job names.
This key is meant to be a short identifier of the repo.
By default it is the base name of the repo followed by <code>:</code>.</p>
</li>
<li>
<p><code>use_nice</code>:
open-lmake has and advantage over slurm in terms of knowledge: it knows the deps, the overall jobs necessary to reach the asked target and the history of the time taken by each job.
This allows it to anticipate the needs and know, even globally when numerous <code>lmake</code> commands run, in the same repo or on several ones, which jobs should be given which priority.
Note that open-lmake cannot leverage the dep capability of slurm as deps are dynamic by nature:</p>
<ul>
<li>new deps can appear during job execution, adding new edges to the dep graph,</li>
<li>jobs can have to rerun, so a dependent job may not be able to start when its dep is done,</li>
<li>and a job can be steady, so a dependent job may not have to run at all.</li>
</ul>
<p>The way it works is th following:</p>
<ul>
<li>First open-lmake computes and <a href="eta.html">ETA</a> for each <code>lmake</code> command. This ETA is a date, it is absolute, and can be compared between commands running in different repos.</li>
<li>Then it computes a pressure for each job. The pressure is the time necessary to reach the asked target of the <code>lmake</code> command given the run time for all intermediate jobs
(including the considered job).</li>
<li>The subtraction of the pressure from the ETA gives a reasonable and global estimate of when it is desirable to schedule a job, and hence can be used as a priority.</li>
</ul>
<p>The way to communicate this information is to set for each job a nice value that represents this priority.
Because this may interfere with other jobs submitted by other means, this mechanism is made optional,
although it is much better than other scheduling policies based on blind guesses of the futur (such as fair-share, qos, etc.).</p>
</li>
</ul>
<p>There are 2 additional parameters that you can set in the <code>PriorityParams</code> entry of the slurm configuration in the form of param=value, separated by <code>,</code>:</p>
<ul>
<li><code>time_origin</code>: as the communicated priority is a date, we need a reference point.
This reference point should be in the past, not too far, to be sure that generated nice values are in the range <code>0</code> - <code>1&lt;&lt;31</code>.</li>
<li>open-lmake sometimes generates dates in the past when it wrongly estimates a very short ETA with a high pressure.
Taking a little bit of margin of a few days is more than necessary in all practical cases.
Default value is 2023-01-01 00:00:00.
Date is given in the format YYYY-MM-DD HH:MM optionally followed by +/-HH:MM to adjust for time zone.
This is mostly ISO8601 except the T between date and time replaced by a space, which is more readable and corresponds to mainstream usage.</li>
<li><code>nice_factor</code>: this is the value that the nice value increases each second. It is a floating point value.
If too high, the the nice value may wrap too often. If too low, job scheduling precision may suffer.
The default value is <code>1</code> which seems to be a good compromise.</li>
</ul>
<p>Overall, you can ignore these parameters for open-lmake internal needs, the default values work fine.
They have been implemented to have means to control interactions with jobs submitted to slurm from outside open-lmake.</p>
<h3 id="resources-2"><a class="header" href="#resources-2">Resources</a></h3>
<p>The <code>resources</code> rule attributes is composed of:</p>
<ul>
<li>standard resources <code>cpu</code>, <code>mem</code> and <code>tmp</code>.</li>
<li><code>excludes</code> <code>features</code>, <code>gres</code>, <code>licence</code>, <code>nodes</code>, <code>partition</code>, <code>qos</code>, <code>reserv</code> : these are passed as is to the slurm daemon.
For heterogeneous jobs, these attribute names may be followed by an index identifying the task (for example <code>gres0</code>, <code>gres1</code>).
The absence of index is equivalent to index 0.</li>
<li>any other resource passed to the slurm daemon as <code>licenses</code> if such licenses are declared in the slurm configuration, else as <code>gres</code>.</li>
</ul>
<h3 id="command-line-option-2"><a class="header" href="#command-line-option-2">Command line option</a></h3>
<p>The command line option passed with the <code>-b</code> or <code>--backend</code> option is a space separate list of options.
The following table describes supported option, with a description when it does not correspond to the identical option of <code>srun</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Short option</th><th>Long option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>-c</code></td><td>cpus-per-task</td><td>cpu resource to use</td></tr>
<tr><td></td><td>mem</td><td>mem resource to use</td></tr>
<tr><td></td><td>tmp</td><td>tmp resource to use</td></tr>
<tr><td><code>-C</code></td><td>constraint</td><td></td></tr>
<tr><td><code>-x</code></td><td>exclude</td><td></td></tr>
<tr><td></td><td>gres</td><td></td></tr>
<tr><td><code>-L</code></td><td>licenses</td><td></td></tr>
<tr><td><code>-w</code></td><td>nodelist</td><td></td></tr>
<tr><td><code>-p</code></td><td>partition</td><td></td></tr>
<tr><td><code>-q</code></td><td>qos</td><td></td></tr>
<tr><td></td><td>reservation</td><td></td></tr>
<tr><td><code>-h</code></td><td>help</td><td>print usage         )</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>Namespaces are used to isolate jobs.
This is used to provide the semantic for the <code>chroot_dir</code>, <code>repo_view</code>, <code>tmp_view</code> and <code>views</code> attributes.</p>
<p>In that case, pid's are also isolated which allow reliable job end : when the top-level process exits, the namespaces are destroyed and no other process can survive.
This guarantees that no daemon is left behind, uncontrolled.</p>
<p>Note that this is true even when <code>chroot_dir</code> is <code>'/'</code>, which otherwise provides no other effect by itself.</p>
<p>Namespaces can be used in the following situations :</p>
<ul>
<li>Open-lmake provides a cache mechanism allowing to prevent executing a job which was already executed in the same or another repo.
However, some jobs may use and record absolute paths.
In that case, the cache will be inefficient as the result in a repo is not identical to the one in another repo.
This is current practice, in particular in the EDA tools community (which may be rather heavy and where caching is mostly desirable).
Using the <code>repo_view</code> attribute is a good way to work around this obstacle.</li>
<li>Open-lmake tracks all deps inside the reposity and listed source dirs. But it does not track external deps, typically the system (e.g.the <code>/usr</code> dir).
However, the <code>chroot_dir</code> attribute is part of the command definition and a job will be considered out of date if its value is modified.
Hence, this can be used as a marker representing the whole system to ensure jobs are rerun upon system updates.</li>
<li>some softwares (e.g. EDA tools) are designed to operate on a dir rather than dealing with input files/dirs and output files/dirs.
This goes against reentrancy and thus reliability, repeatability, parallelism etc.
This problem can be solved with symbolic links if they are allowed.
In all cases, it can be solved by using the <code>tmp_view</code> and copying data back and forth between the repo and the tmp dir.
Or, more efficient, it can be solved by adequately mapping a logical steady file or dir to a per job physical file or dir (respectively).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="autodep-1"><a class="header" href="#autodep-1">Autodep</a></h1>
<p>Autodep is a mechanism through which jobs are spied to automatically detect disk accesses.
From this information open-lmake can determine if accesses were within the constraints provided by the rule and can list all deps.</p>
<h2 id="spying-methods"><a class="header" href="#spying-methods">Spying methods</a></h2>
<p>There exists two classes of spying methods.
Not all methods are supported on all systems, though.</p>
<h3 id="spying-methods-based-on-libc-calls"><a class="header" href="#spying-methods-based-on-libc-calls">Spying methods based on <code>libc</code> calls</a></h3>
<p>This consists in spying all calls the the <code>libc</code>.
Several mechanisms can be used to do so.</p>
<p>All of them consist in diverting the calls to the <code>libc</code> that access files (typically <code>open</code>, but there are about a hundred of them) to a piggy-back code
that records the access before handling over to the real <code>libc</code>.
They differ in the methods used to divert these calls to the autodep code.</p>
<p>This class of methods is fast as there is no need to switch context at each access.
Moreover, the accessed file is first scanned to see if it is a system file (such as in <code>/usr</code>), in which case we can escape very early from the recording mechanism.
And in practice, such accesses to system files are by far the most common case.</p>
<p>One of the major drawbacks is that it requires the <code>libc</code> to be dynamically linked. While <code>libc</code> static linking is very uncommon, it does happen.</p>
<h3 id="ld_audit"><a class="header" href="#ld_audit"><code>$LD_AUDIT</code></a></h3>
<p>Modern Linux dynamic linkers implement an auditing mechanism.
This works by providing hooks at dynamic link edition time (by setting the environment variable <code>$LD_AUDIT</code>) when a file is loaded, when a symbol is searched, when a reference is bound, etc.
In our case, we trap all symbol look up into the <code>libc</code> and interesting calls (i.e. those that access files) are diverted at that time.</p>
<p>However, some linkers do not seem to honor this auditing API.
For example, programs compiled by the rust compiler (including <code>rustc</code> itself) could not be made working.</p>
<p>Such auditing code is marginally intrusive in the user code as, while lying in the same address space, it is in a different segment.
For example it has its own <code>errno</code> global variable.</p>
<p>If available, this is the default method.</p>
<h3 id="ld_preload"><a class="header" href="#ld_preload"><code>$LD_PRELOAD</code></a></h3>
<p>This method consists in pre-loading our spying library before the <code>libc</code>.
Because it is loaded before and contains the same symbols as the <code>libc</code>, these calls from the user application are diverted to our code.</p>
<p>this is a little bit more intrusive (e.g. the <code>errno</code> variable is shared) and this is the default method if <code>$LD_AUDIT</code> is not available.</p>
<h3 id="ld_preload-with-jemalloc"><a class="header" href="#ld_preload-with-jemalloc"><code>$LD_PRELOAD</code> with <code>jemalloc</code></a></h3>
<p>The use of <code>jemalloc</code> creates a chicken and egg problem at start up.
The reason is that the spying code requires the use of <code>malloc</code> at start up, and <code>jemalloc</code> (which is called in lieu of <code>malloc</code>) accesses a configuration file at start up.
A special implementation has been devised to handle this case, but is too fragile and complex to make it the default <code>$LD_PRELOAD</code> method.</p>
<h3 id="spying-methods-based-on-system-calls"><a class="header" href="#spying-methods-based-on-system-calls">Spying methods based on system calls</a></h3>
<p>The principle is to use <code>ptrace</code> (the system call used by the <code>strace</code> utility) to spy user code activity.</p>
<p>This is almost non-intrusive.
In one case, we have seen a commercial tool reading <code>/proc/self/status</code> to detect such a <code>ptrace</code>ing process, and it stopped, thinking it was being reverse engineered.
Curiously, it did not detect <code>$LD_PRELOAD</code>...</p>
<p>The major drawback is performance wise: the impact is more significant as there is a context switch at each system call.
<code>BPF</code> is used, if available, to decrease the number of useless context switches, but it does not allow to filter out on file name, so it is impossible to have an early ignore of system files.</p>
<h2 id="what-to-do-with-accesses"><a class="header" href="#what-to-do-with-accesses">What to do with accesses</a></h2>
<p>There are 2 questions to solve :</p>
<ul>
<li>Determine the <code>cwd</code>. Because accesses may be relative to it (and usually are), the spying code must have a precise view of the <code>cwd</code>.
This requires to intercept <code>chdir</code> although no access is to be reported.</li>
<li>Symbolic link processing.
Open-lmake lies in the physical world (and there is no way it can do anything else) and must be aware of any symbolic link traversal.
This includes the ones on the dir path.
So the spying code includes a functionality that resembles to <code>realpath</code>, listing all traversed links.</li>
</ul>
<p>Lying in the physical world means that symbolic links are handled like plain data files, except that there is a special bit that says it is a symbolic link.
Its content is its target.
For example, after the code sequence:</p>
<pre><code>cd a
cat b
</code></pre>
<p>where <code>b</code> is symbolic link to <code>c</code>, 2 deps are recorded:</p>
<ul>
<li><code>a/b</code> (a symbolic link), as if it is modified, job must be rerun.</li>
<li><code>a/c</code> (a plain data file), same reason.</li>
</ul>
<p>Generally speaking, read a file makes it a dep, writing to it makes it a target.
Of course, reading a file that has been written doe not make it a dep any more.</p>
<h2 id="how-to-report-accesses"><a class="header" href="#how-to-report-accesses">How to report accesses</a></h2>
<p>When a job is run, a wrapper (called <code>job_exec</code>) is launched that launches the user process.</p>
<p><code>job_exec</code> has several responsibilities, among which :</p>
<ul>
<li>Prepare the user environment for the user code (environment variables, cwd, namespace if necessary, etc.).</li>
<li>Receive the accesses made by the user code (through a socket) and record them.</li>
<li>Determine what is a dep, what is a target etc.</li>
<li>Report a job digest to the server (the central process managing the dep DAG).</li>
</ul>
<p>The major idea is that when an access is reported by the user code (in the case of <code>libc</code> call spying), there is no reply from <code>job_exec</code> back to the user code, so no round trip delay is incurred.</p>
<h2 id="deps-order-is-kept-as-well"><a class="header" href="#deps-order-is-kept-as-well">Deps order is kept as well</a></h2>
<p>Remember that when a job is run, its deps list is <strong>approximative</strong>.
It is the one of the previous run, which had different file contents.
For example, a <code>.c</code> may have changed, including a <code>#include</code> directive.
In case there are 2 deps <code>d1</code> and <code>d2</code>, and <code>d1</code> was just discovered, it may be out-of date and the job ran with a bad content for <code>d1</code>.</p>
<p>Most of the time, this is harmless, but sometimes, it may happen that <code>d2</code> is not necessary any more (because old <code>d1</code> content had <code>#include "d2"</code> and new one does not).
In that case, this job must be rerun with the new content od <code>d1</code>, even if <code>d2</code> is in error, as <code>d2</code> might disappaer as de dep.</p>
<p>This may only occurs if <code>d2</code> was accessed <strong>after</strong> <code>d1</code> was accessed. If <code>d2</code> was accessed before <code>d1</code>, it is safe to say the job cannot run because <code>d2</code> is in error: it will never disappear.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="critical-deps"><a class="header" href="#critical-deps">Critical deps</a></h1>
<p>The question of critical deps is a performance only question.
Semantically, whether a dep is critical or not has no impact on the content of the files built by open-lmake.</p>
<p>During dep analysis, when a dep (call it <code>dep1</code>) has been used and turns out to be out-of-date, open-lmake must choose between 2 strategies regarding the deps that follow:</p>
<ul>
<li>One possibility is to anticipate that the modification of <code>dep1</code> has no impact on the list of following deps.
With such an anticipation, open-lmake will keep the following deps, i.e. when ensuring that deps are up-to-date before launching a job, open-lmake will launch all necessary jobs to rebuild
all deps in parallel, even if the deps have been explicitly declared parallel.</li>
<li>Another possivility is to anticipate that such a modification of <code>dep1</code> will drastically change the list of following deps.
With such an anticipation, as soone as open-lmake sees a modified dep, it will stop its analysis as the following deps, acquired with an out-of-date content of <code>dep1</code> is meaningless.</li>
</ul>
<p>The first strategy is speculative: launch everything you hear about, and we will see later what is useful.
The second strategy is conservative: build only what is certain to be required.</p>
<p>Generally speaking, a speculative approach is much better, but there are exceptions.</p>
<p>Typical use of critical deps is when you have a report that is built from the results of tests provided by a list of tests (a test suite).</p>
<p>For example, let's say you have:</p>
<ul>
<li>2 tests whose reports are built in <code>test1.rpt</code> and <code>test2.rpt</code> by some rather heavy means</li>
<li>a test suite <code>test_suite.lst</code> listing these reports</li>
<li>a rule that builds <code>test_suite.rpts</code> by collating reports listed in <code>test_suite.lst</code></li>
</ul>
<p>In such a situation, the rule building <code>test_suite.rpts</code> typically has <code>test_suite.lst</code> as a static dep but the actual reports <code>test1.rpt</code> and <code>test2.rpt</code> are
hidden deps, i.e. automatically discovered when building <code>test_suite.rpts</code>.</p>
<p>Suppose now that you make a modification that makes <code>test2.rpt</code> very heavy to generate. Knowing that, you change your test suite so list a lighter <code>test3.rpt</code> instead.
The succession of jobs would then be the following:</p>
<ul>
<li><code>test1.rpt</code> and <code>test2.rpt</code> are rebuilt as they are out-of-date after your modification.</li>
<li><code>test_suite.rpts</code> is rebuilt to collate theses reports.</li>
<li>Open-lmake then sees that <code>test3.rpt</code> is needed instead of <code>test2.rpt</code>.</li>
<li>Hence, <code>test3.rpt</code> is (re)built.</li>
<li><code>test_suite.rpts</code> is finally built from <code>test1.rpt</code> and <code>test3.rpt</code>.</li>
</ul>
<p>There are 2 losses of performance here:</p>
<ul>
<li><code>test2.rpt</code> is unnecessarily rebuilt.</li>
<li><code>test1.rpt</code> and <code>test3.rpt</code> are rebuilt sequentially.</li>
</ul>
<p>The problem lies in the fact that <code>test1.rpt</code> and <code>test2.rpt</code> are rebuilt before open-lmake had a chance to re-analyze the test suite showing that the new tests are test1 and test3.
Generally speaking, this is a good strategy : such modifications of the dep graph happens rather rarely and speculating that it is pretty stable by building known deps before
launching a job is the right option.
But here, because collating is very light (something like just executing <code>cat</code> on the reports), it is better to check <code>tests_suilte.lst</code> first,
and if it changed, rerun the collation before ensuring (old) tests have run.</p>
<p>This is the purpose of the <code>critical</code> flag.
Such a flag can either be passed when declaring static deps in a rule, or dynamically using <code>lmake.depend</code> or <code>ldepend</code>.</p>
<p>The collating rule would look like:</p>
<ul>
<li>Set the <code>critial</code> flag on <code>test_suite.lst</code> (before or after actually reading it, this has no impact).</li>
<li>Read <code>test_suite.lst</code>.</li>
<li>Call <code>ldepend</code> on the reports listed in <code>test_suite.lst</code>.
This is optional, just to generate parallel deps instead of automatic sequential deps (but if done, it must be before actually reading the reports).</li>
<li>Collate reports listed in <code>test_suite.lst</code>.</li>
</ul>
<p>And the succession of job would be:</p>
<ul>
<li><code>test_suite.rpts</code> is rebuilt before analyzing <code>test1.rpt</code> and <code>test2.rpt</code> because <code>test_suite.lst</code> has changed.</li>
<li>Open-lmake sees that <code>test3.rpt</code> is needed instead of <code>test2.rpt</code>.</li>
<li>Hence, <code>test1.rpt</code> and <code>test3.rpt</code> are (re)built in parallel.</li>
<li><code>test_suite.rpts</code> is finally built from <code>test1.rpt</code> and <code>test3.rpt</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="eta"><a class="header" href="#eta">ETA</a></h1>
<p>An ETA estimation is made possible because the execution time for each job is recorded in open-lmake book-keeping after all successful runs
(if a job ends in error, it may very well have been much faster and the previous execution time is probably a better estimate than this one).
When a job has never run successfully, an ETE is used instead of its actual execution time by taking a moving average of all the jobs of the same rule.</p>
<p>This being given, a precise ETA would require a fake execution of the jobs yet to be run which can take all deps and resources into account.
But this is way too expensive, so a faster process must be done, even at the expense of precision.</p>
<p>In all cases, the ETA assumes that no new hidden deps are discovered and that no file is steady so that all jobs currently remaining will actually be executed.</p>
<p>2 approaches can be considered to estimate the time necessary to carry out remaining jobs :</p>
<ul>
<li>Resources limited : deps are ignored, only resources are considered.
Roughly, the time is the division of the quantity of resources necessary by the quantity of resources available.
For example, if you need 10 minutes of processing and you have 2 cpus, this will last 10/2=5 minutes.</li>
<li>Deps limited : resources are ignored and only deps are considered. This means you only look at the critical path.
For example if you need to run a 2 minutes job followed by a 3 minutes job, and in parallel you must run a 4 minutes job, this will last 2+3=5 minutes.</li>
</ul>
<p>Open-lmake uses the first approach.
For that it measures the parallelism of each job while running and the ETA is computed after the sum of the costs of all waiting and running jobs,
the cost being the execution time divided by the observed parallelism.
Jobs running for the first time inherit a moving average of the last 100 run jobs of the same rule.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="video-mode"><a class="header" href="#video-mode">Video mode</a></h1>
<p>If lmake is connected to a terminal, then the terminal foreground and background colors are probed and if the brightness of the background color is less than that of the foreground color,
video mode is set to normal, else it is set to reverse.</p>
<p>In that case, lmake output is colored and the (configurable) color set is chosen depending on video mode.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="meta-data"><a class="header" href="#meta-data">Meta data</a></h1>
<p>The <code>LMAKE</code> dir at the root of the repo contains numerous information that may be handy for the user.</p>
<p>It also contains a <code>lmake</code> dir containing private data for open-lmake's own usage.</p>
<p><code>LMAKE/environ</code> and <code>LMAKE/manifest</code> can be freely used in jobs and are considered as sources if they are listed in <code>lmake.manifest</code>, which is automatic by default.</p>
<h3 id="lmakeconfig_deps-lmakerules_deps-and-lmakesources_deps"><a class="header" href="#lmakeconfig_deps-lmakerules_deps-and-lmakesources_deps"><code>LMAKE/config_deps</code>, <code>LMAKE/rules_deps</code> and <code>LMAKE/sources_deps</code></a></h3>
<p>These files contain a list of files that open-lmake has read to process <code>Lmakefile.py</code> when reading each section (config, rules and sources).</p>
<p>They contain several types of lines, depending on the first char:</p>
<ul>
<li><code>#</code>: comment line</li>
<li><code>*</code>: line contains the open-lmake installation dir</li>
<li><code>+</code>: line contains an existing file that was read</li>
<li><code>!</code>: line contains a non-existing file that was accessed</li>
</ul>
<p>These contents are then used to determine if each section must be refreshed when a new <code>lmake</code> command is run.</p>
<h3 id="lmakeconfig"><a class="header" href="#lmakeconfig"><code>LMAKE/config</code></a></h3>
<p>This file contains a description of the <code>lmake.config</code> <code>dict</code> as it has been understood by open-lmake after having processed <code>Lmakefile.py</code>.</p>
<h3 id="lmakeenviron"><a class="header" href="#lmakeenviron"><code>LMAKE/environ</code></a></h3>
<p>This file contains the list of environment variables actually used in <code>Lmakefile.py</code> in the form of lines containing <code>&lt;key&gt;=&lt;value&gt;</code>.</p>
<h3 id="lmakemanifest"><a class="header" href="#lmakemanifest"><code>LMAKE/manifest</code></a></h3>
<p>This file contains a description of the sources as it has been understood by open-lmake after having processed <code>Lmakefile.py</code>.</p>
<h3 id="lmakematching"><a class="header" href="#lmakematching"><code>LMAKE/matching</code></a></h3>
<p>This file contains a description of the matching performed by open-lmake when looking for rules to generate a file.
It is composed of matching entries.</p>
<p>Each matching entry starts with a header providing a prefix and a suffix.
Files matching the prefix and suffix are matched against the rules listed underneath.</p>
<p>The prefix and suffix are given in the form <code>&lt;prefix&gt;*&lt;suffix&gt;' to mimic shell patterns. However, in this case, the </code>*` may match a negative number of characters, i.e. the prefix and the suffix may overlap.</p>
<p>The listed rules are provided as:</p>
<ul>
<li>Its priority: if a rule at given priority match and generate the file, rules of lower priority are not tried.</li>
<li>Its name.</li>
<li>The target corresponding to this prefix/suffix pair.</li>
</ul>
<h3 id="lmakerules"><a class="header" href="#lmakerules"><code>LMAKE/rules</code></a></h3>
<p>This file contains a description of the rules as they have been understood by open-lmake after having processed <code>Lmakefile.py</code>.</p>
<h3 id="lmakeoutputsdatetime"><a class="header" href="#lmakeoutputsdatetime"><code>LMAKE/outputs/&lt;date&gt;/&lt;time&gt;</code></a></h3>
<p>This file contains a transcript of the <code>lmake</code> command that has been run at <code>&lt;time&gt;</code> on <code>&lt;day&gt;</code>.
Such logs are kept for a number of days given in <code>lmake.config.console.history_days</code>.</p>
<h3 id="lmakelast_output"><a class="header" href="#lmakelast_output"><code>LMAKE/last_output</code></a></h3>
<p>This file is a symbolic link to the last transcript.</p>
<h3 id="lmaketargets"><a class="header" href="#lmaketargets"><code>LMAKE/targets</code></a></h3>
<p>This file contains the targets that have been required by <code>lmake</code> commands in chronological order (with duplicates removed).</p>
<h3 id="lmakeversion"><a class="header" href="#lmakeversion"><code>LMAKE/version</code></a></h3>
<p>This file contains a state-recording version of open-lmake.
If the recorded version does not match the used version, none of the open-lmake commands can be used.</p>
<h3 id="lmakedebug"><a class="header" href="#lmakedebug"><code>LMAKE/debug</code></a></h3>
<p>This dir contains a sub-dir for each job <code>ldebug</code> was used for.
These sub-dirs are named after the job id as displayed by <code>lshow -i</code>.</p>
<h3 id="lmaketmp"><a class="header" href="#lmaketmp"><code>LMAKE/tmp</code></a></h3>
<p>This dir contains a sub-dir for each job which was run while keeping its tmp dir.
These sub-dirs are named after the job id as displayed by <code>lshow -i</code>.</p>
<h3 id="lmakequarantine"><a class="header" href="#lmakequarantine"><code>LMAKE/quarantine</code></a></h3>
<p>This dir contains all files that have been quarantined.
A file is quantantined when open-lmake decides it must be unlinked and it contains manual modifications, i.e. modifications made outside the control of open-lmake.
In that case, in order to be sure that no user work is lost, the file is quarantined in this dir rather than unlinked.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="commands"><a class="header" href="#commands">Commands</a></h1>
<p>Open-lmake is a package containing several commands.</p>
<p>The full documentation of these commands can also be obtained by running <code>man &lt;command&gt;</code>.</p>
<h2 id="command-execution"><a class="header" href="#command-execution">command execution</a></h2>
<p>Most commands (<code>ldebug</code>, <code>lforget</code>, <code>lmake</code>, <code>lmark</code> and <code>lshow</code>) do not execute directly but instead connect to a server, or launch one if none already run.</p>
<p>The reason is that although several of these commands can run at the same time (including several times the same one, in particular several <code>lmake</code>), they all must run in the same process to
stay coherent.</p>
<p>Among these commands, all of them except <code>lmake</code> run mostly instantaneously. So the serverr mostly exist to be able to run any of these commands while one or several instances of <code>lmake</code> are
already running.</p>
<p>The (unique) server is created automatically when necessary and dies as soon as no more needed.
So under normal situations, one does not have to even be aware of the existence of such a server.</p>
<p>Although the server has been carefully coded to have a very low start overhead, it may happen in rare circumstances, though, that pre-launching a server (<code>&lt;installation dir&gt;/_bin/lmakeserver</code>)
leads to improved performances by avoiding to relaunch a server for each command.
In such cases, the server must be run with no argument.</p>
<p>However, if, under a particular cicumstance, the server must be killed, best is to use signal 1 (SIGHUP) or 2 (SIGINT) as this will force the server to smoothly kill all running jobs.
Other signals are not managed and will lead to the server dying abruptly, potentially leaving a lot of running jobs.
This has no semantic impact as these jobs will be considered out-of-date and will rerun, but may incur a waste of resources.</p>
<h2 id="commands-to-control-build-execution"><a class="header" href="#commands-to-control-build-execution">commands to control build execution</a></h2>
<p>These commands are meant to be run by the user outside jobs.
They are:</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Short description</th></tr></thead><tbody>
<tr><td><a href="man/man1/lautodep.html"><code>lautodep</code></a></td><td>run a script in an execution environmeent while recording accesses</td></tr>
<tr><td><a href="man/man1/ldebug.html"><code>ldebug</code></a></td><td>run a job in a debug environement</td></tr>
<tr><td><a href="man/man1/lforget.html"><code>lforget</code></a></td><td>forget history of a job</td></tr>
<tr><td><a href="man/man1/lmake.html"><code>lmake</code></a></td><td>run necessary jobs to ensure a target is up-to-date</td></tr>
<tr><td><a href="man/man1/lmark.html"><code>lmark</code></a></td><td>mark a job to alter its behavior w.r.t. <code>lmake</code></td></tr>
<tr><td><a href="man/man1/lrepair.html"><code>lrepair</code></a></td><td>repair a broken repo</td></tr>
<tr><td><a href="man/man1/lshow.html"><code>lshow</code></a></td><td>show various informations of a job</td></tr>
<tr><td><a href="man/man1/xxhsum.html"><code>xxhsum</code></a></td><td>compute a checksum on a file</td></tr>
</tbody></table>
</div>
<h2 id="commands-to-interact-with-open-lmake-from-within-jobs"><a class="header" href="#commands-to-interact-with-open-lmake-from-within-jobs">commands to interact with open-lmake from within jobs</a></h2>
<p>These commands are meant to be run from within a job.
They are:</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Short description</th></tr></thead><tbody>
<tr><td><a href="man/man1/lcheck_deps.html"><code>lcheck_deps</code></a></td><td>check currently seen deps are all up-to-date and kill job if not the case</td></tr>
<tr><td><a href="man/man1/ldecode.html"><code>ldecode</code></a></td><td>retrieve value associated with a code</td></tr>
<tr><td><a href="man/man1/ldepend.html"><code>ldepend</code></a></td><td>generate deps</td></tr>
<tr><td><a href="man/man1/lencode.html"><code>lencode</code></a></td><td>retrieve/generate a code associated with a value</td></tr>
<tr><td><a href="man/man1/lrun_cc.html"><code>lrun_cc</code></a></td><td>run a compilation, ensuring include dirs and lib dirs exist</td></tr>
<tr><td><a href="man/man1/ltarget.html"><code>ltarget</code></a></td><td>generate targets</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="experimental-features"><a class="header" href="#experimental-features">Experimental features</a></h1>
<p>The features described herein are experimental as long as they have not been thoroughly used.</p>
<p>If you plan to use one of those, best is to be in contact with the development team to:</p>
<ul>
<li>get dedicated support</li>
<li>make necessary evolutions so as to fit your needs as they appear</li>
</ul>
<p>As a consequence, it is most probable that the specifications will evolve in a non-backward compatible way.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="cache-1"><a class="header" href="#cache-1">Cache</a></h1>
<p>Several cache mechanisms will be implemented but for now, ony one exists.</p>
<h2 id="dircache"><a class="header" href="#dircache">DirCache</a></h2>
<p>This cache is based on a shared dir and requires no running daemon.</p>
<p>It must be initialized with a file <code>LMAKE/size</code> containing the overall size the cache is allowed to occupy.
The value may end with a unit suffix in <code>k</code>, <code>M</code>, <code>G</code>, <code>T</code> (powers of 1024).
For example <code>LMAKE/size</code> can contain <code>1.5T</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="encoding-and-decoding"><a class="header" href="#encoding-and-decoding">Encoding and decoding</a></h1>
<p>In some situations with heavily parameterized generated files, file names can become very long.
Think of the mere compilation of a C++ file <code>foo.c</code>.
You may want to specify:</p>
<ul>
<li>the optimization level through a <code>-O</code> argument</li>
<li>Whether debug checks are enable through the definition of <code>NDEBUG</code></li>
<li>a trace level through the definition of a macro such as <code>TRACE_LEVEL</code></li>
<li>whether and how to instrument with <code>-fsanitize</code></li>
<li>whether some internal data are 32 or 64 bits</li>
<li>whether to use a reference algorithm or an agressively optimized one used in production.</li>
<li>...</li>
</ul>
<p>You may want to be able to generate any combination so as, for example, compare the output of any 2 of them for validation purpose.
You easily end up with an object file with a name such as <code>foo.O3.NDEBUG.TRACE_LEVEL=1.sanitize=address.32.o</code>.
Already 50 characters or so.
In a real projects, file names can easily be 200, 300, 400 characters long.</p>
<p>As long as the file name, with adequate shorthands such as using <code>TL</code> instead of <code>TRACE_LEVEL</code> fits within a few hundreds of characters, the situation is heavy but manageable.
But if you need, say 3000 characters to specify a file, then it becomes completely impractical.</p>
<p>When the configuration can be devised in advance, in a stable way, an efficient alternative is to create a file to contain it, which becomes a configuration name,
and just specify the configuration name in the generated file.</p>
<p>In the example above, you may have a file <code>test.opts</code> that contains options for testing and <code>prod.opts</code> that contains options for production.
then, your object file is simply named <code>foo.test.o</code> or <code>foo.prod.o</code>.</p>
<p>When it is not, the situation is more complex and you need to automatically generate these configuration files with reasonably short names.
A practical and stable way to generate short names is to compute a checksum on the parameters.
You then need a way to retrieve the original parameters from the checksum to generate the generated file (the <code>.o</code> file in our example).
In doing so, you must account for:</p>
<ul>
<li>robustness    : because such checksums are subject to the birthday paradox, you need either to deal with collisions are provide enough margin (roughly doubling the size) to avoid them.</li>
<li>repeatability : your system must not prevent you from being able to repeat a scenario that was generated some days, weeks, months earlier.</li>
<li>merging       : when you invent a name, think that some colleagues working on the same project may also invent names, and they may collide.
Tools such as <code>git</code> are there to help you in this process, but your scheme must be git friendly.</li>
<li>performance   : you must have a scheme that support as many code/value associations as necessary for your case, without spending most of its time searching for value when given a code.</li>
<li>communication : ideally, you may want to signal a bug to a colleague by just telling him "build that target, and you see the bug".
If the target refers to a code, he may need some further steps to create the code/value association, which goes against communication.</li>
</ul>
<p>One way to deal with this case is to create a central database, with the following pros and cons:</p>
<ul>
<li>robustness    : collisions can easily be dealt with.</li>
<li>repeatability : this is a probleme. When dealing with collisions, some codes change, which change old repo because the database is not itself versioned. This is a serious problem.</li>
<li>merging       : no merging.</li>
<li>perfomance    : accessing the data in a performant way is easy. Detecting modifications so that open-lmake can take sound decisions may be more challenging.</li>
<li>communication : excellent, the database is shared</li>
<li>installation  : you need a server, configure clients to connect to it, etc. it is some work</li>
<li>maintainance  : as any central services, you may inadvertently enter wrong data, you need a way to administer it as it has the potential to block the whole team.</li>
</ul>
<p>The <code>lencode</code>/<code>ldecode</code> commands (or the <code>lmake.encode</code>/<code>lmake.decode</code> fonctions) are there to address this question.</p>
<p>The principle of operation is the following:</p>
<ul>
<li>There are a certain number of files storing code/value associations. These are sources seen from open-lmake, i.e. they are normally managed by <code>git</code>.</li>
<li>To keep the number of such files to a reasonably low level (say low compared to the overal number of sources), there are contexts, mostly used as a subdivision of files</li>
<li>So, a file provides a certain number of tables (the contexts), each table associating some codes with some values</li>
<li>These tables are stored in files as lines containing triplet : context, code, value</li>
<li>When reading, <code>lencode</code>/<code>ldecode</code> are very flexible. The files may contain garbage lines, duplicates, collisions, they are all ignored.
When 2 values are associated with the same code by 2 different lines, a new code is generated by lengthening one of them with further digites of the checksum computed on the value.
When 2 codes are associated with the same value by 2 different lines, only one code is retained, the shorter of the 2 (or any if of equal length).</li>
<li>When writing, <code>lencode</code>/<code>ldecode</code> are very rigid. File is generated sorted, with no garbage lines, nor duplicates, or collisions.</li>
<li>When open-lmake starts and read a file, it write it back in its canonical form.</li>
<li>When open-lmake runs, that <code>lencode</code> is used and generate new codes on the fly, additional lines are merely appended to the file.</li>
</ul>
<p>This has the following properties:</p>
<ul>
<li>Information is under git. No further server, central database, management, configuration etc.</li>
<li>repeatability is excellent. As long as you do not merge, your are insensitive to external activities.
When merging, the probability of collision depends on the length of the used codes, which is under user control.
Moreover, the length increasing automatically with collisions maintain the number of such collision to a reasonably low level, even in fully automatic mode.</li>
<li>Merging is very easy : actually one need not even merge. The simple collision file generated by <code>git</code> can be used as is. This makes this tool very <code>git</code> friendly.</li>
<li>Robustness is perfect : collisions are detected and dealt with.</li>
<li>Coherence is perfect : seen from open-lmake, each association is managed as a source.
If anything changes (i.e. a new value is associated with an old code or a new code is associated with an old value), the adequate jobs are rerun.</li>
<li>Performance is very good as the content of the file is cached in a performance friendly format by open-lmake. And update to the file is done by a simple append.
However, the file is sorted at every <code>lmake</code> command, making the content more rigid and the merge process easier.</li>
<li>Associations files can be editing by hand, so that human friendly codes may be associated to some heavily used values.
<code>lencode</code> will only generate codes from checksums, but will handle any code generated externally (manually or otherwise).
In case of collision and when open-lmake must suppress one of 2 codes, externally generated codes are given preference as they believed to be more readable.
If 2 externally generated codes collide, a numerical suffix is appended or incremented to solve the collision.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="sub-repos"><a class="header" href="#sub-repos">Sub-repos</a></h1>
<p>Sub-repos are repos that contain repos, i.e. some <code>Lmakefile.py</code> are present in sub-dirs.</p>
<p>In that situation, it is reasonable to assume that the <code>Lmakefile.py</code> are made to handle building files underneath it.</p>
<p>To support this situation, open-lmake allow you to simply mention such sub-repos, so that:</p>
<ul>
<li>Targets only match within the sub-repo (and escape is possibly by setting the <code>top</code> flag to the target to provide global rules).</li>
<li>The same applies to deps.</li>
<li><code>cmd</code> is run from this sub-repo, i.e. its cwd is set accordingly.</li>
<li>The priority of deeper rules are matched first, so that builds in a sub-repo is not pertubated by rules of englobing repo.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!-- This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)-->
<!-- Copyright (c) 2023-2025 Doliam-->
<!-- This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).-->
<!-- This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.-->
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="acronyms"><a class="header" href="#acronyms">Acronyms</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Acronym</th><th>Definition</th><th>Comment</th></tr></thead><tbody>
<tr><td>CAD</td><td>Computer Aided Design</td><td></td></tr>
<tr><td>ETA</td><td>Estimated Time of Arrival</td><td>(from aeronautic jargon) This is the date at which a given event is estimated to occur</td></tr>
<tr><td>ETE</td><td>Estimated Time Enroute</td><td>(from aeronautic jargon) This is the remaining time necessary to complete a task</td></tr>
<tr><td>LRU</td><td>Least Recently Used</td><td>A classical cache replacement policy where the entry that was least recently used is discarded when a new one is allocated</td></tr>
<tr><td>MRO</td><td>Method Research Order</td><td>The inheritance chain from the current class to its most basic base, usually <code>object</code></td></tr>
</tbody></table>
</div>
<h2 id="abbreviations"><a class="header" href="#abbreviations">Abbreviations</a></h2>
<p>Some words are so heavily used in this documentation that abbreviating them greatly improve readability.</p>
<div class="table-wrapper"><table><thead><tr><th>Abbreviation</th><th>Definition</th></tr></thead><tbody>
<tr><td>dep</td><td>dependency</td></tr>
<tr><td>dir</td><td>directory</td></tr>
<tr><td>repo</td><td>repository</td></tr>
</tbody></table>
</div>
<h2 id="vocabulary-in-messages"><a class="header" href="#vocabulary-in-messages">Vocabulary in messages</a></h2>
<p>Regularly, open-lmake generate some messages.
In order to keep such messages reasonably terse, a dedicated vocabulary is used.
This vocabulary is meant to be intuitive, but a full explanation is given here.</p>
<h3 id="consider"><a class="header" href="#consider">Consider</a></h3>
<p>When open-lmake finds an error and has a reasonable suggestion to fix it, it also generates an action likely to be done by the user.
Wuch action are generated in a form that can be as directly copy-pasted as possible.</p>
<p>When such action is linked to the source versioning system, <code>git</code> is assumed (which is by far the most commonly used system).
In case another source versioning system is used, the user must adapt the suggested action.</p>
<h3 id="dangling"><a class="header" href="#dangling">Dangling</a></h3>
<p>A dangling file refers to an existing file with no way to generate it (i.e. no rules apply) but which is not controlled by the source versioning system.</p>
<p>Open-lmake considers depending on such a file an error as such dep would go against repeatability, i.e. a <code>git push</code> followed by a <code>git pull</code> in another repo would not transport said file.</p>
<h3 id="manual"><a class="header" href="#manual">Manual</a></h3>
<p>A manual file refers to a file that has been modified outside open-lmake control (i.e. it is not the result of the execution of a job).</p>
<h3 id="official-job"><a class="header" href="#official-job">Official job</a></h3>
<p>The official job of a target is the one that would be selected to generate it upon execution of the command <code>lmake &lt;target&gt;</code>.
If no such job exists, the official state of such target is to not exist.</p>
<p>When open-lmake needs a dep for a job, it ensures its content is its official content (i.e. it is generated by its official job) for the job to be up-to-date.</p>
<p>A target may be generated by other means, such as written by a job as a <code>side_target</code> or allowed to be written by a call to <code>lmake.target</code> or <code>ltarget</code>.
This does not make such target officially generated, but actually generated : open-lmake has no means to find out the right job to execute should it need to (re)generate it.</p>
<h3 id="polluted"><a class="header" href="#polluted">Polluted</a></h3>
<p>A polluted file refers to a file that has been actually generated by a non-official job.</p>
<h3 id="quarantine"><a class="header" href="#quarantine">Quarantine</a></h3>
<p>Before executing a job, open-lmake ensures its targets do not exist (unless they are <code>incremental</code>) to ensure repeatable executions.
This may lead it to unlink such files if they have been previously generated.</p>
<p>However, if a target is determined to be manual (cf. above), it might contain valuable information that the user would be upset to lose.</p>
<p>In such cases, unless open-lmake can determine that no valuable information is present, instead of unlinking the file, it moves it to the <code>LMAKE/quaranntine</code> dir where it can be retrieved by the user.
Open-lmake considers that there is no valuable information in 2 cases:</p>
<ul>
<li>the file is empty</li>
<li>the file is identical to its previous content (typically, it has been edited, saved, but not modified)</li>
</ul>
<h3 id="steady"><a class="header" href="#steady">Steady</a></h3>
<p>A job is steady when it has been run, but all targets have been generated identically to the previous run, i.e. the job could have not ben run with no semantic consequences.</p>
<p>This may be an indication that the flow is suboptimal.
Consider 2 cases:</p>
<ul>
<li>a source file is modified, but only comments have been touched. Compilation is run as the source is modified, but the result is identical to its previous content.</li>
<li>a source file includes an include file (e.g. in C) or import a module (e.g. in Python), but does not actually use such include file/module.</li>
</ul>
<p>In the first case, it is very difficult to devise a flow to avoid such compilation.
A possibility would be to split the compilation process into 2 parts, the first one filtering out comments,
this has generally adverse consequences (such as line numbers being altered or source file name being difficult to trace).</p>
<p>In the second case, the solution is probably pretty trivial : just suppress the contemplated include/import line.</p>
<h3 id="uniquify"><a class="header" href="#uniquify">Uniquify</a></h3>
<p>When hard links are used and open-lmake decides that one of the link must be regenerated, sharing is no more possible.</p>
<p>If such a target is not incremental, it will be unlinked, regenerated and the other link will not be modified.
But if such a target is incremental, it is not unlinked but a copy must be done to split the links between those that must be updated by the job execution and those the must not.</p>
<p>This process is called "uniquify".</p>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<h3 id="birthday-paradox"><a class="header" href="#birthday-paradox">Birthday paradox</a></h3>
<p>This is a wellknown counter intuitive problem linked to checksum collision.</p>
<p>It is extensively described <a href="https://en.wikipedia.org/wiki/Birthday_problem">here</a>.</p>
<h3 id="diamond-rule"><a class="header" href="#diamond-rule">diamond rule</a></h3>
<p>A feature of python that allows the following behavior:</p>
<ul>
<li>A class <code>D</code> inherits from <code>B</code> and <code>C</code> in that order.</li>
<li>Both <code>B</code> and <code>C</code> inherit from a class <code>A</code>.</li>
<li>A method <code>m</code> is defined on <code>A</code> and <code>C</code> but not on <code>B</code>.</li>
<li>Then if <code>m</code> is called from an instance of <code>D</code>, <code>C.m</code> will be called and not <code>B.m</code> (which turns out to be <code>A.m</code>).</li>
</ul>
<p>It is extensively described <a href="https://docs.python.org/3.12/whatsnew/2.2.html#multiple-inheritance-the-diamond-rule">here</a>.</p>
<p>This feature is a central point that makes python multiple inheritance easy to use and enables the class hierarchy shopping list style.</p>
<p>python computes the MRO in such a way as to enforce the diamond rule.</p>
<div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
