#!/bin/bash
# vim: filetype=python
# This file is part of the open-lmake distribution (git@github.com:cesar-douady/open-lmake.git)
# Copyright (c) 2023-2026 Doliam
# This program is free software: you can redistribute/modify under the terms of the GPL-v3 (https://www.gnu.org/licenses/gpl-3.0.html).
# This program is distributed WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

exec $PYTHON <<EOF

import hashlib
import os
import re
import sys

action    = '$1'
slots_def = '$2'

def to_snake(camel) :
	return re.sub(r'(.)([A-Z])',r'\1_\2',camel).lower()

def from_cc(file,slots) :
	tab = { slot:(0,'') for slot in slots }
	for line in open(file) :
		m = re.match(fr'\t*uint64_t *constexpr *(\w+) *= *([0-9]+) *; *// *([0-9a-f]+)\n',line)
		if not m                      : continue
		if m.groups()[0] not in slots : continue
		tab[m.groups()[0]] = ( int(m.groups()[1]) , m.groups()[2] or '' )
	return tab

def mk_slots(file) :
	slots = []
	for line in open(file) :
		m = re.match(fr'\t*extern *uint64_t *const *(\w+) *;( *//.*)?\n',line)
		if not m : continue
		slot = m.groups()[0]
		if slot in ('Major','Tag') : continue
		if m : slots.append(slot)
	return slots

if action=='gen' :

	prev_cc   = '$3'
	src       = '$4'

	def analyze(file,slots) :
		content = open(file).read()
		#
		tab = {}
		#
		for slot in slots :
			lines    = '\n'.join( m[0] for m in re.findall(fr'(.*//.*START_OF_VERSIONING(.*{to_snake(slot).upper()}.*)?\n[\s\S]*?END_OF_VERSIONING.*)',content) )
			semantic = re.sub(r'//.*',''    ,lines   )
			semantic = re.sub(r'/\*.*\*/','',semantic)
			semantic = re.sub(r'[ \t\n]' ,'',semantic)
			#
			h = hashlib.md5()
			h.update(semantic.encode())
			tab[slot] = ( h.hexdigest() , lines )
		return tab

	def merge(prev_tab,new_crcs) :
		tab = {}
		for slot,prev in prev_tab.items() :
			if new_crcs[slot][0]==prev[1] : tab[slot] = ( prev[0]   , new_crcs[slot] )
			else                          : tab[slot] = ( prev[0]+1 , new_crcs[slot] )
		return tab

	def mk_cc(tab) :
		wk = max( len('Major') , len('Tag') , *(len(slot) for slot in tab.keys()) )
		wv = len(os.getenv('VERSION'))+2
		txt = ''
		txt +=  '#include "version.hh"\n'
		txt +=  'namespace Version {\n'
		for slot,entry in tab.items() :
			val,(crc,lines) = entry
			txt += f'\tuint64_t    constexpr {slot:<{wk}} = {val:<{wv}} ; // {crc}\n'
		txt += f'\tconst char* const     {"Major":<{wk}} = "{os.getenv("VERSION"):<{wv-2}}" ;\n'
		txt += f'\tuint64_t    constexpr {"Tag"  :<{wk}} = { os.getenv("TAG"    ):<{wv   }} ;\n'
		txt +=  '}\n'
		for slot,entry in tab.items() :
			val,(crc,lines) = entry
			txt += '\n'
			txt += f"// **{'*'*len(slot)}***{'*'*len(crc)}**\n"
			txt += f'// * {slot} : {crc} *\n'
			txt += f"// **{'*'*len(slot)}***{'*'*len(crc)}**\n"
			txt += '//\n'
			txt += '//' + lines.replace('\n','\n//\t').replace('\t\n','\n')
			if txt[-1]!='\n' : txt += '\n'
		return txt

	slots         = mk_slots( slots_def                )
	prev_tab      = from_cc ( prev_cc  , slots         )
	new_crc_lines = analyze ( src      , slots         )
	new_tab       = merge   ( prev_tab , new_crc_lines )
	#
	sys.stdout.write(mk_cc(new_tab))

elif action=='cc_to_py' :

	cc = '$3'

	def mk_py(tab) :
		txt = ''
		w = max(len(to_snake(k)) for k in tab.keys())
		for k,(idx,crc) in tab.items() :
			txt += f'{to_snake(k):{w}} = {idx}\n'
		return txt

	slots = mk_slots( slots_def  )
	tab   = from_cc ( cc , slots )
	sys.stdout.write(mk_py(tab))

EOF
